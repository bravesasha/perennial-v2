{
  "address": "0x8238fC11566d092aB15103E54E6e30fA2544af7d",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "implementation",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "UFixed18",
              "name": "multiplierBase",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "bufferBase",
              "type": "uint256"
            },
            {
              "internalType": "UFixed18",
              "name": "multiplierCalldata",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "bufferCalldata",
              "type": "uint256"
            }
          ],
          "internalType": "struct IKept.KeepConfig",
          "name": "keepConfig",
          "type": "tuple"
        },
        {
          "internalType": "contract IVerifierBase",
          "name": "nonceManager",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "ControllerGroupBalancedError",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ControllerInvalidRebalanceConfigError",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ControllerInvalidRebalanceGroupError",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ControllerInvalidRebalanceMarketsError",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ControllerInvalidRebalanceTargetsError",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ControllerInvalidSignerError",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "contract IMarket",
          "name": "market",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "group",
          "type": "uint256"
        }
      ],
      "name": "ControllerMarketAlreadyInGroupError",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "contract IMarket",
          "name": "market",
          "type": "address"
        }
      ],
      "name": "ControllerUnsupportedMarketError",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "FactoryNotInstanceError",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "version",
          "type": "uint256"
        }
      ],
      "name": "InitializableAlreadyInitializedError",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InitializableNotInitializingError",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InitializableZeroVersionError",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "OwnableAlreadyInitializedError",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "OwnableNotOwnerError",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "OwnableNotPendingOwnerError",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "PausableNotPauserError",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "PausablePausedError",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "int256",
          "name": "value",
          "type": "int256"
        }
      ],
      "name": "UFixed18UnderflowError",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "contract IAccount",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "AccountDeployed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "group",
          "type": "uint256"
        }
      ],
      "name": "GroupRebalanced",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "version",
          "type": "uint256"
        }
      ],
      "name": "Initialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "contract IInstance",
          "name": "instance",
          "type": "address"
        }
      ],
      "name": "InstanceRegistered",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "applicableGas",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "applicableValue",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "UFixed18",
          "name": "baseFee",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "UFixed18",
          "name": "calldataFee",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "UFixed18",
          "name": "keeperFee",
          "type": "uint256"
        }
      ],
      "name": "KeeperCall",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnerUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [],
      "name": "Paused",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "newPauser",
          "type": "address"
        }
      ],
      "name": "PauserUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "newPendingOwner",
          "type": "address"
        }
      ],
      "name": "PendingOwnerUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "group",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "markets",
          "type": "uint256"
        }
      ],
      "name": "RebalanceGroupConfigured",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "group",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "market",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "UFixed6",
              "name": "target",
              "type": "uint256"
            },
            {
              "internalType": "UFixed6",
              "name": "threshold",
              "type": "uint256"
            }
          ],
          "indexed": false,
          "internalType": "struct RebalanceConfig",
          "name": "newConfig",
          "type": "tuple"
        }
      ],
      "name": "RebalanceMarketConfigured",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [],
      "name": "Unpaused",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "ARB_FIXED_OVERHEAD",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ARB_GAS_MULTIPLIER",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "DSU",
      "outputs": [
        {
          "internalType": "Token18",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "USDC",
      "outputs": [
        {
          "internalType": "Token6",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "acceptOwner",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "group",
              "type": "uint256"
            },
            {
              "internalType": "address[]",
              "name": "markets",
              "type": "address[]"
            },
            {
              "components": [
                {
                  "internalType": "UFixed6",
                  "name": "target",
                  "type": "uint256"
                },
                {
                  "internalType": "UFixed6",
                  "name": "threshold",
                  "type": "uint256"
                }
              ],
              "internalType": "struct RebalanceConfig[]",
              "name": "configs",
              "type": "tuple[]"
            },
            {
              "internalType": "UFixed6",
              "name": "maxFee",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "UFixed6",
                  "name": "maxFee",
                  "type": "uint256"
                },
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "account",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "signer",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "domain",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "nonce",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "group",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expiry",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct Common",
                  "name": "common",
                  "type": "tuple"
                }
              ],
              "internalType": "struct Action",
              "name": "action",
              "type": "tuple"
            }
          ],
          "internalType": "struct RebalanceConfigChange",
          "name": "configChange",
          "type": "tuple"
        },
        {
          "internalType": "bytes",
          "name": "signature",
          "type": "bytes"
        }
      ],
      "name": "changeRebalanceConfigWithSignature",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "group",
          "type": "uint256"
        }
      ],
      "name": "checkGroup",
      "outputs": [
        {
          "internalType": "Fixed6",
          "name": "groupCollateral",
          "type": "int256"
        },
        {
          "internalType": "bool",
          "name": "canRebalance",
          "type": "bool"
        },
        {
          "internalType": "Fixed6[]",
          "name": "imbalances",
          "type": "int256[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "deployAccount",
      "outputs": [
        {
          "internalType": "contract IAccount",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "UFixed6",
                  "name": "maxFee",
                  "type": "uint256"
                },
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "account",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "signer",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "domain",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "nonce",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "group",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expiry",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct Common",
                  "name": "common",
                  "type": "tuple"
                }
              ],
              "internalType": "struct Action",
              "name": "action",
              "type": "tuple"
            }
          ],
          "internalType": "struct DeployAccount",
          "name": "deployAccount_",
          "type": "tuple"
        },
        {
          "internalType": "bytes",
          "name": "signature",
          "type": "bytes"
        }
      ],
      "name": "deployAccountWithSignature",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ethTokenOracleFeed",
      "outputs": [
        {
          "internalType": "contract AggregatorV3Interface",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "getAccountAddress",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "groupToMarkets",
      "outputs": [
        {
          "internalType": "contract IMarket",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "groupToMaxRebalanceFee",
      "outputs": [
        {
          "internalType": "UFixed6",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "implementation",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IMarketFactory",
          "name": "marketFactory_",
          "type": "address"
        },
        {
          "internalType": "contract IAccountVerifier",
          "name": "verifier_",
          "type": "address"
        }
      ],
      "name": "initialize",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IMarketFactory",
          "name": "marketFactory_",
          "type": "address"
        },
        {
          "internalType": "contract IAccountVerifier",
          "name": "verifier_",
          "type": "address"
        },
        {
          "internalType": "contract AggregatorV3Interface",
          "name": "chainlinkFeed_",
          "type": "address"
        }
      ],
      "name": "initialize",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IInstance",
          "name": "instance",
          "type": "address"
        }
      ],
      "name": "instances",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "keepConfig",
      "outputs": [
        {
          "internalType": "UFixed18",
          "name": "multiplierBase",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "bufferBase",
          "type": "uint256"
        },
        {
          "internalType": "UFixed18",
          "name": "multiplierCalldata",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "bufferCalldata",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "keeperToken",
      "outputs": [
        {
          "internalType": "Token18",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "marketFactory",
      "outputs": [
        {
          "internalType": "contract IMarketFactory",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "marketToGroup",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "market",
              "type": "address"
            },
            {
              "internalType": "Fixed6",
              "name": "amount",
              "type": "int256"
            },
            {
              "components": [
                {
                  "internalType": "UFixed6",
                  "name": "maxFee",
                  "type": "uint256"
                },
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "account",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "signer",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "domain",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "nonce",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "group",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expiry",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct Common",
                  "name": "common",
                  "type": "tuple"
                }
              ],
              "internalType": "struct Action",
              "name": "action",
              "type": "tuple"
            }
          ],
          "internalType": "struct MarketTransfer",
          "name": "marketTransfer",
          "type": "tuple"
        },
        {
          "internalType": "bytes",
          "name": "signature",
          "type": "bytes"
        }
      ],
      "name": "marketTransferWithSignature",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "nonceManager",
      "outputs": [
        {
          "internalType": "contract IVerifierBase",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "pause",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "paused",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "pauser",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "pendingOwner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "group",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "market",
          "type": "address"
        }
      ],
      "name": "rebalanceConfigs",
      "outputs": [
        {
          "components": [
            {
              "internalType": "UFixed6",
              "name": "target",
              "type": "uint256"
            },
            {
              "internalType": "UFixed6",
              "name": "threshold",
              "type": "uint256"
            }
          ],
          "internalType": "struct RebalanceConfig",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "group",
          "type": "uint256"
        }
      ],
      "name": "rebalanceGroup",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "group",
          "type": "uint256"
        }
      ],
      "name": "rebalanceGroupMarkets",
      "outputs": [
        {
          "internalType": "contract IMarket[]",
          "name": "markets",
          "type": "address[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "components": [
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "accessor",
                      "type": "address"
                    },
                    {
                      "internalType": "bool",
                      "name": "approved",
                      "type": "bool"
                    }
                  ],
                  "internalType": "struct AccessUpdate[]",
                  "name": "operators",
                  "type": "tuple[]"
                },
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "accessor",
                      "type": "address"
                    },
                    {
                      "internalType": "bool",
                      "name": "approved",
                      "type": "bool"
                    }
                  ],
                  "internalType": "struct AccessUpdate[]",
                  "name": "signers",
                  "type": "tuple[]"
                },
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "account",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "signer",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "domain",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "nonce",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "group",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expiry",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct Common",
                  "name": "common",
                  "type": "tuple"
                }
              ],
              "internalType": "struct AccessUpdateBatch",
              "name": "accessUpdateBatch",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "UFixed6",
                  "name": "maxFee",
                  "type": "uint256"
                },
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "account",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "signer",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "domain",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "nonce",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "group",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expiry",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct Common",
                  "name": "common",
                  "type": "tuple"
                }
              ],
              "internalType": "struct Action",
              "name": "action",
              "type": "tuple"
            }
          ],
          "internalType": "struct RelayedAccessUpdateBatch",
          "name": "message",
          "type": "tuple"
        },
        {
          "internalType": "bytes",
          "name": "outerSignature",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "innerSignature",
          "type": "bytes"
        }
      ],
      "name": "relayAccessUpdateBatch",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "group",
                  "type": "uint256"
                },
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "account",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "signer",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "domain",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "nonce",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "group",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expiry",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct Common",
                  "name": "common",
                  "type": "tuple"
                }
              ],
              "internalType": "struct GroupCancellation",
              "name": "groupCancellation",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "UFixed6",
                  "name": "maxFee",
                  "type": "uint256"
                },
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "account",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "signer",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "domain",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "nonce",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "group",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expiry",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct Common",
                  "name": "common",
                  "type": "tuple"
                }
              ],
              "internalType": "struct Action",
              "name": "action",
              "type": "tuple"
            }
          ],
          "internalType": "struct RelayedGroupCancellation",
          "name": "message",
          "type": "tuple"
        },
        {
          "internalType": "bytes",
          "name": "outerSignature",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "innerSignature",
          "type": "bytes"
        }
      ],
      "name": "relayGroupCancellation",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "account",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "signer",
                  "type": "address"
                },
                {
                  "internalType": "address",
                  "name": "domain",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "nonce",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "group",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "expiry",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Common",
              "name": "nonceCancellation",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "UFixed6",
                  "name": "maxFee",
                  "type": "uint256"
                },
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "account",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "signer",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "domain",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "nonce",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "group",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expiry",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct Common",
                  "name": "common",
                  "type": "tuple"
                }
              ],
              "internalType": "struct Action",
              "name": "action",
              "type": "tuple"
            }
          ],
          "internalType": "struct RelayedNonceCancellation",
          "name": "message",
          "type": "tuple"
        },
        {
          "internalType": "bytes",
          "name": "outerSignature",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "innerSignature",
          "type": "bytes"
        }
      ],
      "name": "relayNonceCancellation",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "components": [
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "accessor",
                      "type": "address"
                    },
                    {
                      "internalType": "bool",
                      "name": "approved",
                      "type": "bool"
                    }
                  ],
                  "internalType": "struct AccessUpdate",
                  "name": "access",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "account",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "signer",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "domain",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "nonce",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "group",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expiry",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct Common",
                  "name": "common",
                  "type": "tuple"
                }
              ],
              "internalType": "struct OperatorUpdate",
              "name": "operatorUpdate",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "UFixed6",
                  "name": "maxFee",
                  "type": "uint256"
                },
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "account",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "signer",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "domain",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "nonce",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "group",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expiry",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct Common",
                  "name": "common",
                  "type": "tuple"
                }
              ],
              "internalType": "struct Action",
              "name": "action",
              "type": "tuple"
            }
          ],
          "internalType": "struct RelayedOperatorUpdate",
          "name": "message",
          "type": "tuple"
        },
        {
          "internalType": "bytes",
          "name": "outerSignature",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "innerSignature",
          "type": "bytes"
        }
      ],
      "name": "relayOperatorUpdate",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "components": [
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "accessor",
                      "type": "address"
                    },
                    {
                      "internalType": "bool",
                      "name": "approved",
                      "type": "bool"
                    }
                  ],
                  "internalType": "struct AccessUpdate",
                  "name": "access",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "account",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "signer",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "domain",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "nonce",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "group",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expiry",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct Common",
                  "name": "common",
                  "type": "tuple"
                }
              ],
              "internalType": "struct SignerUpdate",
              "name": "signerUpdate",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "UFixed6",
                  "name": "maxFee",
                  "type": "uint256"
                },
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "account",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "signer",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "domain",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "nonce",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "group",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expiry",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct Common",
                  "name": "common",
                  "type": "tuple"
                }
              ],
              "internalType": "struct Action",
              "name": "action",
              "type": "tuple"
            }
          ],
          "internalType": "struct RelayedSignerUpdate",
          "name": "message",
          "type": "tuple"
        },
        {
          "internalType": "bytes",
          "name": "outerSignature",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "innerSignature",
          "type": "bytes"
        }
      ],
      "name": "relaySignerUpdate",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "unpause",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newPauser",
          "type": "address"
        }
      ],
      "name": "updatePauser",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newPendingOwner",
          "type": "address"
        }
      ],
      "name": "updatePendingOwner",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "verifier",
      "outputs": [
        {
          "internalType": "contract IAccountVerifier",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "UFixed6",
              "name": "amount",
              "type": "uint256"
            },
            {
              "internalType": "bool",
              "name": "unwrap",
              "type": "bool"
            },
            {
              "components": [
                {
                  "internalType": "UFixed6",
                  "name": "maxFee",
                  "type": "uint256"
                },
                {
                  "components": [
                    {
                      "internalType": "address",
                      "name": "account",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "signer",
                      "type": "address"
                    },
                    {
                      "internalType": "address",
                      "name": "domain",
                      "type": "address"
                    },
                    {
                      "internalType": "uint256",
                      "name": "nonce",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "group",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "expiry",
                      "type": "uint256"
                    }
                  ],
                  "internalType": "struct Common",
                  "name": "common",
                  "type": "tuple"
                }
              ],
              "internalType": "struct Action",
              "name": "action",
              "type": "tuple"
            }
          ],
          "internalType": "struct Withdrawal",
          "name": "withdrawal",
          "type": "tuple"
        },
        {
          "internalType": "bytes",
          "name": "signature",
          "type": "bytes"
        }
      ],
      "name": "withdrawWithSignature",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x52832a5c9bfca1f35cfcdea3628fd668e1fad54e7c13226989d168268e72756e",
  "receipt": {
    "to": null,
    "from": "0x66a7fDB96C583c59597de16d8b2B989231415339",
    "contractAddress": "0x8238fC11566d092aB15103E54E6e30fA2544af7d",
    "transactionIndex": 16,
    "gasUsed": "4883400",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x5bfdcbd7c44f69260b79981429b3775cfd31c27b789e86c788563ee3726fe4fe",
    "transactionHash": "0x52832a5c9bfca1f35cfcdea3628fd668e1fad54e7c13226989d168268e72756e",
    "logs": [],
    "blockNumber": 86734412,
    "cumulativeGasUsed": "8643666",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x53B6D8d2D8c4802085AD7FbFa300Adf034c5E3b1",
    {
      "multiplierBase": 0,
      "bufferBase": 0,
      "multiplierCalldata": 0,
      "bufferCalldata": 0
    },
    "0x6FaabfA2fDb093A027Ed16F291ADc7F07780014A"
  ],
  "numDeployments": 4,
  "solcInputHash": "e123277fe3084afc1fa5abf5480a19e0",
  "metadata": "{\"compiler\":{\"version\":\"0.8.24+commit.e11b9ed9\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"UFixed18\",\"name\":\"multiplierBase\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bufferBase\",\"type\":\"uint256\"},{\"internalType\":\"UFixed18\",\"name\":\"multiplierCalldata\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bufferCalldata\",\"type\":\"uint256\"}],\"internalType\":\"struct IKept.KeepConfig\",\"name\":\"keepConfig\",\"type\":\"tuple\"},{\"internalType\":\"contract IVerifierBase\",\"name\":\"nonceManager\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ControllerGroupBalancedError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ControllerInvalidRebalanceConfigError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ControllerInvalidRebalanceGroupError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ControllerInvalidRebalanceMarketsError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ControllerInvalidRebalanceTargetsError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ControllerInvalidSignerError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"contract IMarket\",\"name\":\"market\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"group\",\"type\":\"uint256\"}],\"name\":\"ControllerMarketAlreadyInGroupError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"contract IMarket\",\"name\":\"market\",\"type\":\"address\"}],\"name\":\"ControllerUnsupportedMarketError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FactoryNotInstanceError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"}],\"name\":\"InitializableAlreadyInitializedError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InitializableNotInitializingError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InitializableZeroVersionError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnableAlreadyInitializedError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"OwnableNotOwnerError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"OwnableNotPendingOwnerError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"PausableNotPauserError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PausablePausedError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"value\",\"type\":\"int256\"}],\"name\":\"UFixed18UnderflowError\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IAccount\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AccountDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"group\",\"type\":\"uint256\"}],\"name\":\"GroupRebalanced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IInstance\",\"name\":\"instance\",\"type\":\"address\"}],\"name\":\"InstanceRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"applicableGas\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"applicableValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"UFixed18\",\"name\":\"baseFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"UFixed18\",\"name\":\"calldataFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"UFixed18\",\"name\":\"keeperFee\",\"type\":\"uint256\"}],\"name\":\"KeeperCall\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newPauser\",\"type\":\"address\"}],\"name\":\"PauserUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newPendingOwner\",\"type\":\"address\"}],\"name\":\"PendingOwnerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"group\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"markets\",\"type\":\"uint256\"}],\"name\":\"RebalanceGroupConfigured\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"group\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"UFixed6\",\"name\":\"target\",\"type\":\"uint256\"},{\"internalType\":\"UFixed6\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct RebalanceConfig\",\"name\":\"newConfig\",\"type\":\"tuple\"}],\"name\":\"RebalanceMarketConfigured\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ARB_FIXED_OVERHEAD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ARB_GAS_MULTIPLIER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DSU\",\"outputs\":[{\"internalType\":\"Token18\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDC\",\"outputs\":[{\"internalType\":\"Token6\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"group\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"markets\",\"type\":\"address[]\"},{\"components\":[{\"internalType\":\"UFixed6\",\"name\":\"target\",\"type\":\"uint256\"},{\"internalType\":\"UFixed6\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"internalType\":\"struct RebalanceConfig[]\",\"name\":\"configs\",\"type\":\"tuple[]\"},{\"internalType\":\"UFixed6\",\"name\":\"maxFee\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"UFixed6\",\"name\":\"maxFee\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"domain\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"group\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"}],\"internalType\":\"struct Common\",\"name\":\"common\",\"type\":\"tuple\"}],\"internalType\":\"struct Action\",\"name\":\"action\",\"type\":\"tuple\"}],\"internalType\":\"struct RebalanceConfigChange\",\"name\":\"configChange\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"changeRebalanceConfigWithSignature\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"group\",\"type\":\"uint256\"}],\"name\":\"checkGroup\",\"outputs\":[{\"internalType\":\"Fixed6\",\"name\":\"groupCollateral\",\"type\":\"int256\"},{\"internalType\":\"bool\",\"name\":\"canRebalance\",\"type\":\"bool\"},{\"internalType\":\"Fixed6[]\",\"name\":\"imbalances\",\"type\":\"int256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deployAccount\",\"outputs\":[{\"internalType\":\"contract IAccount\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"UFixed6\",\"name\":\"maxFee\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"domain\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"group\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"}],\"internalType\":\"struct Common\",\"name\":\"common\",\"type\":\"tuple\"}],\"internalType\":\"struct Action\",\"name\":\"action\",\"type\":\"tuple\"}],\"internalType\":\"struct DeployAccount\",\"name\":\"deployAccount_\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"deployAccountWithSignature\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethTokenOracleFeed\",\"outputs\":[{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getAccountAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"groupToMarkets\",\"outputs\":[{\"internalType\":\"contract IMarket\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"groupToMaxRebalanceFee\",\"outputs\":[{\"internalType\":\"UFixed6\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IMarketFactory\",\"name\":\"marketFactory_\",\"type\":\"address\"},{\"internalType\":\"contract IAccountVerifier\",\"name\":\"verifier_\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IMarketFactory\",\"name\":\"marketFactory_\",\"type\":\"address\"},{\"internalType\":\"contract IAccountVerifier\",\"name\":\"verifier_\",\"type\":\"address\"},{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"chainlinkFeed_\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IInstance\",\"name\":\"instance\",\"type\":\"address\"}],\"name\":\"instances\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"keepConfig\",\"outputs\":[{\"internalType\":\"UFixed18\",\"name\":\"multiplierBase\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bufferBase\",\"type\":\"uint256\"},{\"internalType\":\"UFixed18\",\"name\":\"multiplierCalldata\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bufferCalldata\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"keeperToken\",\"outputs\":[{\"internalType\":\"Token18\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketFactory\",\"outputs\":[{\"internalType\":\"contract IMarketFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"marketToGroup\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"},{\"internalType\":\"Fixed6\",\"name\":\"amount\",\"type\":\"int256\"},{\"components\":[{\"internalType\":\"UFixed6\",\"name\":\"maxFee\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"domain\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"group\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"}],\"internalType\":\"struct Common\",\"name\":\"common\",\"type\":\"tuple\"}],\"internalType\":\"struct Action\",\"name\":\"action\",\"type\":\"tuple\"}],\"internalType\":\"struct MarketTransfer\",\"name\":\"marketTransfer\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"marketTransferWithSignature\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nonceManager\",\"outputs\":[{\"internalType\":\"contract IVerifierBase\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauser\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"group\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"}],\"name\":\"rebalanceConfigs\",\"outputs\":[{\"components\":[{\"internalType\":\"UFixed6\",\"name\":\"target\",\"type\":\"uint256\"},{\"internalType\":\"UFixed6\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"internalType\":\"struct RebalanceConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"group\",\"type\":\"uint256\"}],\"name\":\"rebalanceGroup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"group\",\"type\":\"uint256\"}],\"name\":\"rebalanceGroupMarkets\",\"outputs\":[{\"internalType\":\"contract IMarket[]\",\"name\":\"markets\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"accessor\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"internalType\":\"struct AccessUpdate[]\",\"name\":\"operators\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"accessor\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"internalType\":\"struct AccessUpdate[]\",\"name\":\"signers\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"domain\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"group\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"}],\"internalType\":\"struct Common\",\"name\":\"common\",\"type\":\"tuple\"}],\"internalType\":\"struct AccessUpdateBatch\",\"name\":\"accessUpdateBatch\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"UFixed6\",\"name\":\"maxFee\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"domain\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"group\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"}],\"internalType\":\"struct Common\",\"name\":\"common\",\"type\":\"tuple\"}],\"internalType\":\"struct Action\",\"name\":\"action\",\"type\":\"tuple\"}],\"internalType\":\"struct RelayedAccessUpdateBatch\",\"name\":\"message\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"outerSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"innerSignature\",\"type\":\"bytes\"}],\"name\":\"relayAccessUpdateBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"group\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"domain\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"group\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"}],\"internalType\":\"struct Common\",\"name\":\"common\",\"type\":\"tuple\"}],\"internalType\":\"struct GroupCancellation\",\"name\":\"groupCancellation\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"UFixed6\",\"name\":\"maxFee\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"domain\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"group\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"}],\"internalType\":\"struct Common\",\"name\":\"common\",\"type\":\"tuple\"}],\"internalType\":\"struct Action\",\"name\":\"action\",\"type\":\"tuple\"}],\"internalType\":\"struct RelayedGroupCancellation\",\"name\":\"message\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"outerSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"innerSignature\",\"type\":\"bytes\"}],\"name\":\"relayGroupCancellation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"domain\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"group\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"}],\"internalType\":\"struct Common\",\"name\":\"nonceCancellation\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"UFixed6\",\"name\":\"maxFee\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"domain\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"group\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"}],\"internalType\":\"struct Common\",\"name\":\"common\",\"type\":\"tuple\"}],\"internalType\":\"struct Action\",\"name\":\"action\",\"type\":\"tuple\"}],\"internalType\":\"struct RelayedNonceCancellation\",\"name\":\"message\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"outerSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"innerSignature\",\"type\":\"bytes\"}],\"name\":\"relayNonceCancellation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"accessor\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"internalType\":\"struct AccessUpdate\",\"name\":\"access\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"domain\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"group\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"}],\"internalType\":\"struct Common\",\"name\":\"common\",\"type\":\"tuple\"}],\"internalType\":\"struct OperatorUpdate\",\"name\":\"operatorUpdate\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"UFixed6\",\"name\":\"maxFee\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"domain\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"group\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"}],\"internalType\":\"struct Common\",\"name\":\"common\",\"type\":\"tuple\"}],\"internalType\":\"struct Action\",\"name\":\"action\",\"type\":\"tuple\"}],\"internalType\":\"struct RelayedOperatorUpdate\",\"name\":\"message\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"outerSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"innerSignature\",\"type\":\"bytes\"}],\"name\":\"relayOperatorUpdate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"accessor\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"internalType\":\"struct AccessUpdate\",\"name\":\"access\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"domain\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"group\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"}],\"internalType\":\"struct Common\",\"name\":\"common\",\"type\":\"tuple\"}],\"internalType\":\"struct SignerUpdate\",\"name\":\"signerUpdate\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"UFixed6\",\"name\":\"maxFee\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"domain\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"group\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"}],\"internalType\":\"struct Common\",\"name\":\"common\",\"type\":\"tuple\"}],\"internalType\":\"struct Action\",\"name\":\"action\",\"type\":\"tuple\"}],\"internalType\":\"struct RelayedSignerUpdate\",\"name\":\"message\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"outerSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"innerSignature\",\"type\":\"bytes\"}],\"name\":\"relaySignerUpdate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPauser\",\"type\":\"address\"}],\"name\":\"updatePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPendingOwner\",\"type\":\"address\"}],\"name\":\"updatePendingOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"verifier\",\"outputs\":[{\"internalType\":\"contract IAccountVerifier\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"UFixed6\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unwrap\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"UFixed6\",\"name\":\"maxFee\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"domain\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"group\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"}],\"internalType\":\"struct Common\",\"name\":\"common\",\"type\":\"tuple\"}],\"internalType\":\"struct Action\",\"name\":\"action\",\"type\":\"tuple\"}],\"internalType\":\"struct Withdrawal\",\"name\":\"withdrawal\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"withdrawWithSignature\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"ControllerGroupBalancedError()\":[{\"custom:error\":\"Group is balanced and ineligible for rebalance\"}],\"ControllerInvalidRebalanceConfigError()\":[{\"custom:error\":\"A RebalanceConfigChange message had a mismatch in number of markets and configs\"}],\"ControllerInvalidRebalanceGroupError()\":[{\"custom:error\":\"Group number was out-of-range; each collateral account may have up to 8 groups, indexed 1-8\"}],\"ControllerInvalidRebalanceMarketsError()\":[{\"custom:error\":\"Group has too many markets; each group may have 1-4 markets\"}],\"ControllerInvalidRebalanceTargetsError()\":[{\"custom:error\":\"The sum of `target` collateral allocations for each market in a group does not total 100%. This could also indicate a duplicate market was in the list.\"}],\"ControllerInvalidSignerError()\":[{\"custom:error\":\"Signer is not authorized to interact with the specified collateral account\"}],\"ControllerMarketAlreadyInGroupError(address,uint256)\":[{\"custom:error\":\"A market in this rebalancing configuration is already a member of a different group\",\"params\":{\"group\":\"Identifies the group in which the aforementioned market is a member\",\"market\":\"Identifies which market in the message which is causing the problem\"}}],\"ControllerUnsupportedMarketError(address)\":[{\"custom:error\":\"Attempt to interact with a Market which does not use DSU as collateral\",\"params\":{\"market\":\"Market with non-DSU collateral\"}}]},\"events\":{\"AccountDeployed(address,address)\":{\"params\":{\"account\":\"contract address of the collateral account\",\"owner\":\"EOA for whom the collateral account was created\"}},\"GroupRebalanced(address,uint256)\":{\"params\":{\"group\":\"Identifies the rebalance group within context of owner\",\"owner\":\"Owner of the collateral account for which the rebalance group was created or modified\"}},\"RebalanceGroupConfigured(address,uint256,uint256)\":{\"params\":{\"group\":\"Identifies the rebalance group within context of owner\",\"markets\":\"Number of markets in the group (0 if group was deleted)\",\"owner\":\"Owner of the collateral account for which the rebalance group was created or modified\"}},\"RebalanceMarketConfigured(address,uint256,address,(uint256,uint256))\":{\"params\":{\"group\":\"Identifies the rebalance group within context of owner\",\"market\":\"The Perennial market for which this configuration applies\",\"newConfig\":\"Rebalance configuration for the market, which may or may not have changed\",\"owner\":\"Owner of the collateral account for which the rebalance group was created or modified\"}}},\"kind\":\"dev\",\"methods\":{\"acceptOwner()\":{\"details\":\"Can only be called by the pending owner to ensure correctness. Calls to the `_beforeAcceptOwner` hook      to perform logic before updating ownership.\"},\"changeRebalanceConfigWithSignature((uint256,address[],(uint256,uint256)[],uint256,(uint256,(address,address,address,uint256,uint256,uint256))),bytes)\":{\"params\":{\"configChange\":\"Message with new rebalance group configuration\",\"signature\":\"ERC712 message signature\"}},\"checkGroup(address,uint256)\":{\"params\":{\"group\":\"Identifies the group within the context of the owner\",\"owner\":\"User whose collateral account may be rebalanced using this group\"},\"returns\":{\"canRebalance\":\"True if one or more markets in the group are eligible for rebalancing\",\"groupCollateral\":\"Sum of ower's collateral across each market in the group\",\"imbalances\":\"The difference between target and actual collateral for each market\"}},\"constructor\":{\"details\":\"Creates instance of Controller which compensates keepers\",\"params\":{\"implementation\":\"Pristine collateral account contract\",\"keepConfig\":\"Configuration used to compensate keepers\"}},\"deployAccountWithSignature(((uint256,(address,address,address,uint256,uint256,uint256))),bytes)\":{\"params\":{\"deployAccountAction\":\"Message requesting creation of a collateral account\",\"signature\":\"ERC712 message signature\"}},\"getAccountAddress(address)\":{\"params\":{\"owner\":\"Identifies the user whose collateral account address is desired\"}},\"initialize(address,address)\":{\"params\":{\"marketFactory\":\"Contract used to validate delegated signers\",\"verifier\":\"Contract used to validate collateral account message signatures\"}},\"initialize(address,address,address)\":{\"params\":{\"chainlinkFeed_\":\"ETH-USD price feed used for calculating keeper compensation\",\"marketFactory_\":\"Contract used to validate delegated signers\",\"verifier_\":\"Contract used to validate collateral account message signatures\"}},\"instances(address)\":{\"params\":{\"instance\":\"The instance to check\"},\"returns\":{\"_0\":\"Whether the instance is valid\"}},\"marketTransferWithSignature((address,int256,(uint256,(address,address,address,uint256,uint256,uint256))),bytes)\":{\"params\":{\"marketTransfer\":\"Message requesting a deposit to or withdrawal from the Market\",\"signature\":\"ERC712 message signature\"}},\"pause()\":{\"details\":\"Can only be called by the pauser\"},\"rebalanceConfigs(address,uint256,address)\":{\"params\":{\"group\":\"Identifies a collection of markets, each with their own configuration\",\"market\":\"Identifies which Perennial market for which the configuration is desired\",\"owner\":\"User for whom the collateral account was created\"}},\"rebalanceGroup(address,uint256)\":{\"params\":{\"group\":\"Identifies the group within the context of the owner\",\"owner\":\"User whose collateral account may be rebalanced using this group\"}},\"rebalanceGroupMarkets(address,uint256)\":{\"params\":{\"group\":\"Identifies which collection of markets is desired for the owner\",\"owner\":\"User for whom the collateral account was created\"},\"returns\":{\"markets\":\"Array containing each market in the rebalance group\"}},\"relayAccessUpdateBatch((((address,bool)[],(address,bool)[],(address,address,address,uint256,uint256,uint256)),(uint256,(address,address,address,uint256,uint256,uint256))),bytes,bytes)\":{\"params\":{\"innerSignature\":\"Signature of the embedded AccessUpdateBatch message\",\"message\":\"Request with details needed for keeper compensation\",\"outerSignature\":\"Signature of the RelayedAccessUpdateBatch message\"}},\"relayGroupCancellation(((uint256,(address,address,address,uint256,uint256,uint256)),(uint256,(address,address,address,uint256,uint256,uint256))),bytes,bytes)\":{\"params\":{\"innerSignature\":\"Signature of the embedded GroupCancellation message\",\"message\":\"Request with details needed for keeper compensation\",\"outerSignature\":\"Signature of the RelayedGroupCancellation message\"}},\"relayNonceCancellation(((address,address,address,uint256,uint256,uint256),(uint256,(address,address,address,uint256,uint256,uint256))),bytes,bytes)\":{\"params\":{\"innerSignature\":\"Signature of the embedded Common message\",\"message\":\"Request with details needed for keeper compensation\",\"outerSignature\":\"Signature of the RelayedNonceCancellation message\"}},\"relayOperatorUpdate((((address,bool),(address,address,address,uint256,uint256,uint256)),(uint256,(address,address,address,uint256,uint256,uint256))),bytes,bytes)\":{\"params\":{\"innerSignature\":\"Signature of the embedded OperatorUpdate message\",\"message\":\"Request with details needed for keeper compensation\",\"outerSignature\":\"Signature of the RelayedOperatorUpdate message\"}},\"relaySignerUpdate((((address,bool),(address,address,address,uint256,uint256,uint256)),(uint256,(address,address,address,uint256,uint256,uint256))),bytes,bytes)\":{\"params\":{\"innerSignature\":\"Signature of the embedded SignerUpdate message\",\"message\":\"Request with details needed for keeper compensation\",\"outerSignature\":\"Signature of the RelayedSignerUpdate message\"}},\"unpause()\":{\"details\":\"Can only be called by the pauser\"},\"updatePauser(address)\":{\"details\":\"Can only be called by the current owner\",\"params\":{\"newPauser\":\"New pauser address\"}},\"updatePendingOwner(address)\":{\"details\":\"Can only be called by the current owner      New owner does not take affect until that address calls `acceptOwner()`\",\"params\":{\"newPendingOwner\":\"New pending owner address\"}},\"withdrawWithSignature((uint256,bool,(uint256,(address,address,address,uint256,uint256,uint256))),bytes)\":{\"params\":{\"signature\":\"ERC712 message signature\",\"withdrawal\":\"Message requesting a withdrawal\"}}},\"title\":\"Controller_Arbitrum\",\"version\":1},\"userdoc\":{\"events\":{\"AccountDeployed(address,address)\":{\"notice\":\"Emitted when a collateral account is deployed\"},\"GroupRebalanced(address,uint256)\":{\"notice\":\"Emitted when a group has been rebalanced\"},\"RebalanceGroupConfigured(address,uint256,uint256)\":{\"notice\":\"Emitted when a rebalance group is created or updated\"},\"RebalanceMarketConfigured(address,uint256,address,(uint256,uint256))\":{\"notice\":\"Emitted for each market in a rebalance group upon creation of the group or when any changes are made to the group\"}},\"kind\":\"user\",\"methods\":{\"acceptOwner()\":{\"notice\":\"Accepts and transfers the ownership of the contract to the pending owner\"},\"changeRebalanceConfigWithSignature((uint256,address[],(uint256,uint256)[],uint256,(uint256,(address,address,address,uint256,uint256,uint256))),bytes)\":{\"notice\":\"Adjusts the rebalancing configuration of one or more markets\"},\"checkGroup(address,uint256)\":{\"notice\":\"Checks all markets in a rebalance group to see if anything may be rebalanced\"},\"deployAccount()\":{\"notice\":\"Deploys the collateral account for msg.sender and returns the address of the account\"},\"deployAccountWithSignature(((uint256,(address,address,address,uint256,uint256,uint256))),bytes)\":{\"notice\":\"Deploys a collateral account via a signed message\"},\"getAccountAddress(address)\":{\"notice\":\"Returns the deterministic address of the collateral account for a user, regardless of whether or not it exists.\"},\"implementation()\":{\"notice\":\"The instance implementation address\"},\"initialize(address,address)\":{\"notice\":\"Sets contract addresses used for message verification and token management\"},\"initialize(address,address,address)\":{\"notice\":\"Configures message verification and keeper compensation\"},\"instances(address)\":{\"notice\":\"Returns whether the instance is valid\"},\"marketTransferWithSignature((address,int256,(uint256,(address,address,address,uint256,uint256,uint256))),bytes)\":{\"notice\":\"Transfers tokens between a collateral account and a specified Perennial Market\"},\"pause()\":{\"notice\":\"Pauses the contract\"},\"rebalanceConfigs(address,uint256,address)\":{\"notice\":\"Retrieves rebalance configuration for a specified owner, group, and market\"},\"rebalanceGroup(address,uint256)\":{\"notice\":\"Called by keepers to rebalance an unbalanced group\"},\"rebalanceGroupMarkets(address,uint256)\":{\"notice\":\"Retrieves array of markets in an owner's rebalance group\"},\"relayAccessUpdateBatch((((address,bool)[],(address,bool)[],(address,address,address,uint256,uint256,uint256)),(uint256,(address,address,address,uint256,uint256,uint256))),bytes,bytes)\":{\"notice\":\"Relays a message to MarketFactory to update multiple operators and signers\"},\"relayGroupCancellation(((uint256,(address,address,address,uint256,uint256,uint256)),(uint256,(address,address,address,uint256,uint256,uint256))),bytes,bytes)\":{\"notice\":\"Relays a message to Verifier extension to invalidate a group nonce\"},\"relayNonceCancellation(((address,address,address,uint256,uint256,uint256),(uint256,(address,address,address,uint256,uint256,uint256))),bytes,bytes)\":{\"notice\":\"Relays a message to Verifier extension to invalidate a nonce\"},\"relayOperatorUpdate((((address,bool),(address,address,address,uint256,uint256,uint256)),(uint256,(address,address,address,uint256,uint256,uint256))),bytes,bytes)\":{\"notice\":\"Relays a message to MarketFactory to update status of an operator\"},\"relaySignerUpdate((((address,bool),(address,address,address,uint256,uint256,uint256)),(uint256,(address,address,address,uint256,uint256,uint256))),bytes,bytes)\":{\"notice\":\"Relays a message to MarketFactory to update status of a delegated signer\"},\"unpause()\":{\"notice\":\"Unpauses the contract\"},\"updatePauser(address)\":{\"notice\":\"Updates the new pauser\"},\"updatePendingOwner(address)\":{\"notice\":\"Updates the new pending owner\"},\"withdrawWithSignature((uint256,bool,(uint256,(address,address,address,uint256,uint256,uint256))),bytes)\":{\"notice\":\"Transfers tokens from the collateral account back to the owner of the account\"}},\"notice\":\"Controller which compensates keepers for handling or relaying messages on Arbitrum L2.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"@equilibria/perennial-v2-account/contracts/Controller_Arbitrum.sol\":\"Controller_Arbitrum\"},\"evmVersion\":\"shanghai\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000000},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\",\"keccak256\":\"0xf2b6c9adb3552254df1445b73563cf014434ff5e78663e9b961b6c059506ceb5\",\"license\":\"MIT\"},\"@equilibria/emptyset-batcher/interfaces/IEmptySetReserve.sol\":{\"content\":\"//SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@equilibria/root/number/types/UFixed18.sol\\\";\\n\\ninterface IEmptySetReserve {\\n    event Redeem(address indexed account, uint256 costAmount, uint256 redeemAmount);\\n    event Mint(address indexed account, uint256 mintAmount, uint256 costAmount);\\n    event Repay(address indexed account, uint256 repayAmount);\\n\\n    function debt(address borrower) external view returns (UFixed18);\\n    function repay(address borrower, UFixed18 amount) external;\\n    function mint(UFixed18 amount) external;\\n    function redeem(UFixed18 amount) external;\\n}\\n\",\"keccak256\":\"0xdb96e26082a471c7803e892ecd8d2877f23cd9e31f13a3e407dd5f8909078864\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2-account/contracts/Account.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.24;\\n\\nimport { IERC20Metadata } from \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport { IEmptySetReserve } from \\\"@equilibria/emptyset-batcher/interfaces/IEmptySetReserve.sol\\\";\\nimport { Instance } from \\\"@equilibria/root/attribute/Instance.sol\\\";\\nimport { Fixed6, Fixed6Lib } from \\\"@equilibria/root/number/types/Fixed6.sol\\\";\\nimport { UFixed6, UFixed6Lib } from \\\"@equilibria/root/number/types/UFixed6.sol\\\";\\nimport { UFixed18, UFixed18Lib } from \\\"@equilibria/root/number/types/UFixed18.sol\\\";\\nimport { Token6 } from \\\"@equilibria/root/token/types/Token6.sol\\\";\\nimport { Token18 } from \\\"@equilibria/root/token/types/Token18.sol\\\";\\n\\nimport { IAccount } from \\\"./interfaces/IAccount.sol\\\";\\nimport { IMarket, Position } from \\\"@equilibria/perennial-v2/contracts/interfaces/IMarket.sol\\\";\\n\\n/// @title Account\\n/// @notice Collateral Accounts allow users to manage collateral across Perennial markets\\ncontract Account is IAccount, Instance {\\n    UFixed6 private constant UNCHANGED_POSITION = UFixed6Lib.MAX;\\n\\n    /// @dev EOA of the user who owns this collateral account\\n    address public owner;\\n\\n    /// @dev USDC stablecoin address\\n    Token6 public immutable USDC; // solhint-disable-line var-name-mixedcase\\n\\n    /// @dev DSU address\\n    Token18 public immutable DSU; // solhint-disable-line var-name-mixedcase\\n\\n    /// @dev DSU Reserve address\\n    IEmptySetReserve public immutable reserve;\\n\\n    /// @dev Construct collateral account and set approvals for controller and DSU reserve\\n    /// @param usdc_ USDC stablecoin\\n    /// @param dsu_ Digital Standard Unit stablecoin\\n    /// @param reserve_ DSU SimpleReserve contract, used for wrapping/unwrapping USDC to/from DSU\\n    constructor(Token6 usdc_, Token18 dsu_, IEmptySetReserve reserve_) {\\n        USDC = usdc_;\\n        DSU = dsu_;\\n        reserve = reserve_;\\n    }\\n\\n    /// @inheritdoc IAccount\\n    function initialize(address owner_) external initializer(1) {\\n        __Instance__initialize();\\n        owner = owner_;\\n\\n        // approve the Controller to interact with this account's DSU\\n        DSU.approve(address(factory()));\\n\\n        // approve DSU facilities to wrap and unwrap USDC for this account\\n        DSU.approve(address(reserve));\\n        USDC.approve(address(reserve));\\n    }\\n\\n    /// @inheritdoc IAccount\\n    function deposit(UFixed6 amount) external {\\n        USDC.pull(msg.sender, amount);\\n    }\\n\\n    /// @inheritdoc IAccount\\n    function marketTransfer(IMarket market, Fixed6 amount) external ownerOrController {\\n        // implicitly approve this market to spend our DSU\\n        DSU.approve(address(market));\\n\\n        // if account does not have enough DSU for the deposit, wrap everything\\n         if (amount.gt(Fixed6Lib.ZERO))\\n            wrapIfNecessary(UFixed18Lib.from(amount.abs()), true);\\n\\n        // pass magic numbers to avoid changing position; market will pull/push collateral from/to this contract\\n        market.update(owner, UNCHANGED_POSITION, UNCHANGED_POSITION, UNCHANGED_POSITION, amount, false);\\n    }\\n\\n    /// @inheritdoc IAccount\\n    function withdraw(UFixed6 amount, bool shouldUnwrap) external ownerOrController {\\n        UFixed6 usdcBalance = USDC.balanceOf();\\n        if (shouldUnwrap && usdcBalance.lt(amount)) {\\n            UFixed18 unwrapAmount = amount.eq(UFixed6Lib.MAX) ?\\n                DSU.balanceOf() :\\n                UFixed18Lib.from(amount.sub(usdcBalance)).min(DSU.balanceOf());\\n            unwrap(unwrapAmount);\\n        }\\n        UFixed6 pushAmount = amount.eq(UFixed6Lib.MAX) ? USDC.balanceOf() : amount;\\n        USDC.push(owner, pushAmount);\\n    }\\n\\n    /// @inheritdoc IAccount\\n    function wrap(UFixed18 amount) public ownerOrController {\\n        reserve.mint(amount);\\n    }\\n\\n    /// @inheritdoc IAccount\\n    function wrapIfNecessary(UFixed18 amount, bool wrapAll) public ownerOrController {\\n        if (DSU.balanceOf().lt(amount)) {\\n            UFixed6 usdcBalance = USDC.balanceOf();\\n            if (!usdcBalance.eq(UFixed6Lib.ZERO))\\n                wrap(wrapAll ? UFixed18Lib.from(usdcBalance) : amount);\\n        }\\n    }\\n\\n    /// @inheritdoc IAccount\\n    function unwrap(UFixed18 amount) public ownerOrController {\\n        reserve.redeem(amount);\\n    }\\n\\n    /// @dev Reverts if not called by the owner of the collateral account, or the collateral account controller\\n    modifier ownerOrController {\\n        if (msg.sender != owner && msg.sender != address(factory())) revert AccountNotAuthorizedError();\\n        _;\\n    }\\n}\",\"keccak256\":\"0x4ca50bb60ed80ca5509f8cc9697f25f3c5cae9e7c1c4c3bb57861b361ec81c7d\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2-account/contracts/Controller.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.24;\\n\\nimport { Create2 } from \\\"@openzeppelin/contracts/utils/Create2.sol\\\";\\n\\nimport { Factory } from \\\"@equilibria/root/attribute/Factory.sol\\\";\\nimport { Token6 } from \\\"@equilibria/root/token/types/Token6.sol\\\";\\nimport { Token18 } from \\\"@equilibria/root/token/types/Token18.sol\\\";\\nimport { Fixed6, Fixed6Lib } from \\\"@equilibria/root/number/types/Fixed6.sol\\\";\\nimport { UFixed6, UFixed6Lib } from \\\"@equilibria/root/number/types/UFixed6.sol\\\";\\nimport { IMarketFactory } from \\\"@equilibria/perennial-v2/contracts/interfaces/IMarketFactory.sol\\\";\\n\\nimport { IAccount, IMarket } from \\\"./interfaces/IAccount.sol\\\";\\nimport { IAccountVerifier, IController } from \\\"./interfaces/IController.sol\\\";\\nimport { RebalanceLib } from \\\"./libs/RebalanceLib.sol\\\";\\nimport { Account } from \\\"./Account.sol\\\";\\nimport { DeployAccount, DeployAccountLib } from \\\"./types/DeployAccount.sol\\\";\\nimport { MarketTransfer, MarketTransferLib } from \\\"./types/MarketTransfer.sol\\\";\\nimport { RebalanceConfig, RebalanceConfigLib } from \\\"./types/RebalanceConfig.sol\\\";\\nimport { RebalanceConfigChange, RebalanceConfigChangeLib } from \\\"./types/RebalanceConfigChange.sol\\\";\\nimport { Withdrawal, WithdrawalLib } from \\\"./types/Withdrawal.sol\\\";\\n\\n/// @title Controller\\n/// @notice Facilitates unpermissioned actions between collateral accounts and markets,\\n/// without keeper compensation.  No message relaying facilities are provided.\\ncontract Controller is Factory, IController {\\n    // used for deterministic address creation through create2\\n    bytes32 constant SALT = keccak256(\\\"Perennial V2 Collateral Accounts\\\");\\n\\n    uint256 constant MAX_GROUPS_PER_OWNER = 8;\\n    uint256 constant MAX_MARKETS_PER_GROUP = 4;\\n\\n    /// @dev USDC stablecoin address\\n    Token6 immutable public USDC; // solhint-disable-line var-name-mixedcase\\n\\n    /// @dev DSU address\\n    Token18 immutable public DSU; // solhint-disable-line var-name-mixedcase\\n\\n    /// @inheritdoc IController\\n    IMarketFactory public marketFactory;\\n\\n    /// @inheritdoc IController\\n    IAccountVerifier public verifier;\\n\\n    /// @dev Mapping of rebalance configuration\\n    /// owner => group => market => config\\n    mapping(address => mapping(uint256 => mapping(address => RebalanceConfig))) private _rebalanceConfigs;\\n\\n    /// @dev Prevents markets from being added to multiple rebalance groups\\n    /// owner => market => group\\n    mapping(address => mapping(address => uint256)) public marketToGroup;\\n\\n    /// @dev Allows iteration through markets in a rebalance group\\n    /// owner => group => markets\\n    mapping(address => mapping(uint256 => IMarket[])) public groupToMarkets;\\n\\n    /// @dev Limits relayer/keeper compensation for rebalancing a group, in DSU\\n    mapping(address => mapping(uint256 => UFixed6)) public groupToMaxRebalanceFee;\\n\\n    /// @dev Creates instance of Controller\\n    /// @param implementation_ Collateral account contract initialized with stablecoin addresses\\n    constructor(address implementation_) Factory(implementation_) {\\n        USDC = Account(implementation_).USDC();\\n        DSU = Account(implementation_).DSU();\\n    }\\n\\n    /// @inheritdoc IController\\n    function initialize(\\n        IMarketFactory marketFactory_,\\n        IAccountVerifier verifier_\\n    ) external initializer(1) {\\n        __Factory__initialize();\\n        marketFactory = marketFactory_;\\n        verifier = verifier_;\\n    }\\n\\n    /// @inheritdoc IController\\n    function getAccountAddress(address owner) public view returns (address) {\\n        // calculate the hash for an uninitialized account for the owner\\n        return _computeCreate2Address(abi.encodeCall(Account.initialize, (owner)), SALT);\\n    }\\n\\n    /// @inheritdoc IController\\n    function changeRebalanceConfigWithSignature(\\n        RebalanceConfigChange calldata configChange,\\n        bytes calldata signature\\n    ) virtual external {\\n        _changeRebalanceConfigWithSignature(configChange, signature);\\n    }\\n\\n    /// @inheritdoc IController\\n    function checkGroup(address owner, uint256 group) public view returns (\\n        Fixed6 groupCollateral,\\n        bool canRebalance,\\n        Fixed6[] memory imbalances\\n    ) {\\n        // query owner's collateral in each market and calculate sum\\n        Fixed6[] memory actualCollateral;\\n        (actualCollateral, groupCollateral) = _queryMarketCollateral(owner, group);\\n        imbalances = new Fixed6[](actualCollateral.length);\\n\\n        // determine if anything is outside the rebalance threshold\\n        for (uint256 i; i < actualCollateral.length; i++) {\\n            IMarket market = groupToMarkets[owner][group][i];\\n            RebalanceConfig memory marketRebalanceConfig = _rebalanceConfigs[owner][group][address(market)];\\n            (bool canMarketRebalance, Fixed6 imbalance) =\\n                RebalanceLib.checkMarket(marketRebalanceConfig, groupCollateral, actualCollateral[i]);\\n            imbalances[i] = imbalance;\\n            canRebalance = canRebalance || canMarketRebalance;\\n        }\\n    }\\n\\n    /// @inheritdoc IController\\n    function deployAccount() public returns (IAccount) {\\n        return _createAccount(msg.sender);\\n    }\\n\\n    /// @inheritdoc IController\\n    function deployAccountWithSignature(\\n        DeployAccount calldata deployAccountAction,\\n        bytes calldata signature\\n    ) virtual external {\\n        _deployAccountWithSignature(deployAccountAction, signature);\\n    }\\n\\n    /// @inheritdoc IController\\n    function marketTransferWithSignature(\\n        MarketTransfer calldata marketTransfer,\\n        bytes calldata signature\\n    ) virtual external {\\n        IAccount account = IAccount(getAccountAddress(marketTransfer.action.common.account));\\n        _marketTransferWithSignature(account, marketTransfer, signature);\\n    }\\n\\n    /// @inheritdoc IController\\n    function rebalanceConfigs(\\n        address owner,\\n        uint256 group,\\n        address market\\n    ) external view returns (RebalanceConfig memory) {\\n        return _rebalanceConfigs[owner][group][market];\\n    }\\n\\n    /// @inheritdoc IController\\n    function rebalanceGroupMarkets(\\n        address owner,\\n        uint256 group\\n    ) external view returns (IMarket[] memory markets) {\\n        markets = groupToMarkets[owner][group];\\n    }\\n\\n    /// @inheritdoc IController\\n    function withdrawWithSignature(Withdrawal calldata withdrawal, bytes calldata signature) virtual external {\\n        IAccount account = IAccount(getAccountAddress(withdrawal.action.common.account));\\n        _withdrawWithSignature(account, withdrawal, signature);\\n    }\\n\\n    /// @inheritdoc IController\\n    function rebalanceGroup(address owner, uint256 group) virtual external {\\n        _rebalanceGroup(owner, group);\\n    }\\n\\n    function _changeRebalanceConfigWithSignature(RebalanceConfigChange calldata configChange, bytes calldata signature) internal {\\n        // ensure the message was signed by the owner or a delegated signer\\n        verifier.verifyRebalanceConfigChange(configChange, signature);\\n        _ensureValidSigner(configChange.action.common.account, configChange.action.common.signer);\\n\\n        // sum of the target allocations of all markets in the group\\n        _updateRebalanceGroup(configChange, configChange.action.common.account);\\n    }\\n\\n    function _createAccount(address owner) internal returns (IAccount account) {\\n        account = Account(address(_create2(abi.encodeCall(Account.initialize, (owner)), SALT)));\\n        emit AccountDeployed(owner, account);\\n    }\\n\\n    /// @dev reverts if user is not authorized to sign transactions for the owner\\n    function _ensureValidSigner(address owner, address signer) internal view {\\n        if (signer != owner && !marketFactory.signers(owner, signer)) revert ControllerInvalidSignerError();\\n    }\\n\\n    function _deployAccountWithSignature(\\n        DeployAccount calldata deployAccount_,\\n        bytes calldata signature\\n    ) internal returns (IAccount account) {\\n        address owner = deployAccount_.action.common.account;\\n        verifier.verifyDeployAccount(deployAccount_, signature);\\n        _ensureValidSigner(owner, deployAccount_.action.common.signer);\\n\\n        // create the account\\n        account = _createAccount(owner);\\n    }\\n\\n    function _marketTransferWithSignature(\\n        IAccount account,\\n        MarketTransfer calldata marketTransfer,\\n        bytes calldata signature\\n    ) internal {\\n        // ensure the message was signed by the owner or a delegated signer\\n        verifier.verifyMarketTransfer(marketTransfer, signature);\\n        _ensureValidSigner(marketTransfer.action.common.account, marketTransfer.action.common.signer);\\n\\n        // only Markets with DSU collateral are supported\\n        IMarket market = IMarket(marketTransfer.market);\\n        if (!market.token().eq(DSU)) revert ControllerUnsupportedMarketError(market);\\n\\n        account.marketTransfer(market, marketTransfer.amount);\\n    }\\n\\n    function _withdrawWithSignature(\\n        IAccount account,\\n        Withdrawal calldata withdrawal,\\n        bytes calldata signature\\n    ) internal {\\n        // ensure the message was signed by the owner or a delegated signer\\n        verifier.verifyWithdrawal(withdrawal, signature);\\n        _ensureValidSigner(withdrawal.action.common.account, withdrawal.action.common.signer);\\n\\n        // call the account's implementation to push to owner\\n        account.withdraw(withdrawal.amount, withdrawal.unwrap);\\n    }\\n\\n    function _rebalanceGroup(address owner, uint256 group) internal {\\n        // settles each markets, such that locals are up-to-date\\n        _settleMarkets(owner, group);\\n\\n        // determine imbalances\\n        (, bool canRebalance, Fixed6[] memory imbalances) = checkGroup(owner, group);\\n        if (!canRebalance) revert ControllerGroupBalancedError();\\n\\n        IAccount account = IAccount(getAccountAddress(owner));\\n        // pull collateral from markets with surplus collateral\\n        for (uint256 i; i < imbalances.length; i++) {\\n            IMarket market = groupToMarkets[owner][group][i];\\n            if (Fixed6.unwrap(imbalances[i]) < 0) account.marketTransfer(market, imbalances[i]);\\n        }\\n\\n        // push collateral to markets with insufficient collateral\\n        for (uint256 i; i < imbalances.length; i++) {\\n            IMarket market = groupToMarkets[owner][group][i];\\n            if (Fixed6.unwrap(imbalances[i]) > 0) account.marketTransfer(market, imbalances[i]);\\n        }\\n\\n        emit GroupRebalanced(owner, group);\\n    }\\n\\n    /// @dev checks current collateral for each market in a group and aggregates collateral for the group\\n    function _queryMarketCollateral(address owner, uint256 group) private view returns (\\n        Fixed6[] memory actualCollateral,\\n        Fixed6 groupCollateral\\n    ) {\\n        actualCollateral = new Fixed6[](groupToMarkets[owner][group].length);\\n        for (uint256 i; i < actualCollateral.length; i++) {\\n            Fixed6 collateral = groupToMarkets[owner][group][i].locals(owner).collateral;\\n            actualCollateral[i] = collateral;\\n            groupCollateral = groupCollateral.add(collateral);\\n        }\\n    }\\n\\n    /// @dev settles each market in a rebalancing group\\n    function _settleMarkets(address owner, uint256 group) private {\\n        for (uint256 i; i < groupToMarkets[owner][group].length; i++)\\n            groupToMarkets[owner][group][i].settle(owner);\\n    }\\n\\n    /// @dev overwrites rebalance configuration of all markets for a particular owner and group\\n    /// @param message already-verified message with new configuration\\n    /// @param owner identifies the owner of the collateral account\\n    function _updateRebalanceGroup(\\n        RebalanceConfigChange calldata message,\\n        address owner\\n    ) private {\\n        // ensure group index is valid\\n        if (message.group == 0 || message.group > MAX_GROUPS_PER_OWNER)\\n            revert ControllerInvalidRebalanceGroupError();\\n\\n        if (message.markets.length > MAX_MARKETS_PER_GROUP)\\n            revert ControllerInvalidRebalanceMarketsError();\\n\\n        // delete the existing group\\n        for (uint256 i; i < groupToMarkets[owner][message.group].length; i++) {\\n            address market = address(groupToMarkets[owner][message.group][i]);\\n            delete _rebalanceConfigs[owner][message.group][market];\\n            delete marketToGroup[owner][market];\\n        }\\n        delete groupToMarkets[owner][message.group];\\n\\n        UFixed6 totalAllocation;\\n        for (uint256 i; i < message.markets.length; i++) {\\n            // ensure market is not pointing to a different group\\n            uint256 currentGroup = marketToGroup[owner][message.markets[i]];\\n            if (currentGroup != 0)\\n                revert ControllerMarketAlreadyInGroupError(IMarket(message.markets[i]), currentGroup);\\n\\n            // rewrite over all the old configuration\\n            marketToGroup[owner][message.markets[i]] = message.group;\\n            _rebalanceConfigs[owner][message.group][message.markets[i]] = message.configs[i];\\n            groupToMarkets[owner][message.group].push(IMarket(message.markets[i]));\\n            groupToMaxRebalanceFee[owner][message.group] = message.maxFee;\\n\\n            // ensure target allocation across all markets totals 100%\\n            // read from storage to trap duplicate markets in the message\\n            totalAllocation = totalAllocation.add(message.configs[i].target);\\n\\n            emit RebalanceMarketConfigured(owner, message.group, message.markets[i], message.configs[i]);\\n        }\\n\\n        // if not deleting the group, ensure rebalance targets add to 100%\\n        if (message.markets.length != 0 && !totalAllocation.eq(UFixed6Lib.ONE))\\n            revert ControllerInvalidRebalanceTargetsError();\\n\\n        emit RebalanceGroupConfigured(owner, message.group, message.markets.length);\\n    }\\n}\\n\",\"keccak256\":\"0xe94dfb76dc2c05b6f4f58589da9b64514ba300ed9a3e8bfe51afdb0735a1bdde\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2-account/contracts/Controller_Arbitrum.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.24;\\n\\nimport { Kept_Arbitrum, Kept } from \\\"@equilibria/root/attribute/Kept/Kept_Arbitrum.sol\\\";\\nimport { UFixed18 } from \\\"@equilibria/root/number/types/UFixed18.sol\\\";\\nimport { IVerifierBase } from \\\"@equilibria/root/verifier/interfaces/IVerifierBase.sol\\\";\\nimport { Controller_Incentivized } from \\\"./Controller_Incentivized.sol\\\";\\n\\n/// @title Controller_Arbitrum\\n/// @notice Controller which compensates keepers for handling or relaying messages on Arbitrum L2.\\ncontract Controller_Arbitrum is Controller_Incentivized, Kept_Arbitrum {\\n    /// @dev Creates instance of Controller which compensates keepers\\n    /// @param implementation Pristine collateral account contract\\n    /// @param keepConfig Configuration used to compensate keepers\\n    constructor(address implementation, KeepConfig memory keepConfig, IVerifierBase nonceManager)\\n    Controller_Incentivized(implementation, keepConfig, nonceManager) {}\\n\\n    /// @dev Use the Kept_Arbitrum implementation for calculating the dynamic fee\\n    function _calldataFee(\\n        bytes memory applicableCalldata,\\n        UFixed18 multiplierCalldata,\\n        uint256 bufferCalldata\\n    ) internal view override(Kept_Arbitrum, Kept) returns (UFixed18) {\\n        return Kept_Arbitrum._calldataFee(applicableCalldata, multiplierCalldata, bufferCalldata);\\n    }\\n\\n    /// @dev Transfers funds from collateral account to controller, and limits compensation\\n    /// to the user-defined maxFee in the Action message\\n    /// @param amount Calculated keeper fee\\n    /// @param data Encoded address of collateral account and UFixed6 user-specified maximum fee\\n    /// @return raisedKeeperFee Amount pulled from controller to keeper\\n    function _raiseKeeperFee(\\n        UFixed18 amount,\\n        bytes memory data\\n    ) internal override(Controller_Incentivized, Kept) returns (UFixed18 raisedKeeperFee) {\\n        return Controller_Incentivized._raiseKeeperFee(amount, data);\\n    }\\n}\\n\",\"keccak256\":\"0x0d4609aed2508a289ba726634456060bf737cea88c074cb0a9d31d39c5407d69\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2-account/contracts/Controller_Incentivized.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport { AggregatorV3Interface } from \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\nimport { IEmptySetReserve } from \\\"@equilibria/emptyset-batcher/interfaces/IEmptySetReserve.sol\\\";\\nimport { Kept } from \\\"@equilibria/root/attribute/Kept/Kept.sol\\\";\\nimport { Fixed6, Fixed6Lib } from \\\"@equilibria/root/number/types/Fixed6.sol\\\";\\nimport { UFixed6, UFixed6Lib } from \\\"@equilibria/root/number/types/UFixed6.sol\\\";\\nimport { UFixed18, UFixed18Lib } from \\\"@equilibria/root/number/types/UFixed18.sol\\\";\\nimport { Token6 } from \\\"@equilibria/root/token/types/Token6.sol\\\";\\nimport { Token18 } from \\\"@equilibria/root/token/types/Token18.sol\\\";\\nimport { IVerifierBase } from \\\"@equilibria/root/verifier/interfaces/IVerifierBase.sol\\\";\\nimport { IMarket } from \\\"@equilibria/perennial-v2/contracts/interfaces/IMarket.sol\\\";\\nimport { IMarketFactory } from \\\"@equilibria/perennial-v2/contracts/interfaces/IMarketFactory.sol\\\";\\n\\nimport { IAccount } from \\\"./interfaces/IAccount.sol\\\";\\nimport { IController } from \\\"./interfaces/IController.sol\\\";\\nimport { IRelayer } from \\\"./interfaces/IRelayer.sol\\\";\\nimport { Controller, IAccountVerifier } from \\\"./Controller.sol\\\";\\nimport { Action } from \\\"./types/Action.sol\\\";\\nimport { DeployAccount } from \\\"./types/DeployAccount.sol\\\";\\nimport { MarketTransfer } from \\\"./types/MarketTransfer.sol\\\";\\nimport { RebalanceConfigChange } from \\\"./types/RebalanceConfigChange.sol\\\";\\nimport { RelayedNonceCancellation } from \\\"./types/RelayedNonceCancellation.sol\\\";\\nimport { RelayedGroupCancellation } from \\\"./types/RelayedGroupCancellation.sol\\\";\\nimport { RelayedOperatorUpdate } from \\\"./types/RelayedOperatorUpdate.sol\\\";\\nimport { RelayedSignerUpdate } from \\\"./types/RelayedSignerUpdate.sol\\\";\\nimport { RelayedAccessUpdateBatch } from \\\"./types/RelayedAccessUpdateBatch.sol\\\";\\nimport { Withdrawal } from \\\"./types/Withdrawal.sol\\\";\\n\\n/// @title Controller_Incentivized\\n/// @notice Controller which compensates keepers for handling or relaying messages. Subclass to handle differences in\\n/// gas calculations on different chains.\\nabstract contract Controller_Incentivized is Controller, IRelayer, Kept {\\n    /// @dev Configuration used to calculate keeper compensation\\n    KeepConfig public keepConfig;\\n\\n    /// @dev Handles relayed messages for nonce cancellation\\n    IVerifierBase public nonceManager;\\n\\n    /// @dev Creates instance of Controller which compensates keepers\\n    /// @param implementation_ Pristine collateral account contract\\n    /// @param keepConfig_ Configuration used to compensate keepers\\n    constructor(address implementation_, KeepConfig memory keepConfig_, IVerifierBase nonceManager_)\\n    Controller(implementation_) {\\n        keepConfig = keepConfig_;\\n        nonceManager = nonceManager_;\\n    }\\n\\n    /// @notice Configures message verification and keeper compensation\\n    /// @param marketFactory_ Contract used to validate delegated signers\\n    /// @param verifier_ Contract used to validate collateral account message signatures\\n    /// @param chainlinkFeed_ ETH-USD price feed used for calculating keeper compensation\\n    function initialize(\\n        IMarketFactory marketFactory_,\\n        IAccountVerifier verifier_,\\n        AggregatorV3Interface chainlinkFeed_\\n    ) external initializer(2) {\\n        // __Factory__initialize();\\n        __Kept__initialize(chainlinkFeed_, DSU);\\n        marketFactory = marketFactory_;\\n        verifier = verifier_;\\n    }\\n\\n    /// @inheritdoc IController\\n    function changeRebalanceConfigWithSignature(\\n        RebalanceConfigChange calldata configChange,\\n        bytes calldata signature\\n    ) override external {\\n        _changeRebalanceConfigWithSignature(configChange, signature);\\n        _compensateKeeper(configChange.action);\\n    }\\n\\n    /// @inheritdoc IController\\n    function deployAccountWithSignature(\\n        DeployAccount calldata deployAccount_,\\n        bytes calldata signature\\n    ) override external {\\n        IAccount account = _deployAccountWithSignature(deployAccount_, signature);\\n        bytes memory data = abi.encode(address(account), deployAccount_.action.maxFee);\\n        _handleKeeperFee(keepConfig, 0, msg.data[0:0], 0, data);\\n    }\\n\\n    /// @inheritdoc IController\\n    function marketTransferWithSignature(\\n        MarketTransfer calldata marketTransfer,\\n        bytes calldata signature\\n    ) override external {\\n        IAccount account = IAccount(getAccountAddress(marketTransfer.action.common.account));\\n        bytes memory data = abi.encode(account, marketTransfer.action.maxFee);\\n\\n        // if we're depositing collateral to the market, pay the keeper before transferring funds\\n        if (marketTransfer.amount.gte(Fixed6Lib.ZERO)) {\\n            _handleKeeperFee(keepConfig, 0, msg.data[0:0], 0, data);\\n            _marketTransferWithSignature(account, marketTransfer, signature);\\n        // otherwise handle the keeper fee normally, after withdrawing to the collateral account\\n        } else {\\n            _marketTransferWithSignature(account, marketTransfer, signature);\\n            _handleKeeperFee(keepConfig, 0, msg.data[0:0], 0, data);\\n        }\\n    }\\n\\n    /// @inheritdoc IController\\n    function rebalanceGroup(address owner, uint256 group) override external {\\n        _rebalanceGroup(owner, group);\\n        address account = getAccountAddress(owner);\\n        bytes memory data = abi.encode(account, groupToMaxRebalanceFee[owner][group]);\\n        _handleKeeperFee(keepConfig, 0, msg.data[0:0], 0, data);\\n    }\\n\\n    /// @inheritdoc IController\\n    function withdrawWithSignature(\\n        Withdrawal calldata withdrawal,\\n        bytes calldata signature\\n    ) override external {\\n        address account = getAccountAddress(withdrawal.action.common.account);\\n        // levy fee prior to withdrawal\\n        bytes memory data = abi.encode(account, withdrawal.action.maxFee);\\n        _handleKeeperFee(keepConfig, 0, msg.data[0:0], 0, data);\\n        _withdrawWithSignature(IAccount(account), withdrawal, signature);\\n    }\\n\\n    /// @inheritdoc IRelayer\\n    function relayNonceCancellation(\\n        RelayedNonceCancellation calldata message,\\n        bytes calldata outerSignature,\\n        bytes calldata innerSignature\\n    ) override external {\\n        // ensure the message was signed by the owner or a delegated signer\\n        verifier.verifyRelayedNonceCancellation(message, outerSignature);\\n        _ensureValidSigner(message.action.common.account, message.action.common.signer);\\n\\n        _compensateKeeper(message.action);\\n\\n        // relay the message to Verifier\\n        nonceManager.cancelNonceWithSignature(message.nonceCancellation, innerSignature);\\n    }\\n\\n    /// @inheritdoc IRelayer\\n    function relayGroupCancellation(\\n        RelayedGroupCancellation calldata message,\\n        bytes calldata outerSignature,\\n        bytes calldata innerSignature\\n    ) override external {\\n        // ensure the message was signed by the owner or a delegated signer\\n        verifier.verifyRelayedGroupCancellation(message, outerSignature);\\n        _ensureValidSigner(message.action.common.account, message.action.common.signer);\\n\\n        _compensateKeeper(message.action);\\n\\n        // relay the message to Verifier\\n        nonceManager.cancelGroupWithSignature(message.groupCancellation, innerSignature);\\n    }\\n\\n    /// @inheritdoc IRelayer\\n    function relayOperatorUpdate(\\n        RelayedOperatorUpdate calldata message,\\n        bytes calldata outerSignature,\\n        bytes calldata innerSignature\\n    ) override external {\\n        // ensure the message was signed by the owner or a delegated signer\\n        verifier.verifyRelayedOperatorUpdate(message, outerSignature);\\n        _ensureValidSigner(message.action.common.account, message.action.common.signer);\\n\\n        _compensateKeeper(message.action);\\n\\n        // relay the message to MarketFactory\\n        marketFactory.updateOperatorWithSignature(message.operatorUpdate, innerSignature);\\n    }\\n\\n    /// @inheritdoc IRelayer\\n    function relaySignerUpdate(\\n        RelayedSignerUpdate calldata message,\\n        bytes calldata outerSignature,\\n        bytes calldata innerSignature\\n    ) override external {\\n        // ensure the message was signed by the owner or a delegated signer\\n        verifier.verifyRelayedSignerUpdate(message, outerSignature);\\n        _ensureValidSigner(message.action.common.account, message.action.common.signer);\\n\\n        _compensateKeeper(message.action);\\n\\n        // relay the message to MarketFactory\\n        marketFactory.updateSignerWithSignature(message.signerUpdate, innerSignature);\\n    }\\n\\n    /// @inheritdoc IRelayer\\n    function relayAccessUpdateBatch(\\n        RelayedAccessUpdateBatch calldata message,\\n        bytes calldata outerSignature,\\n        bytes calldata innerSignature\\n    ) override external {\\n        // ensure the message was signed by the owner or a delegated signer\\n        verifier.verifyRelayedAccessUpdateBatch(message, outerSignature);\\n        _ensureValidSigner(message.action.common.account, message.action.common.signer);\\n\\n        _compensateKeeper(message.action);\\n\\n        // relay the message to MarketFactory\\n        marketFactory.updateAccessBatchWithSignature(message.accessUpdateBatch, innerSignature);\\n    }\\n\\n    function _compensateKeeper(Action calldata action) internal virtual {\\n        bytes memory data = abi.encode(getAccountAddress(action.common.account), action.maxFee);\\n        _handleKeeperFee(keepConfig, 0, msg.data[0:0], 0, data);\\n    }\\n\\n    /// @dev Transfers funds from collateral account to controller, and limits compensation\\n    /// to the user-defined maxFee in the Action message\\n    /// @param amount Calculated keeper fee\\n    /// @param data Encoded address of collateral account and UFixed6 user-specified maximum fee\\n    /// @return raisedKeeperFee Amount pulled from controller to keeper\\n    function _raiseKeeperFee(\\n        UFixed18 amount,\\n        bytes memory data\\n    ) internal virtual override returns (UFixed18 raisedKeeperFee) {\\n        (address account, UFixed6 maxFee) = abi.decode(data, (address, UFixed6));\\n        raisedKeeperFee = amount.min(UFixed18Lib.from(maxFee));\\n\\n        // if the account has insufficient DSU to pay the fee, wrap\\n        IAccount(account).wrapIfNecessary(raisedKeeperFee, false);\\n\\n        // transfer DSU to the Controller, such that Kept can transfer to keeper\\n        DSU.pull(account, raisedKeeperFee);\\n    }\\n}\\n\",\"keccak256\":\"0x333cdfdd45c49d61639bec938e5aabe4522f6e6f3cb401eee68af85445ce6199\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2-account/contracts/interfaces/IAccount.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport { IMarket } from \\\"@equilibria/perennial-v2/contracts/interfaces/IMarket.sol\\\";\\nimport { Fixed6 } from \\\"@equilibria/root/number/types/Fixed6.sol\\\";\\nimport { UFixed18 } from \\\"@equilibria/root/number/types/UFixed18.sol\\\";\\nimport { UFixed6 } from \\\"@equilibria/root/number/types/UFixed6.sol\\\";\\nimport { Token6 } from \\\"@equilibria/root/token/types/Token6.sol\\\";\\nimport { Token18 } from \\\"@equilibria/root/token/types/Token18.sol\\\";\\n\\n/// @notice Collateral Accounts allow users to manage collateral across Perennial markets\\ninterface IAccount {\\n    // sig: 0x9041f6c1\\n    /// @custom:error Only the owner or the collateral account controller may withdraw\\n    error AccountNotAuthorizedError();\\n\\n    /// @notice Sets owner, contract, and token addresses, and runs approvals for a collateral account\\n    /// @param owner Address of the user for which the account was created\\n    function initialize(address owner) external;\\n\\n    /// @notice Transfer USDC collateral from msg.sender to this account\\n    /// @param amount Quantity of USDC to transfer in 6-decimal precision\\n    function deposit(UFixed6 amount) external;\\n\\n    /// @notice used for transferring and rebalancing collateral\\n    /// @param market Market to transfer funds to/from, which identifies the token\\n    /// @param amount Quantity to deposit (positive) or withdraw (negative)\\n    function marketTransfer(IMarket market, Fixed6 amount) external;\\n\\n    /// @notice Transfer USDC collateral from this account to the owner\\n    /// @param amount Quantity of tokens to transfer in 6-decimal precision; set to UFixed6.MAX for full withdrawal\\n    /// @param shouldUnwrap If amount exceeds USDC balance and this is true, DSU will be unwrapped as necessary to facilitate withdrawal\\n    function withdraw(UFixed6 amount, bool shouldUnwrap) external;\\n\\n    /// @notice Converts a specified amount of USDC to DSU\\n    /// @param amount Quantity of DSU to mint, in 18-decimal precision\\n    function wrap(UFixed18 amount) external;\\n\\n    /// @notice Wraps if DSU balance is under a specified amount\\n    /// @param amount Desired quantity of DSU\\n    /// @param wrapAll True to wrap full USDC balance, false to wrap specified amount\\n    function wrapIfNecessary(UFixed18 amount, bool wrapAll) external;\\n\\n    /// @notice Converts a specified amount of DSU to USDC\\n    /// @param amount Quantity of DSU to burn, in 18-decimal precision\\n    function unwrap(UFixed18 amount) external;\\n}\",\"keccak256\":\"0x19a33bbe20e3e976cde4816c79c8f9a8754a30648a7c47e16871283629165d62\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2-account/contracts/interfaces/IAccountVerifier.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport { IVerifierBase } from \\\"@equilibria/root/verifier/interfaces/IVerifierBase.sol\\\";\\nimport { IRelayVerifier } from \\\"./IRelayVerifier.sol\\\";\\nimport { Action } from \\\"../types/Action.sol\\\";\\nimport { DeployAccount } from \\\"../types/DeployAccount.sol\\\";\\nimport { MarketTransfer } from \\\"../types/MarketTransfer.sol\\\";\\nimport { RebalanceConfigChange } from \\\"../types/RebalanceConfigChange.sol\\\";\\nimport { Withdrawal } from \\\"../types/Withdrawal.sol\\\";\\n\\n/// @notice EIP712 signed message verifier for Perennial V2 Collateral Accounts.\\ninterface IAccountVerifier is IVerifierBase, IRelayVerifier {\\n    /// @notice Verifies the signature of no-op action message\\n    /// @dev Cancels the nonce after verifying the signature\\n    ///      Reverts if the signature does not match the signer\\n    /// @param action Data common to all action messages\\n    /// @param signature EIP712 signature for the message\\n    function verifyAction(Action calldata action, bytes calldata signature) external;\\n\\n    /// @notice Verifies the signature of a request to deploy a collateral account\\n    /// @dev Cancels the nonce after verifying the signature\\n    ///      Reverts if the signature does not match the signer\\n    /// @param deployAccount message to verify, which includes the owner of the collateral account\\n    /// @param signature EIP712 signature for the message\\n    function verifyDeployAccount(DeployAccount calldata deployAccount, bytes calldata signature) external;\\n\\n    /// @notice Verifies the signature of a request to transfer funds between a collateral account and a market\\n    /// @dev Cancels the nonce after verifying the signature\\n    ///      Reverts if the signature does not match the signer\\n    /// @param transfer message to verify\\n    /// @param signature EIP712 signature for the message\\n    function verifyMarketTransfer(MarketTransfer calldata transfer, bytes calldata signature) external;\\n\\n    /// @notice Verifies the signature of a request to change rebalancing configuration for multiple markets\\n    /// @dev Cancels the nonce after verifying the signature\\n    /// @param change message to verify\\n    /// @param signature EIP712 signature for the message\\n    function verifyRebalanceConfigChange(RebalanceConfigChange calldata change, bytes calldata signature) external;\\n\\n    /// @notice Verifies the signature of a request to transfer funds from the collateral account back to the owner\\n    /// @dev Cancels the nonce after verifying the signature\\n    ///      Reverts if the signature does not match the signer\\n    /// @param withdrawal message to verify, which includes the owner of the collateral account\\n    /// @param signature EIP712 signature for the message\\n    function verifyWithdrawal(Withdrawal calldata withdrawal, bytes calldata signature) external;\\n}\\n\",\"keccak256\":\"0x0bb0886d949c8460bb90dabd28194379b669896874b702d127f793535c7f1231\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2-account/contracts/interfaces/IController.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport { Fixed6 } from \\\"@equilibria/root/number/types/Fixed6.sol\\\";\\nimport { Token6 } from \\\"@equilibria/root/token/types/Token6.sol\\\";\\nimport { Token18 } from \\\"@equilibria/root/token/types/Token18.sol\\\";\\nimport { IMarketFactory } from \\\"@equilibria/perennial-v2/contracts/interfaces/IMarketFactory.sol\\\";\\n\\nimport { IAccount, IMarket } from \\\"../interfaces/IAccount.sol\\\";\\nimport { IAccountVerifier } from \\\"../interfaces/IAccountVerifier.sol\\\";\\nimport { DeployAccount } from \\\"../types/DeployAccount.sol\\\";\\nimport { MarketTransfer } from \\\"../types/MarketTransfer.sol\\\";\\nimport { RebalanceConfig } from \\\"../types/RebalanceConfig.sol\\\";\\nimport { RebalanceConfigChange } from \\\"../types/RebalanceConfigChange.sol\\\";\\nimport { Withdrawal } from \\\"../types/Withdrawal.sol\\\";\\n\\n/// @notice Facilitates unpermissioned actions between collateral accounts and markets\\ninterface IController {\\n    /// @notice Emitted when a collateral account is deployed\\n    /// @param owner EOA for whom the collateral account was created\\n    /// @param account contract address of the collateral account\\n    event AccountDeployed(address indexed owner, IAccount indexed account);\\n\\n    /// @notice Emitted when a group has been rebalanced\\n    /// @param owner Owner of the collateral account for which the rebalance group was created or modified\\n    /// @param group Identifies the rebalance group within context of owner\\n    event GroupRebalanced(address indexed owner, uint256 indexed group);\\n\\n    /// @notice Emitted when a rebalance group is created or updated\\n    /// @param owner Owner of the collateral account for which the rebalance group was created or modified\\n    /// @param group Identifies the rebalance group within context of owner\\n    /// @param markets Number of markets in the group (0 if group was deleted)\\n    event RebalanceGroupConfigured(address indexed owner, uint256 indexed group, uint256 markets);\\n\\n    /// @notice Emitted for each market in a rebalance group upon creation of the group\\n    /// or when any changes are made to the group\\n    /// @param owner Owner of the collateral account for which the rebalance group was created or modified\\n    /// @param group Identifies the rebalance group within context of owner\\n    /// @param market The Perennial market for which this configuration applies\\n    /// @param newConfig Rebalance configuration for the market, which may or may not have changed\\n    event RebalanceMarketConfigured(\\n        address indexed owner,\\n        uint256 indexed group,\\n        address indexed market,\\n        RebalanceConfig newConfig\\n    );\\n\\n    // sig: 0xdc72f280\\n    /// @custom:error Group is balanced and ineligible for rebalance\\n    error ControllerGroupBalancedError();\\n\\n    // sig: 0xbd3648e9\\n    /// @custom:error A RebalanceConfigChange message had a mismatch in number of markets and configs\\n    error ControllerInvalidRebalanceConfigError();\\n\\n    // sig: 0xa16ba7f2\\n    /// @custom:error Group number was out-of-range; each collateral account may have up to 8 groups, indexed 1-8\\n    error ControllerInvalidRebalanceGroupError();\\n\\n    // sig: 0xecce9fda\\n    /// @custom:error Group has too many markets; each group may have 1-4 markets\\n    error ControllerInvalidRebalanceMarketsError();\\n\\n    // sig: 0x64580a1c\\n    /// @custom:error The sum of `target` collateral allocations for each market in a group does not total 100%.\\n    /// This could also indicate a duplicate market was in the list.\\n    error ControllerInvalidRebalanceTargetsError();\\n\\n    // sig: 0x43e749f8\\n    /// @custom:error Signer is not authorized to interact with the specified collateral account\\n    error ControllerInvalidSignerError();\\n\\n    // sig: 0xa4a79a03\\n    /// @custom:error A market in this rebalancing configuration is already a member of a different group\\n    /// @param market Identifies which market in the message which is causing the problem\\n    /// @param group Identifies the group in which the aforementioned market is a member\\n    error ControllerMarketAlreadyInGroupError(IMarket market, uint256 group);\\n\\n    // sig: 0xdcca49cd\\n    /// @custom:error Attempt to interact with a Market which does not use DSU as collateral\\n    /// @param market Market with non-DSU collateral\\n    error ControllerUnsupportedMarketError(IMarket market);\\n\\n    /// @dev Contract used to validate delegated signers and relay certain messages\\n    function marketFactory() external view returns (IMarketFactory);\\n\\n    /// @dev Contract used to validate message signatures\\n    function verifier() external view returns (IAccountVerifier);\\n\\n    /// @notice Sets contract addresses used for message verification and token management\\n    /// @param marketFactory Contract used to validate delegated signers\\n    /// @param verifier Contract used to validate collateral account message signatures\\n    function initialize(\\n        IMarketFactory marketFactory,\\n        IAccountVerifier verifier\\n    ) external;\\n\\n    /// @notice Returns the deterministic address of the collateral account for a user,\\n    /// regardless of whether or not it exists.\\n    /// @param owner Identifies the user whose collateral account address is desired\\n    function getAccountAddress(address owner) external view returns (address);\\n\\n    /// @notice Deploys the collateral account for msg.sender and returns the address of the account\\n    function deployAccount() external returns (IAccount);\\n\\n    /// @notice Deploys a collateral account via a signed message\\n    /// @param deployAccountAction Message requesting creation of a collateral account\\n    /// @param signature ERC712 message signature\\n    function deployAccountWithSignature(DeployAccount calldata deployAccountAction, bytes calldata signature) external;\\n\\n    /// @notice Transfers tokens between a collateral account and a specified Perennial Market\\n    /// @param marketTransfer Message requesting a deposit to or withdrawal from the Market\\n    /// @param signature ERC712 message signature\\n    function marketTransferWithSignature(MarketTransfer calldata marketTransfer, bytes calldata signature) external;\\n\\n    /// @notice Adjusts the rebalancing configuration of one or more markets\\n    /// @param configChange Message with new rebalance group configuration\\n    /// @param signature ERC712 message signature\\n    function changeRebalanceConfigWithSignature(RebalanceConfigChange calldata configChange,\\n        bytes calldata signature) external;\\n\\n    /// @notice Checks all markets in a rebalance group to see if anything may be rebalanced\\n    /// @param owner User whose collateral account may be rebalanced using this group\\n    /// @param group Identifies the group within the context of the owner\\n    /// @return groupCollateral Sum of ower's collateral across each market in the group\\n    /// @return canRebalance True if one or more markets in the group are eligible for rebalancing\\n    /// @return imbalances The difference between target and actual collateral for each market\\n    function checkGroup(address owner, uint256 group) external view returns (\\n        Fixed6 groupCollateral,\\n        bool canRebalance,\\n        Fixed6[] memory imbalances\\n    );\\n\\n    /// @notice Called by keepers to rebalance an unbalanced group\\n    /// @param owner User whose collateral account may be rebalanced using this group\\n    /// @param group Identifies the group within the context of the owner\\n    function rebalanceGroup(address owner, uint256 group) external;\\n\\n    /// @notice Retrieves rebalance configuration for a specified owner, group, and market\\n    /// @param owner User for whom the collateral account was created\\n    /// @param group Identifies a collection of markets, each with their own configuration\\n    /// @param market Identifies which Perennial market for which the configuration is desired\\n    function rebalanceConfigs(\\n        address owner,\\n        uint256 group,\\n        address market\\n    ) external view returns (RebalanceConfig memory);\\n\\n    /// @notice Retrieves array of markets in an owner's rebalance group\\n    /// @param owner User for whom the collateral account was created\\n    /// @param group Identifies which collection of markets is desired for the owner\\n    /// @return markets Array containing each market in the rebalance group\\n    function rebalanceGroupMarkets(\\n        address owner,\\n        uint256 group\\n    ) external view returns (IMarket[] memory markets);\\n\\n    /// @notice Transfers tokens from the collateral account back to the owner of the account\\n    /// @param withdrawal Message requesting a withdrawal\\n    /// @param signature ERC712 message signature\\n    function withdrawWithSignature(Withdrawal calldata withdrawal, bytes calldata signature) external;\\n}\",\"keccak256\":\"0x461caf9cfba561922b531a28da4be58f5249c953120fd456f338420ce81876d9\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2-account/contracts/interfaces/IRelayVerifier.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport { IVerifierBase } from \\\"@equilibria/root/verifier/interfaces/IVerifierBase.sol\\\";\\nimport { RelayedNonceCancellation } from \\\"../types/RelayedNonceCancellation.sol\\\";\\nimport { RelayedGroupCancellation } from \\\"../types/RelayedGroupCancellation.sol\\\";\\nimport { RelayedOperatorUpdate } from \\\"../types/RelayedOperatorUpdate.sol\\\";\\nimport { RelayedSignerUpdate } from \\\"../types/RelayedSignerUpdate.sol\\\";\\nimport { RelayedAccessUpdateBatch } from \\\"../types/RelayedAccessUpdateBatch.sol\\\";\\n\\n/// @notice EIP712 signed message verifier for relaying messages through Collateral Accounts Controller.\\ninterface IRelayVerifier is IVerifierBase {\\n    /// @dev Verifies a request to relay a nonce cancellation request\\n    /// @param message Wrapped message adding details needed for keeper compensation\\n    /// @param outerSignature EIP712 signature for the preceeding message\\n    function verifyRelayedNonceCancellation(\\n        RelayedNonceCancellation calldata message,\\n        bytes calldata outerSignature\\n    ) external;\\n\\n    /// @dev Verifies a request to relay a group nonce cancellation request\\n    /// @param message Wrapped message adding details needed for keeper compensation\\n    /// @param outerSignature EIP712 signature for the preceeding message\\n    function verifyRelayedGroupCancellation(\\n        RelayedGroupCancellation calldata message,\\n        bytes calldata outerSignature\\n    ) external;\\n\\n    /// @dev Verifies a request to relay an operator update\\n    /// @param message Wrapped message adding details needed for keeper compensation\\n    /// @param outerSignature EIP712 signature for the preceeding message\\n    function verifyRelayedOperatorUpdate(\\n        RelayedOperatorUpdate calldata message,\\n        bytes calldata outerSignature\\n    ) external;\\n\\n    /// @dev Verifies a request to relay an update to designated signers\\n    /// @param message Wrapped message adding details needed for keeper compensation\\n    /// @param outerSignature EIP712 signature for the preceeding message\\n    function verifyRelayedSignerUpdate(\\n        RelayedSignerUpdate calldata message,\\n        bytes calldata outerSignature\\n    ) external;\\n\\n    /// @dev Verifies a request to relay a message updating multiple operators and signers\\n    /// @param message Wrapped message adding details needed for keeper compensation\\n    /// @param outerSignature EIP712 signature for the preceeding message\\n    function verifyRelayedAccessUpdateBatch(\\n        RelayedAccessUpdateBatch calldata message,\\n        bytes calldata outerSignature\\n    ) external;\\n}\\n\",\"keccak256\":\"0xb6da649aa7e73698d2aa1fe7c74f53c3b9d7922e81bedef510b9f9f79f1594cc\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2-account/contracts/interfaces/IRelayer.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport { RelayedNonceCancellation } from \\\"../types/RelayedNonceCancellation.sol\\\";\\nimport { RelayedGroupCancellation } from \\\"../types/RelayedGroupCancellation.sol\\\";\\nimport { RelayedOperatorUpdate } from \\\"../types/RelayedOperatorUpdate.sol\\\";\\nimport { RelayedSignerUpdate } from \\\"../types/RelayedSignerUpdate.sol\\\";\\nimport { RelayedAccessUpdateBatch } from \\\"../types/RelayedAccessUpdateBatch.sol\\\";\\n\\n// @notice Relays messages to downstream handlers, compensating keepers for the transaction\\ninterface IRelayer {\\n    /// @notice Relays a message to Verifier extension to invalidate a nonce\\n    /// @param message Request with details needed for keeper compensation\\n    /// @param outerSignature Signature of the RelayedNonceCancellation message\\n    /// @param innerSignature Signature of the embedded Common message\\n    function relayNonceCancellation(\\n        RelayedNonceCancellation calldata message,\\n        bytes calldata outerSignature,\\n        bytes calldata innerSignature\\n    ) external;\\n\\n    /// @notice Relays a message to Verifier extension to invalidate a group nonce\\n    /// @param message Request with details needed for keeper compensation\\n    /// @param outerSignature Signature of the RelayedGroupCancellation message\\n    /// @param innerSignature Signature of the embedded GroupCancellation message\\n    function relayGroupCancellation(\\n        RelayedGroupCancellation calldata message,\\n        bytes calldata outerSignature,\\n        bytes calldata innerSignature\\n    ) external;\\n\\n    /// @notice Relays a message to MarketFactory to update status of an operator\\n    /// @param message Request with details needed for keeper compensation\\n    /// @param outerSignature Signature of the RelayedOperatorUpdate message\\n    /// @param innerSignature Signature of the embedded OperatorUpdate message\\n    function relayOperatorUpdate(\\n        RelayedOperatorUpdate calldata message,\\n        bytes calldata outerSignature,\\n        bytes calldata innerSignature\\n    ) external;\\n\\n    /// @notice Relays a message to MarketFactory to update status of a delegated signer\\n    /// @param message Request with details needed for keeper compensation\\n    /// @param outerSignature Signature of the RelayedSignerUpdate message\\n    /// @param innerSignature Signature of the embedded SignerUpdate message\\n    function relaySignerUpdate(\\n        RelayedSignerUpdate calldata message,\\n        bytes calldata outerSignature,\\n        bytes calldata innerSignature\\n    ) external;\\n\\n    /// @notice Relays a message to MarketFactory to update multiple operators and signers\\n    /// @param message Request with details needed for keeper compensation\\n    /// @param outerSignature Signature of the RelayedAccessUpdateBatch message\\n    /// @param innerSignature Signature of the embedded AccessUpdateBatch message\\n    function relayAccessUpdateBatch(\\n        RelayedAccessUpdateBatch calldata message,\\n        bytes calldata outerSignature,\\n        bytes calldata innerSignature\\n    ) external;\\n}\",\"keccak256\":\"0x27c26b035dc1335a6abf3bc8c1487c99e5e84e9e1b1919c211f461a67493cbc4\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2-account/contracts/libs/RebalanceLib.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport { Fixed6, Fixed6Lib } from \\\"@equilibria/root/number/types/Fixed6.sol\\\";\\nimport { UFixed6 } from \\\"@equilibria/root/number/types/UFixed6.sol\\\";\\nimport { IController } from \\\"../interfaces/IController.sol\\\";\\nimport { RebalanceConfig } from \\\"../types/RebalanceConfig.sol\\\";\\n\\n/// @title RebalanceLib\\n/// @notice Facilities for rebalancing collateral accounts\\nlibrary RebalanceLib {\\n    /// @dev Compares actual market collateral for owner with their account's target\\n    /// @param marketConfig Rebalance group configuration for this market\\n    /// @param groupCollateral Owner's collateral across all markets in the group\\n    /// @param marketCollateral Owner's actual amount of collateral in this market\\n    /// @return canRebalance True if actual collateral in this market is outside of configured threshold\\n    /// @return imbalance Amount which needs to be transferred to balance the market\\n    function checkMarket(\\n        RebalanceConfig memory marketConfig,\\n        Fixed6 groupCollateral,\\n        Fixed6 marketCollateral\\n    ) external pure returns (bool canRebalance, Fixed6 imbalance) {\\n        // determine how much collateral the market should have\\n        Fixed6 targetCollateral = groupCollateral.mul(Fixed6Lib.from(marketConfig.target));\\n\\n        // if market is empty, prevent divide-by-zero condition\\n        if (marketCollateral.eq(Fixed6Lib.ZERO)) return (false, targetCollateral);\\n        // calculate percentage difference between target and actual collateral\\n        Fixed6 pctFromTarget = Fixed6Lib.ONE.sub(targetCollateral.div(marketCollateral));\\n        // if this percentage exceeds the configured threshold, the market may be rebelanced\\n        canRebalance = pctFromTarget.abs().gt(marketConfig.threshold);\\n\\n        // return negative number for surplus, positive number for deficit\\n        imbalance = targetCollateral.sub(marketCollateral);\\n    }\\n}\",\"keccak256\":\"0x83293e8d36fa69d31106f10ff01f49d50dfc8a579f5908e878d865b24b1e9d0e\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2-account/contracts/types/Action.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport { Common, CommonLib } from \\\"@equilibria/root/verifier/types/Common.sol\\\";\\nimport { UFixed6 } from \\\"@equilibria/root/number/types/UFixed6.sol\\\";\\n\\n/// @notice Fields which need to be hashed for each collateral account action\\nstruct Action {\\n    /// @dev Largest amount to compensate relayer/keeper for the transaction in DSU\\n    UFixed6 maxFee;\\n    /// @dev Information shared across all EIP712 collateral account actions;\\n    /// populate common.account with the owner of the collateral account\\n    Common common;\\n}\\nusing ActionLib for Action global;\\n\\n/// @title ActionLib\\n/// @notice Library used to hash and verifiy fields common to all collateral-account-related messages\\nlibrary ActionLib {\\n    /// @dev Used to verify a signed message\\n    bytes32 constant public STRUCT_HASH = keccak256(\\n        \\\"Action(uint256 maxFee,Common common)\\\"\\n        \\\"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\\\"\\n    );\\n\\n    /// @dev Used to create a signed message\\n    function hash(Action memory self) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(STRUCT_HASH, self.maxFee, CommonLib.hash(self.common)));\\n    }\\n}\\n\",\"keccak256\":\"0x08a90145b4fc781ad53cb9ef581f1123e9569500d793fde88ed63ceb32df68a8\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2-account/contracts/types/DeployAccount.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport { Action, ActionLib } from \\\"./Action.sol\\\";\\n\\nstruct DeployAccount {\\n    /// @dev Common information for collateral account actions\\n    Action action;\\n}\\nusing DeployAccountLib for DeployAccount global;\\n\\n/// @title DeployAccountLib\\n/// @notice Library used to hash and verify action to deploy a collateral account\\nlibrary DeployAccountLib {\\n    /// @dev Used to verify a signed message\\n    bytes32 constant public STRUCT_HASH = keccak256(\\n        \\\"DeployAccount(Action action)\\\"\\n        \\\"Action(uint256 maxFee,Common common)\\\"\\n        \\\"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\\\"\\n    );\\n\\n    /// @dev Used to create a signed message\\n    function hash(DeployAccount memory self) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(STRUCT_HASH, ActionLib.hash(self.action)));\\n    }\\n}\\n\",\"keccak256\":\"0x1b3f83e65059bc3531be1385b2ecceb615c4e61834b50b0e5e56bdbfa6b73337\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2-account/contracts/types/MarketTransfer.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport { Fixed6, Fixed6Lib } from \\\"@equilibria/root/number/types/Fixed6.sol\\\";\\nimport { Action, ActionLib } from \\\"./Action.sol\\\";\\n\\nstruct MarketTransfer {\\n    /// @dev Identifies the market to which funds should be sent\\n    address market;\\n    /// @dev Amount to deposit (positive) or withdraw (negative);\\n    /// set to Fixed6Lib.MIN to fully withdraw from market.\\n    Fixed6 amount;\\n    /// @dev Common information for collateral account actions\\n    Action action;\\n}\\nusing MarketTransferLib for MarketTransfer global;\\n\\n/// @title MarketTransferLib\\n/// @notice Library used to hash and verify action to move funds to/from a market\\nlibrary MarketTransferLib {\\n    /// @dev Used to verify a signed message\\n    bytes32 constant public STRUCT_HASH = keccak256(\\n        \\\"MarketTransfer(address market,int256 amount,Action action)\\\"\\n        \\\"Action(uint256 maxFee,Common common)\\\"\\n        \\\"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\\\"\\n    );\\n\\n    /// @dev Used to create a signed message\\n    function hash(MarketTransfer memory self) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(STRUCT_HASH, self.market, self.amount, ActionLib.hash(self.action)));\\n    }\\n}\\n\",\"keccak256\":\"0xcbcd5092a901cbe8dfda7736fbcf314c9e9cc5f6e67fe58226a48113a3b9730e\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2-account/contracts/types/RebalanceConfig.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport { UFixed6, UFixed6Lib } from \\\"@equilibria/root/number/types/UFixed6.sol\\\";\\n\\n/// @dev Rebalancing configuration for a single market\\nstruct RebalanceConfig {\\n    /// @dev Percentage of collateral from the group to deposit into the market\\n    UFixed6 target;\\n    /// @dev Percentage away from the target at which keepers may rebalance\\n    UFixed6 threshold;\\n}\\n\\nstruct RebalanceConfigStorage { uint256 slot0; }\\nusing RebalanceConfigLib for RebalanceConfigStorage global;\\n\\n/// @title RebalanceConfigLib\\n/// @notice Library used to hash and manage storage for rebalancing configuration for a single market\\nlibrary RebalanceConfigLib {\\n    bytes32 constant public STRUCT_HASH = keccak256(\\n        \\\"RebalanceConfig(uint256 target,uint256 threshold)\\\"\\n    );\\n\\n    /// sig: 0xd673935e\\n    error RebalanceConfigStorageInvalidError();\\n\\n    /// @dev hashes this instance for inclusion in an EIP-712 message\\n    function hash(RebalanceConfig memory self) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(STRUCT_HASH, self.target, self.threshold));\\n    }\\n\\n    /// @dev extracts two unsigned values from a single storage slot\\n    function read(RebalanceConfigStorage storage self) internal view returns (RebalanceConfig memory) {\\n        uint256 slot0 = self.slot0;\\n        return RebalanceConfig(\\n            UFixed6.wrap(uint256(slot0 << (256 - 32)) >> (256 - 32)),\\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 32)) >> (256 - 32))\\n        );\\n    }\\n\\n    /// @dev ensures values do not exceed 100% and writes them to a single storage slot\\n    function store(RebalanceConfigStorage storage self, RebalanceConfig memory newValue) external {\\n        if (newValue.target.gt(UFixed6Lib.ONE)) revert RebalanceConfigStorageInvalidError();\\n        if (newValue.threshold.gt(UFixed6Lib.ONE)) revert RebalanceConfigStorageInvalidError();\\n\\n        uint256 encoded0 =\\n            uint256(UFixed6.unwrap(newValue.target)    << (256 - 32)) >> (256 - 32) |\\n            uint256(UFixed6.unwrap(newValue.threshold) << (256 - 32)) >> (256 - 32 - 32);\\n\\n        assembly {\\n            sstore(self.slot, encoded0)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x7aea3201155589c740682a9d3fd2aed019e07b10dda7eeb15bc442fde280369c\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2-account/contracts/types/RebalanceConfigChange.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport { UFixed6 } from \\\"@equilibria/root/number/types/UFixed6.sol\\\";\\nimport { Action, ActionLib } from \\\"./Action.sol\\\";\\nimport { RebalanceConfig, RebalanceConfigLib } from \\\"./RebalanceConfig.sol\\\";\\nimport { IController } from \\\"../interfaces/IController.sol\\\";\\n\\n/// @dev Action message to change configuration for a group of markets\\nstruct RebalanceConfigChange {\\n    /// @dev Identifies which group to change; indexed 1-8\\n    uint256 group;\\n    /// @dev List of 1-4 markets in which collateral shall be managed.\\n    /// Markets may be added to or removed from an existing group. Leave empty to delete the group.\\n    address[] markets;\\n    /// @dev Target allocation for markets in the aforementioned array\\n    RebalanceConfig[] configs;\\n    /// @dev Largest amount to compensate a relayer/keeper for rebalancing the group in DSU\\n    UFixed6 maxFee;\\n    /// @dev Common information for collateral account actions\\n    Action action;\\n}\\nusing RebalanceConfigChangeLib for RebalanceConfigChange global;\\n\\n/// @title RebalanceConfigChangeLib\\n/// @notice Library used to hash and verify action to change rebalancing configuration\\nlibrary RebalanceConfigChangeLib {\\n    /// @dev Used to verify a signed message\\n    bytes32 constant public STRUCT_HASH = keccak256(\\n        \\\"RebalanceConfigChange(uint256 group,address[] markets,RebalanceConfig[] configs,uint256 maxFee,Action action)\\\"\\n        \\\"Action(uint256 maxFee,Common common)\\\"\\n        \\\"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\\\"\\n        \\\"RebalanceConfig(uint256 target,uint256 threshold)\\\"\\n    );\\n\\n    /// @dev Used to create a signed message\\n    function hash(RebalanceConfigChange memory self) internal pure returns (bytes32) {\\n        bytes32[] memory encodedAddresses = new bytes32[](self.markets.length);\\n        bytes32[] memory encodedConfigs = new bytes32[](self.configs.length);\\n\\n        // ensure consistent error for length mismatch\\n        if (self.markets.length != self.configs.length)\\n            revert IController.ControllerInvalidRebalanceConfigError();\\n\\n        for (uint256 i = 0; i < self.markets.length; ++i) {\\n            encodedAddresses[i] = keccak256(abi.encode(self.markets[i]));\\n            encodedConfigs[i] = RebalanceConfigLib.hash(self.configs[i]);\\n        }\\n        return keccak256(abi.encode(\\n            STRUCT_HASH,\\n            self.group,\\n            keccak256(abi.encodePacked(self.markets)),\\n            keccak256(abi.encodePacked(encodedConfigs)),\\n            self.maxFee,\\n            ActionLib.hash(self.action)\\n        ));\\n    }\\n}\\n\",\"keccak256\":\"0xef27da3eefd98aa56e3908e32cb6fa084579529117faf59a02d56cddf63c6834\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2-account/contracts/types/RelayedAccessUpdateBatch.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport { AccessUpdateBatch, AccessUpdateBatchLib } from \\\"@equilibria/perennial-v2-verifier/contracts/types/AccessUpdateBatch.sol\\\";\\nimport { Action, ActionLib } from \\\"./Action.sol\\\";\\n\\nstruct RelayedAccessUpdateBatch {\\n    /// @dev Message to relay to MarketFactory\\n    AccessUpdateBatch accessUpdateBatch;\\n    /// @dev Common information for relayed actions\\n    Action action;\\n}\\nusing RelayedAccessUpdateBatchLib for RelayedAccessUpdateBatch global;\\n\\n/// @title RelayedAccessUpdateBatchLib\\n/// @notice Library used to hash and verify action to relay a message to change status of operators and signers\\nlibrary RelayedAccessUpdateBatchLib {\\n    /// @dev Used to verify a signed message\\n    bytes32 constant public STRUCT_HASH = keccak256(\\n        \\\"RelayedAccessUpdateBatch(AccessUpdateBatch accessUpdateBatch,Action action)\\\"\\n        \\\"AccessUpdate(address accessor,bool approved)\\\"\\n        \\\"AccessUpdateBatch(AccessUpdate[] operators,AccessUpdate[] signers,Common common)\\\"\\n        \\\"Action(uint256 maxFee,Common common)\\\"\\n        \\\"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\\\"\\n    );\\n\\n    /// @dev Used to create a signed message\\n    function hash(RelayedAccessUpdateBatch memory self) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(STRUCT_HASH, AccessUpdateBatchLib.hash(self.accessUpdateBatch), ActionLib.hash(self.action)));\\n    }\\n}\",\"keccak256\":\"0x031776b735ee77573b6dc1f74df2decfe1de4f1312a2b32966641df7249e2d8c\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2-account/contracts/types/RelayedGroupCancellation.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport { GroupCancellation, GroupCancellationLib } from \\\"@equilibria/root/verifier/types/GroupCancellation.sol\\\";\\nimport { Action, ActionLib } from \\\"./Action.sol\\\";\\n\\nstruct RelayedGroupCancellation {\\n    /// @dev Message to relay to verifier, identifying the group to cancel\\n    GroupCancellation groupCancellation;\\n    /// @dev Common information for relayed actions\\n    Action action;\\n}\\nusing RelayedGroupCancellationLib for RelayedGroupCancellation global;\\n\\n/// @title RelayedGroupCancellationLib\\n/// @notice Library used to hash and verify action to relay a message to cancel a group\\nlibrary RelayedGroupCancellationLib {\\n    /// @dev Used to verify a signed message\\n    bytes32 constant public STRUCT_HASH = keccak256(\\n        \\\"RelayedGroupCancellation(GroupCancellation groupCancellation,Action action)\\\"\\n        \\\"Action(uint256 maxFee,Common common)\\\"\\n        \\\"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\\\"\\n        \\\"GroupCancellation(uint256 group,Common common)\\\"\\n    );\\n\\n    /// @dev Used to create a signed message\\n    function hash(RelayedGroupCancellation memory self) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(STRUCT_HASH, GroupCancellationLib.hash(self.groupCancellation), ActionLib.hash(self.action)));\\n    }\\n}\",\"keccak256\":\"0x5030f2b72b0b0748081229a92f6e1ed657d9ecd66707508b6699f256b96d00fb\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2-account/contracts/types/RelayedNonceCancellation.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport { Common, CommonLib } from \\\"@equilibria/root/verifier/types/Common.sol\\\";\\nimport { Action, ActionLib } from \\\"./Action.sol\\\";\\n\\nstruct RelayedNonceCancellation {\\n    /// @dev Message to relay to verifier, identifying the nonce to cancel\\n    Common nonceCancellation;\\n    /// @dev Common information for relayed actions\\n    Action action;\\n}\\nusing RelayedNonceCancellationLib for RelayedNonceCancellation global;\\n\\n/// @title RelayedNonceCancellationLib\\n/// @notice Library used to hash and verify action to relay a message to cancel a nonce\\nlibrary RelayedNonceCancellationLib {\\n    /// @dev Used to verify a signed message\\n    bytes32 constant public STRUCT_HASH = keccak256(\\n        \\\"RelayedNonceCancellation(Common nonceCancellation,Action action)\\\"\\n        \\\"Action(uint256 maxFee,Common common)\\\"\\n        \\\"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\\\"\\n    );\\n\\n    /// @dev Used to create a signed message\\n    function hash(RelayedNonceCancellation memory self) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(STRUCT_HASH, CommonLib.hash(self.nonceCancellation), ActionLib.hash(self.action)));\\n    }\\n}\",\"keccak256\":\"0x59249bd0ee1ce84f276d3e2a20136f9e8959dad737e4f1cced458feebbb51c38\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2-account/contracts/types/RelayedOperatorUpdate.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport { OperatorUpdate, OperatorUpdateLib } from \\\"@equilibria/perennial-v2-verifier/contracts/types/OperatorUpdate.sol\\\";\\nimport { Action, ActionLib } from \\\"./Action.sol\\\";\\n\\nstruct RelayedOperatorUpdate {\\n    /// @dev Message to relay to MarketFactory\\n    OperatorUpdate operatorUpdate;\\n    /// @dev Common information for relayed actions\\n    Action action;\\n}\\nusing RelayedOperatorUpdateLib for RelayedOperatorUpdate global;\\n\\n/// @title RelayedOperatorUpdateLib\\n/// @notice Library used to hash and verify action to relay a message to update an operator\\nlibrary RelayedOperatorUpdateLib {\\n    /// @dev Used to verify a signed message\\n    bytes32 constant public STRUCT_HASH = keccak256(\\n        \\\"RelayedOperatorUpdate(OperatorUpdate operatorUpdate,Action action)\\\"\\n        \\\"AccessUpdate(address accessor,bool approved)\\\"\\n        \\\"Action(uint256 maxFee,Common common)\\\"\\n        \\\"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\\\"\\n        \\\"OperatorUpdate(AccessUpdate access,Common common)\\\"\\n    );\\n\\n    /// @dev Used to create a signed message\\n    function hash(RelayedOperatorUpdate memory self) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(STRUCT_HASH, OperatorUpdateLib.hash(self.operatorUpdate), ActionLib.hash(self.action)));\\n    }\\n}\",\"keccak256\":\"0x488b1e898b530e64ce39d1eeca208312ba9967a39c3c0927654045bb77c912c9\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2-account/contracts/types/RelayedSignerUpdate.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport { SignerUpdate, SignerUpdateLib } from \\\"@equilibria/perennial-v2-verifier/contracts/types/SignerUpdate.sol\\\";\\nimport { Action, ActionLib } from \\\"./Action.sol\\\";\\n\\nstruct RelayedSignerUpdate {\\n    /// @dev Message to relay to MarketFactory\\n    SignerUpdate signerUpdate;\\n    /// @dev Common information for relayed actions\\n    Action action;\\n}\\nusing RelayedSignerUpdateLib for RelayedSignerUpdate global;\\n\\n/// @title RelayedSignerUpdateLib\\n/// @notice Library used to hash and verify action to relay a message to update a signer\\nlibrary RelayedSignerUpdateLib {\\n    /// @dev Used to verify a signed message\\n    bytes32 constant public STRUCT_HASH = keccak256(\\n        \\\"RelayedSignerUpdate(SignerUpdate signerUpdate,Action action)\\\"\\n        \\\"AccessUpdate(address accessor,bool approved)\\\"\\n        \\\"Action(uint256 maxFee,Common common)\\\"\\n        \\\"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\\\"\\n        \\\"SignerUpdate(AccessUpdate access,Common common)\\\"\\n    );\\n\\n    /// @dev Used to create a signed message\\n    function hash(RelayedSignerUpdate memory self) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(STRUCT_HASH, SignerUpdateLib.hash(self.signerUpdate), ActionLib.hash(self.action)));\\n    }\\n}\\n\",\"keccak256\":\"0x5f0cb8f33b56603b0342d040be34e21fef033fc612b70613ec638916f5700ddb\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2-account/contracts/types/Withdrawal.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport { UFixed6 } from \\\"@equilibria/root/number/types/UFixed6.sol\\\";\\nimport { Action, ActionLib } from \\\"./Action.sol\\\";\\n\\nstruct Withdrawal {\\n    /// @dev Quantity to transfer from account to owner; set to UFixed6.MAX for full withdrawal\\n    UFixed6 amount;\\n    /// @dev True unwrap DSU to USDC as needed to satisfy specified withdrawal amount\\n    bool unwrap;\\n    /// @dev Common information for collateral account actions;\\n    /// set action.common.account to the owner of the collateral account\\n    Action action;\\n}\\nusing WithdrawalLib for Withdrawal global;\\n\\n/// @title WithdrawalLib\\n/// @notice Library used to hash and verify action to withdraw from a collateral account\\nlibrary WithdrawalLib {\\n    /// @dev Used to verify a signed message\\n    bytes32 constant public STRUCT_HASH = keccak256(\\n        \\\"Withdrawal(uint256 amount,bool unwrap,Action action)\\\"\\n        \\\"Action(uint256 maxFee,Common common)\\\"\\n        \\\"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\\\"\\n    );\\n\\n    /// @dev Used to create a signed message\\n    function hash(Withdrawal memory self) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(STRUCT_HASH, self.amount, self.unwrap, ActionLib.hash(self.action)));\\n    }\\n}\",\"keccak256\":\"0xa2793c9b58739251f78bbdc0ac391ee2456ec542375c6b28101e6aaf8898a186\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2-verifier/contracts/interfaces/IVerifier.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport { IVerifierBase } from \\\"@equilibria/root/verifier/interfaces/IVerifierBase.sol\\\";\\nimport { Common } from \\\"@equilibria/root/verifier/types/Common.sol\\\";\\nimport { Intent } from \\\"../types/Intent.sol\\\";\\nimport { OperatorUpdate } from \\\"../types/OperatorUpdate.sol\\\";\\nimport { SignerUpdate } from \\\"../types/SignerUpdate.sol\\\";\\nimport { AccessUpdateBatch } from \\\"../types/AccessUpdateBatch.sol\\\";\\n\\ninterface IVerifier is IVerifierBase {\\n    function verifyIntent(Intent calldata intent, bytes calldata signature) external;\\n    function verifyOperatorUpdate(OperatorUpdate calldata operatorUpdate, bytes calldata signature) external;\\n    function verifySignerUpdate(SignerUpdate calldata signerUpdate, bytes calldata signature) external;\\n    function verifyAccessUpdateBatch(AccessUpdateBatch calldata accessUpdateBatch, bytes calldata signature) external;\\n}\",\"keccak256\":\"0x44324d826778f9b8d2f67d372da9fff32385deba95141a0930f803a55582f2e6\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2-verifier/contracts/types/AccessUpdate.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport { UFixed6 } from \\\"@equilibria/root/number/types/UFixed6.sol\\\";\\nimport { Fixed6 } from \\\"@equilibria/root/number/types/Fixed6.sol\\\";\\nimport { Common, CommonLib } from \\\"@equilibria/root/verifier/types/Common.sol\\\";\\n\\nstruct AccessUpdate {\\n    /// @dev The generic signer or operator to approve for the signing account\\n    address accessor;\\n\\n    /// @dev The new status of the signer or operator\\n    bool approved;\\n}\\nusing AccessUpdateLib for AccessUpdate global;\\n\\n/// @title AccessUpdateLib\\n/// @notice Library for AccessUpdate logic and data.\\nlibrary AccessUpdateLib {\\n    bytes32 constant public STRUCT_HASH = keccak256(\\\"AccessUpdate(address accessor,bool approved)\\\");\\n\\n    function hash(AccessUpdate memory self) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(STRUCT_HASH, self.accessor, self.approved));\\n    }\\n}\\n\",\"keccak256\":\"0xb1399f3c02437feba0b2cbdf098e59b7d829e6c8c22673d9eef551cbf0c468ad\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2-verifier/contracts/types/AccessUpdateBatch.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport { UFixed6 } from \\\"@equilibria/root/number/types/UFixed6.sol\\\";\\nimport { Fixed6 } from \\\"@equilibria/root/number/types/Fixed6.sol\\\";\\nimport { Common, CommonLib } from \\\"@equilibria/root/verifier/types/Common.sol\\\";\\nimport { AccessUpdate, AccessUpdateLib } from \\\"../types/AccessUpdate.sol\\\";\\n\\nstruct AccessUpdateBatch {\\n    /// @dev The operator access update messages\\n    AccessUpdate[] operators;\\n\\n    /// @dev The signer access update messages\\n    AccessUpdate[] signers;\\n\\n    /// @dev The common information for the intent\\n    Common common;\\n}\\nusing AccessUpdateBatchLib for AccessUpdateBatch global;\\n\\n/// @title AccessUpdateBatchLib\\n/// @notice Library for AccessUpdateBatch logic and data.\\nlibrary AccessUpdateBatchLib {\\n    bytes32 constant public STRUCT_HASH = keccak256(\\n        \\\"AccessUpdateBatch(AccessUpdate[] operators,AccessUpdate[] signers,Common common)\\\"\\n        \\\"AccessUpdate(address accessor,bool approved)\\\"\\n        \\\"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\\\"\\n    );\\n\\n    function hash(AccessUpdateBatch memory self) internal pure returns (bytes32) {\\n        bytes32[] memory operatorHashes = new bytes32[](self.operators.length);\\n        bytes32[] memory signerHashes = new bytes32[](self.signers.length);\\n\\n        for (uint256 i = 0; i < self.operators.length; i++)\\n            operatorHashes[i] = AccessUpdateLib.hash(self.operators[i]);\\n        for (uint256 i = 0; i < self.signers.length; i++)\\n            signerHashes[i] = AccessUpdateLib.hash(self.signers[i]);\\n\\n        return keccak256(\\n            abi.encode(\\n                STRUCT_HASH,\\n                keccak256(abi.encodePacked(operatorHashes)),\\n                keccak256(abi.encodePacked(signerHashes)),\\n                CommonLib.hash(self.common)\\n            )\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0xd1a6d36e20cd290cefcdcd0adbeb52e06ea35f62b1133b3d647d89c13bf8f6cc\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2-verifier/contracts/types/Intent.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport { UFixed6, UFixed6Lib } from \\\"@equilibria/root/number/types/UFixed6.sol\\\";\\nimport { Fixed6 } from \\\"@equilibria/root/number/types/Fixed6.sol\\\";\\nimport { Common, CommonLib } from \\\"@equilibria/root/verifier/types/Common.sol\\\";\\n\\nstruct Intent {\\n    /// @dev The size and direction of the order being opened by the taker\\n    ///       - Positive opens long / Negative opens short\\n    ///       - The maker will open the opposite side of the order\\n    ///       - To close, open an order in the opposite direction\\n    Fixed6 amount;\\n\\n    /// @dev The price to execute the order at\\n    Fixed6 price;\\n\\n    /// @dev The solver fee, a percentage of the substractive interface fee\\n    UFixed6 fee;\\n\\n    /// @dev The referral address of the originator of the order (ex. the interface)\\n    address originator;\\n\\n    /// @dev The referral address of the solver of the order (ex. the router)\\n    address solver;\\n\\n    /// @dev The minimium collateralization ratio that must be maintained after the order is executed\\n    UFixed6 collateralization;\\n\\n    /// @dev The common information for the intent\\n    Common common;\\n}\\nusing IntentLib for Intent global;\\n\\n/// @title IntentLib\\n/// @notice Library for Intent logic and data.\\nlibrary IntentLib {\\n    bytes32 constant public STRUCT_HASH = keccak256(\\n        \\\"Intent(int256 amount,int256 price,uint256 fee,address originator,address solver,uint256 collateralization,Common common)\\\"\\n        \\\"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\\\"\\n    );\\n\\n    function hash(Intent memory self) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(STRUCT_HASH, self.amount, self.price, self.fee, self.originator, self.solver, self.collateralization, CommonLib.hash(self.common)));\\n    }\\n}\\n\",\"keccak256\":\"0xc7bb16c559362c751d1889d6fea834be0066674ace8fe610f15122f1979b483b\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2-verifier/contracts/types/OperatorUpdate.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport { Common, CommonLib } from \\\"@equilibria/root/verifier/types/Common.sol\\\";\\nimport { AccessUpdate, AccessUpdateLib } from \\\"./AccessUpdate.sol\\\";\\n\\nstruct OperatorUpdate {\\n    /// @dev The operator access to update\\n    AccessUpdate access;\\n\\n    /// @dev The common information for the intent\\n    Common common;\\n}\\nusing OperatorUpdateLib for OperatorUpdate global;\\n\\n/// @title OperatorUpdateLib\\n/// @notice Library for OperatorUpdate logic and data.\\nlibrary OperatorUpdateLib {\\n    bytes32 constant public STRUCT_HASH = keccak256(\\n        \\\"OperatorUpdate(AccessUpdate access,Common common)\\\"\\n        \\\"AccessUpdate(address accessor,bool approved)\\\"\\n        \\\"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\\\"\\n    );\\n\\n    function hash(OperatorUpdate memory self) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(STRUCT_HASH, AccessUpdateLib.hash(self.access), CommonLib.hash(self.common)));\\n    }\\n}\\n\",\"keccak256\":\"0x9862489310881cb283f8befc10ad91599e0ee2fb617962be1957fb077a36f619\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2-verifier/contracts/types/SignerUpdate.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport { UFixed6 } from \\\"@equilibria/root/number/types/UFixed6.sol\\\";\\nimport { Fixed6 } from \\\"@equilibria/root/number/types/Fixed6.sol\\\";\\nimport { Common, CommonLib } from \\\"@equilibria/root/verifier/types/Common.sol\\\";\\nimport { AccessUpdate, AccessUpdateLib } from \\\"./AccessUpdate.sol\\\";\\n\\nstruct SignerUpdate {\\n    /// @dev The signer access to update\\n    AccessUpdate access;\\n\\n    /// @dev The common information for the intent\\n    Common common;\\n}\\nusing SignerUpdateLib for SignerUpdate global;\\n\\n/// @title SignerUpdateLib\\n/// @notice Library for SignerUpdate logic and data.\\nlibrary SignerUpdateLib {\\n    bytes32 constant public STRUCT_HASH = keccak256(\\n        \\\"SignerUpdate(AccessUpdate access,Common common)\\\"\\n        \\\"AccessUpdate(address accessor,bool approved)\\\"\\n        \\\"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\\\"\\n    );\\n\\n    function hash(SignerUpdate memory self) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(STRUCT_HASH, AccessUpdateLib.hash(self.access), CommonLib.hash(self.common)));\\n    }\\n}\\n\",\"keccak256\":\"0xd3165bfb61c612bb24eb360d7dd00b535731ca9f3ef0a806167f7f0995d4c6c8\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2/contracts/interfaces/IMarket.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@equilibria/root/attribute/interfaces/IInstance.sol\\\";\\nimport \\\"@equilibria/root/number/types/UFixed6.sol\\\";\\nimport \\\"@equilibria/root/token/types/Token18.sol\\\";\\nimport \\\"@equilibria/perennial-v2-verifier/contracts/types/Intent.sol\\\";\\nimport \\\"./IOracleProvider.sol\\\";\\nimport \\\"../types/OracleVersion.sol\\\";\\nimport \\\"../types/MarketParameter.sol\\\";\\nimport \\\"../types/RiskParameter.sol\\\";\\nimport \\\"../types/Version.sol\\\";\\nimport \\\"../types/Local.sol\\\";\\nimport \\\"../types/Global.sol\\\";\\nimport \\\"../types/Position.sol\\\";\\nimport \\\"../types/Checkpoint.sol\\\";\\nimport \\\"../types/Guarantee.sol\\\";\\nimport \\\"../libs/VersionLib.sol\\\";\\n\\ninterface IMarket is IInstance {\\n    struct MarketDefinition {\\n        Token18 token;\\n        IOracleProvider oracle;\\n    }\\n\\n    struct Context {\\n        address account;\\n        MarketParameter marketParameter;\\n        RiskParameter riskParameter;\\n        OracleVersion latestOracleVersion;\\n        uint256 currentTimestamp;\\n        Global global;\\n        Local local;\\n        Position latestPositionGlobal;\\n        Position latestPositionLocal;\\n        Order pendingGlobal;\\n        Order pendingLocal;\\n    }\\n\\n    struct SettlementContext {\\n        Version latestVersion;\\n        Checkpoint latestCheckpoint;\\n        OracleVersion orderOracleVersion;\\n    }\\n\\n    struct UpdateContext {\\n        bool operator;\\n        bool signer;\\n        address liquidator;\\n        address orderReferrer;\\n        UFixed6 orderReferralFee;\\n        address guaranteeReferrer;\\n        UFixed6 guaranteeReferralFee;\\n        Order orderGlobal;\\n        Order orderLocal;\\n        Position currentPositionGlobal;\\n        Position currentPositionLocal;\\n        Guarantee guaranteeGlobal;\\n        Guarantee guaranteeLocal;\\n        UFixed6 collateralization;\\n    }\\n\\n    event Updated(address indexed sender, address indexed account, uint256 version, UFixed6 newMaker, UFixed6 newLong, UFixed6 newShort, Fixed6 collateral, bool protect, address referrer);\\n    event OrderCreated(address indexed account, Order order, Guarantee guarantee, address liquidator, address orderReferrer, address guaranteeReferrer);\\n    event PositionProcessed(uint256 orderId, Order order, VersionAccumulationResult accumulationResult);\\n    event AccountPositionProcessed(address indexed account, uint256 orderId, Order order, CheckpointAccumulationResult accumulationResult);\\n    event BeneficiaryUpdated(address newBeneficiary);\\n    event CoordinatorUpdated(address newCoordinator);\\n    /// @notice Fee earned by an account was transferred from market to a receiver\\n    /// @param account User who earned the fee\\n    /// @param receiver Delegated operator of the account, or the account itself\\n    /// @param amount Collateral transferred from market to receiver\\n    event FeeClaimed(address indexed account, address indexed receiver, UFixed6 amount);\\n    event ExposureClaimed(address indexed account, Fixed6 amount);\\n    event ParameterUpdated(MarketParameter newParameter);\\n    event RiskParameterUpdated(RiskParameter newRiskParameter);\\n\\n    // sig: 0x0fe90964\\n    error MarketInsufficientLiquidityError();\\n    // sig: 0x00e2b6a8\\n    error MarketInsufficientMarginError();\\n    // sig: 0x442145e5\\n    error MarketInsufficientCollateralError();\\n    // sig: 0xba555da7\\n    error MarketProtectedError();\\n    // sig: 0x6ed43d8e\\n    error MarketMakerOverLimitError();\\n    // sig: 0x29ab4c44\\n    error MarketClosedError();\\n    // sig: 0x07732aee\\n    error MarketCollateralBelowLimitError();\\n    // sig: 0x5bdace60\\n    error MarketOperatorNotAllowedError();\\n    // sig: 0x8a68c1dc\\n    error MarketNotSingleSidedError();\\n    // sig: 0x736f9fda\\n    error MarketOverCloseError();\\n    // sig: 0x935bdc21\\n    error MarketExceedsPendingIdLimitError();\\n    // sig: 0x9bca0625\\n    error MarketNotCoordinatorError();\\n    // sig: 0xb602d086\\n    error MarketNotBeneficiaryError();\\n    // sig: 0x3222db45\\n    /// @custom:error Sender is not authorized to interact with markets on behalf of the account\\n    error MarketNotOperatorError();\\n    // sig: 0x534f7fe6\\n    error MarketInvalidProtectionError();\\n    // sig: 0xab1e3a00\\n    error MarketStalePriceError();\\n    // sig: 0x15f9ae70\\n    error MarketEfficiencyUnderLimitError();\\n    // sig: 0x7302d51a\\n    error MarketInvalidMarketParameterError(uint256 code);\\n    // sig: 0xc5f0e98a\\n    error MarketInvalidRiskParameterError(uint256 code);\\n    // sig: 0x9dbdc5fd\\n    error MarketInvalidReferrerError();\\n    // sig: 0x5c5cb438\\n    error MarketSettleOnlyError();\\n    // sig: 0x1e9d2296\\n    error MarketInvalidIntentFeeError();\\n\\n    // sig: 0x2142bc27\\n    error GlobalStorageInvalidError();\\n    // sig: 0xc83d08ec\\n    error LocalStorageInvalidError();\\n    // sig: 0x7c53e926\\n    error MarketParameterStorageInvalidError();\\n    // sig: 0x98eb4898\\n    error PositionStorageLocalInvalidError();\\n    // sig: 0x7ecd083f\\n    error RiskParameterStorageInvalidError();\\n    // sig: 0xd2777e72\\n    error VersionStorageInvalidError();\\n\\n    function initialize(MarketDefinition calldata definition_) external;\\n    function migrate() external;\\n    function token() external view returns (Token18);\\n    function oracle() external view returns (IOracleProvider);\\n    function beneficiary() external view returns (address);\\n    function coordinator() external view returns (address);\\n    function positions(address account) external view returns (Position memory);\\n    function pendingOrders(address account, uint256 id) external view returns (Order memory);\\n    function guarantees(address account, uint256 id) external view returns (Guarantee memory);\\n    function pendings(address account) external view returns (Order memory);\\n    function locals(address account) external view returns (Local memory);\\n    function versions(uint256 timestamp) external view returns (Version memory);\\n    function position() external view returns (Position memory);\\n    function pendingOrder(uint256 id) external view returns (Order memory);\\n    function guarantee(uint256 id) external view returns (Guarantee memory);\\n    function pending() external view returns (Order memory);\\n    function global() external view returns (Global memory);\\n    function checkpoints(address account, uint256 version) external view returns (Checkpoint memory);\\n    function liquidators(address account, uint256 id) external view returns (address);\\n    function orderReferrers(address account, uint256 id) external view returns (address);\\n    function guaranteeReferrers(address account, uint256 id) external view returns (address);\\n    function settle(address account) external;\\n    function update(address account, Intent calldata intent, bytes memory signature) external;\\n    function update(address account, Fixed6 amount, Fixed6 collateral, address referrer) external;\\n    function update(address account, UFixed6 newMaker, UFixed6 newLong, UFixed6 newShort, Fixed6 collateral, bool protect) external;\\n    function update(address account, UFixed6 newMaker, UFixed6 newLong, UFixed6 newShort, Fixed6 collateral, bool protect, address referrer) external;\\n    function parameter() external view returns (MarketParameter memory);\\n    function riskParameter() external view returns (RiskParameter memory);\\n    function updateBeneficiary(address newBeneficiary) external;\\n    function updateCoordinator(address newCoordinator) external;\\n    function updateParameter(MarketParameter memory newParameter) external;\\n    function updateRiskParameter(RiskParameter memory newRiskParameter) external;\\n    function claimFee(address account) external returns (UFixed6);\\n}\\n\",\"keccak256\":\"0x5026f1a049b0f85e82c98fee8fbcb6b37662852f89e7c375068ee3557a73217d\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2/contracts/interfaces/IMarketFactory.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@equilibria/root/attribute/interfaces/IFactory.sol\\\";\\nimport \\\"@equilibria/perennial-v2-verifier/contracts/interfaces/IVerifier.sol\\\";\\nimport \\\"@equilibria/perennial-v2-verifier/contracts/types/OperatorUpdate.sol\\\";\\nimport \\\"@equilibria/perennial-v2-verifier/contracts/types/SignerUpdate.sol\\\";\\nimport \\\"@equilibria/perennial-v2-verifier/contracts/types/AccessUpdate.sol\\\";\\nimport \\\"@equilibria/perennial-v2-verifier/contracts/types/AccessUpdateBatch.sol\\\";\\nimport \\\"../types/ProtocolParameter.sol\\\";\\nimport \\\"./IMarket.sol\\\";\\n\\ninterface IMarketFactory is IFactory {\\n    event ParameterUpdated(ProtocolParameter newParameter);\\n    event ExtensionUpdated(address indexed operator, bool newEnabled);\\n    event OperatorUpdated(address indexed account, address indexed operator, bool newEnabled);\\n    event SignerUpdated(address indexed account, address indexed signer, bool newEnabled);\\n    event ReferralFeeUpdated(address indexed referrer, UFixed6 newFee);\\n    event MarketCreated(IMarket indexed market, IMarket.MarketDefinition definition);\\n\\n    // sig: 0x0a37dc74\\n    error FactoryInvalidPayoffError();\\n    // sig: 0x5116bce5\\n    error FactoryInvalidOracleError();\\n    // sig: 0x213e2260\\n    error FactoryAlreadyRegisteredError();\\n    // sig: 0x6928a80f\\n    error MarketFactoryInvalidSignerError();\\n    // sig: 0x199d4b3e\\n    error MarketFactoryInvalidReferralFeeError();\\n\\n    // sig: 0x4dc1bc59\\n    error ProtocolParameterStorageInvalidError();\\n\\n    function oracleFactory() external view returns (IFactory);\\n    function verifier() external view returns (IVerifier);\\n    function parameter() external view returns (ProtocolParameter memory);\\n    function extensions(address extension) external view returns (bool);\\n    function operators(address account, address operator) external view returns (bool);\\n    function signers(address signer, address operator) external view returns (bool);\\n    function referralFees(address referrer) external view returns (UFixed6);\\n    function markets(IOracleProvider oracle) external view returns (IMarket);\\n    function authorization(address account, address sender, address signer, address orderReferrer) external view returns (bool, bool, UFixed6);\\n    function initialize() external;\\n    function updateParameter(ProtocolParameter memory newParameter) external;\\n    function updateExtension(address extension, bool newEnabled) external;\\n    function updateOperator(address operator, bool newEnabled) external;\\n    function updateOperatorWithSignature(OperatorUpdate calldata operatorUpdate, bytes calldata signature) external;\\n    function updateSigner(address signer, bool newEnabled) external;\\n    function updateSignerWithSignature(SignerUpdate calldata signerUpdate, bytes calldata signature) external;\\n    function updateAccessBatch(AccessUpdate[] calldata operators, AccessUpdate[] calldata signers) external;\\n    function updateAccessBatchWithSignature(AccessUpdateBatch calldata accessUpdateBatch, bytes calldata signature) external;\\n    function updateReferralFee(address referrer, UFixed6 newReferralFee) external;\\n    function create(IMarket.MarketDefinition calldata definition) external returns (IMarket);\\n}\\n\",\"keccak256\":\"0xb2b514ce551865922420e91774db362710cf6b5dd7f01a082104ebb27751c662\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2/contracts/interfaces/IOracleProvider.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport { OracleReceipt } from \\\"../types/OracleReceipt.sol\\\";\\nimport { OracleVersion } from \\\"../types/OracleVersion.sol\\\";\\nimport { IMarket } from \\\"./IMarket.sol\\\";\\n\\n/// @dev OracleVersion Invariants\\n///       - Version are requested at a timestamp, the current timestamp is determined by the oracle\\n///         - The current timestamp may not be equal to block.timestamp, for example when batching timestamps\\n///       - Versions are allowed to \\\"fail\\\" and will be marked as .valid = false\\n///         - Invalid versions will always include the latest valid price as its price field\\n///       - Versions must be committed in order, i.e. all requested versions prior to latestVersion must be available\\n///       - Non-requested versions may be committed, but will not receive a settlement fee\\n///         - This is useful for immediately liquidating an account with a valid off-chain price in between orders\\n///         - Satisfying the above constraints, only versions more recent than the latest version may be committed\\n///       - Current must always be greater than Latest, never equal\\ninterface IOracleProvider {\\n    // sig: 0x652fafab\\n    error OracleProviderUnauthorizedError();\\n\\n    event OracleProviderVersionRequested(uint256 indexed version, bool newPrice);\\n    event OracleProviderVersionFulfilled(OracleVersion version);\\n\\n    function request(IMarket market, address account) external;\\n    function status() external view returns (OracleVersion memory, uint256);\\n    function latest() external view returns (OracleVersion memory);\\n    function current() external view returns (uint256);\\n    function at(uint256 timestamp) external view returns (OracleVersion memory, OracleReceipt memory);\\n}\",\"keccak256\":\"0xf5f11c678eb5bc91447ef0d919e2dd9dfa266985cd58597e3ee87fe3fca335c9\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2/contracts/libs/CheckpointLib.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@equilibria/root/accumulator/types/Accumulator6.sol\\\";\\nimport \\\"../interfaces/IMarket.sol\\\";\\nimport \\\"../types/OracleVersion.sol\\\";\\nimport \\\"../types/RiskParameter.sol\\\";\\nimport \\\"../types/Global.sol\\\";\\nimport \\\"../types/Local.sol\\\";\\nimport \\\"../types/Order.sol\\\";\\nimport \\\"../types/Version.sol\\\";\\nimport \\\"../types/Checkpoint.sol\\\";\\nimport \\\"../types/Guarantee.sol\\\";\\n\\n\\nstruct CheckpointAccumulationResponse {\\n    /// @dev Total Collateral change due to collateral, price override, and trade fee and offset\\n    Fixed6 collateral;\\n\\n    /// @dev Liquidation fee accumulated for this checkpoint (only if the order is protected)\\n    UFixed6 liquidationFee;\\n\\n    /// @dev Subtractive fee accumulated from the previous position to the next position (this amount is included in the linear fee)\\n    UFixed6 subtractiveFee;\\n\\n    /// @dev Solver fee accumulated the previous position to the next position (this amount is included in the linear fee)\\n    UFixed6 solverFee;\\n}\\n\\nstruct CheckpointAccumulationResult {\\n    /// @dev Total Collateral change due to pnl, funding, and interest from the previous position to the next position\\n    Fixed6 collateral;\\n\\n    /// @dev Collateral change from the difference between the price override and underlying market price\\n    Fixed6 priceOverride;\\n\\n    /// @dev Trade fee accumulated for this checkpoint\\n    UFixed6 tradeFee;\\n\\n    /// @dev Trade price impact accumulated for this checkpoint\\n    Fixed6 offset;\\n\\n    /// @dev Settlement fee charged for this checkpoint\\n    UFixed6 settlementFee;\\n\\n    /// @dev Liquidation fee accumulated for this checkpoint (only if the order is protected)\\n    UFixed6 liquidationFee;\\n\\n    /// @dev Subtractive fee accumulated from the previous position to the next position (this amount is included in the linear fee)\\n    UFixed6 subtractiveFee;\\n\\n    /// @dev Solver fee accumulated the previous position to the next position (this amount is included in the linear fee)\\n    UFixed6 solverFee;\\n}\\n\\n/// @title CheckpointLib\\n/// @dev (external-safe): this library is safe to externalize\\n/// @notice Manages the logic for the local order accumulation\\nlibrary CheckpointLib {\\n    /// @notice Accumulate pnl and fees from the latest position to next position\\n    /// @param order The next order\\n    /// @param fromVersion The previous latest version\\n    /// @param toVersion The next latest version\\n    /// @return next The next checkpoint\\n    /// @return response The accumulated pnl and fees\\n    function accumulate(\\n        IMarket.Context memory context,\\n        IMarket.SettlementContext memory settlementContext,\\n        uint256 orderId,\\n        Order memory order,\\n        Guarantee memory guarantee,\\n        Version memory fromVersion,\\n        Version memory toVersion\\n    ) external returns (Checkpoint memory next, CheckpointAccumulationResponse memory) {\\n        CheckpointAccumulationResult memory result;\\n\\n        // accumulate\\n        result.collateral = _accumulateCollateral(context.latestPositionLocal, fromVersion, toVersion);\\n        result.priceOverride = _accumulatePriceOverride(guarantee, toVersion);\\n        (result.tradeFee, result.subtractiveFee, result.solverFee) = _accumulateFee(order, guarantee, toVersion);\\n        result.offset = _accumulateOffset(order, guarantee, toVersion);\\n        result.settlementFee = _accumulateSettlementFee(order, guarantee, toVersion);\\n        result.liquidationFee = _accumulateLiquidationFee(order, toVersion);\\n\\n        // update checkpoint\\n        next.collateral = settlementContext.latestCheckpoint.collateral\\n            .sub(settlementContext.latestCheckpoint.tradeFee)                       // trade fee processed post settlement\\n            .sub(Fixed6Lib.from(settlementContext.latestCheckpoint.settlementFee)); // settlement / liquidation fee processed post settlement\\n        next.collateral = next.collateral\\n            .add(settlementContext.latestCheckpoint.transfer)                       // deposit / withdrawal processed post settlement\\n            .add(result.collateral)                                                 // incorporate collateral change at this settlement\\n            .add(result.priceOverride);                                             // incorporate price override pnl at this settlement\\n        next.transfer = order.collateral;\\n        next.tradeFee = Fixed6Lib.from(result.tradeFee).add(result.offset);\\n        next.settlementFee = result.settlementFee.add(result.liquidationFee);\\n\\n        emit IMarket.AccountPositionProcessed(context.account, orderId, order, result);\\n\\n        return (next, _response(result));\\n    }\\n\\n    /// @notice Converts the accumulation result into a response\\n    /// @param result The accumulation result\\n    /// @return response The accumulation response\\n    function _response(\\n        CheckpointAccumulationResult memory result\\n    ) private pure returns (CheckpointAccumulationResponse memory response) {\\n        response.collateral = result.collateral\\n            .add(result.priceOverride)\\n            .sub(Fixed6Lib.from(result.tradeFee))\\n            .sub(result.offset)\\n            .sub(Fixed6Lib.from(result.settlementFee));\\n        response.liquidationFee = result.liquidationFee;\\n        response.subtractiveFee = result.subtractiveFee;\\n        response.solverFee = result.solverFee;\\n    }\\n\\n    /// @notice Accumulate pnl, funding, and interest from the latest position to next position\\n    /// @param fromPosition The previous latest position\\n    /// @param fromVersion The previous latest version\\n    /// @param toVersion The next version\\n    function _accumulateCollateral(\\n        Position memory fromPosition,\\n        Version memory fromVersion,\\n        Version memory toVersion\\n    ) private pure returns (Fixed6) {\\n        return toVersion.makerValue.accumulated(fromVersion.makerValue, fromPosition.maker)\\n            .add(toVersion.longValue.accumulated(fromVersion.longValue, fromPosition.long))\\n            .add(toVersion.shortValue.accumulated(fromVersion.shortValue, fromPosition.short));\\n    }\\n\\n    /// @notice Accumulate trade fees for the next position\\n    /// @param order The next order\\n    /// @param guarantee The next guarantee\\n    /// @param toVersion The next version\\n    function _accumulateFee(\\n        Order memory order,\\n        Guarantee memory guarantee,\\n        Version memory toVersion\\n    ) private pure returns (UFixed6 tradeFee, UFixed6 subtractiveFee, UFixed6 solverFee) {\\n        UFixed6 takerTotal = order.takerTotal().sub(guarantee.takerFee);\\n\\n        // accumulate total trade fees on maker and taker orders\\n        UFixed6 makerFee = Fixed6Lib.ZERO\\n            .sub(toVersion.makerFee.accumulated(Accumulator6(Fixed6Lib.ZERO), order.makerTotal()))\\n            .abs();\\n        UFixed6 takerFee = Fixed6Lib.ZERO\\n            .sub(toVersion.takerFee.accumulated(Accumulator6(Fixed6Lib.ZERO), takerTotal))\\n            .abs();\\n\\n        // compute portion of trade fees that are subtractive\\n        UFixed6 makerSubtractiveFee = order.makerTotal().isZero() ?\\n            UFixed6Lib.ZERO :\\n            makerFee.muldiv(order.makerReferral, order.makerTotal());\\n        UFixed6 takerSubtractiveFee = takerTotal.isZero() ?\\n            UFixed6Lib.ZERO :\\n            takerFee.muldiv(order.takerReferral, takerTotal);\\n\\n        // compute portion of subtractive fees that are solver fees\\n        solverFee = takerTotal.isZero() ?\\n            UFixed6Lib.ZERO :\\n            takerFee.muldiv(guarantee.referral, takerTotal); // guarantee.referral is instantiated as a subset of order.takerReferral\\n\\n        tradeFee = makerFee.add(takerFee);\\n        subtractiveFee = makerSubtractiveFee.add(takerSubtractiveFee).sub(solverFee);\\n\\n    }\\n\\n    /// @notice Accumulate price offset for the next position\\n    /// @dev This includes adjustment for linear, proportional, and adiabatic order fees\\n    /// @param order The next order\\n    /// @param guarantee The next guarantee\\n    /// @param toVersion The next version\\n    function _accumulateOffset(\\n        Order memory order,\\n        Guarantee memory guarantee,\\n        Version memory toVersion\\n    ) private pure returns (Fixed6) {\\n        (UFixed6 takerPos, UFixed6 takerNeg) =\\n            (order.takerPos().sub(guarantee.takerPos), order.takerNeg().sub(guarantee.takerNeg));\\n\\n        return Fixed6Lib.ZERO\\n            .sub(toVersion.makerOffset.accumulated(Accumulator6(Fixed6Lib.ZERO), order.makerTotal()))\\n            .sub(toVersion.takerPosOffset.accumulated(Accumulator6(Fixed6Lib.ZERO), takerPos))\\n            .sub(toVersion.takerNegOffset.accumulated(Accumulator6(Fixed6Lib.ZERO), takerNeg));\\n    }\\n\\n\\n    /// @notice Accumulate settlement fees for the next position\\n    /// @param order The next order\\n    /// @param guarantee The next guarantee\\n    /// @param toVersion The next version\\n    function _accumulateSettlementFee(\\n        Order memory order,\\n        Guarantee memory guarantee,\\n        Version memory toVersion\\n    ) private pure returns (UFixed6) {\\n        uint256 orders = order.orders - guarantee.orders;\\n\\n        return toVersion.settlementFee.accumulated(Accumulator6(Fixed6Lib.ZERO), UFixed6Lib.from(orders)).abs();\\n    }\\n\\n    /// @notice Accumulate liquidation fees for the next position\\n    /// @param order The next order\\n    /// @param toVersion The next version\\n    function _accumulateLiquidationFee(\\n        Order memory order,\\n        Version memory toVersion\\n    ) private pure returns (UFixed6) {\\n        if (!order.protected()) return UFixed6Lib.ZERO;\\n        return toVersion.liquidationFee.accumulated(Accumulator6(Fixed6Lib.ZERO), UFixed6Lib.ONE).abs();\\n    }\\n\\n    /// @notice Accumulate price override pnl for the next position\\n    /// @param guarantee The next guarantee\\n    /// @param toVersion The next version\\n    function _accumulatePriceOverride(\\n        Guarantee memory guarantee,\\n        Version memory toVersion\\n    ) private pure returns (Fixed6) {\\n        if (!toVersion.valid) return Fixed6Lib.ZERO;\\n        return guarantee.taker().mul(toVersion.price).sub(guarantee.notional);\\n    }\\n}\\n\",\"keccak256\":\"0x3cee07e0b8282584ec46d0f2ecc4cf5487195186dff7f8dcebfa07bfe33447f4\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2/contracts/libs/VersionLib.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@equilibria/root/accumulator/types/Accumulator6.sol\\\";\\nimport \\\"@equilibria/root/accumulator/types/UAccumulator6.sol\\\";\\nimport \\\"../interfaces/IMarket.sol\\\";\\nimport \\\"../types/ProtocolParameter.sol\\\";\\nimport \\\"../types/MarketParameter.sol\\\";\\nimport \\\"../types/RiskParameter.sol\\\";\\nimport \\\"../types/Global.sol\\\";\\nimport \\\"../types/Position.sol\\\";\\nimport \\\"../types/Version.sol\\\";\\nimport \\\"../types/OracleVersion.sol\\\";\\nimport \\\"../types/OracleReceipt.sol\\\";\\n\\n/// @dev The response of the version accumulation\\n///      Contains only select fee information needed for the downstream market contract\\n///      Returned by the accumulate function\\nstruct VersionAccumulationResponse {\\n    /// @dev The total market fee charged including (tradeFee, tradeOffsetMarket, fundingFee, interestFee)\\n    UFixed6 marketFee;\\n\\n    /// @dev The settlement fee charged\\n    UFixed6 settlementFee;\\n\\n    /// @dev The market's adiabatic exposure\\n    Fixed6 marketExposure;\\n}\\n\\n/// @dev The result of the version accumulation\\n///      Contains all the accumulated values for the version\\n///      Emitted via the PositionProcessed event\\nstruct VersionAccumulationResult {\\n    /// @dev The trade fee charged\\n    UFixed6 tradeFee;\\n\\n    /// @dev The subtractive fee charged\\n    UFixed6 subtractiveFee;\\n\\n    /// @dev The total price impact of the trade (including linear, proportional, and adiabatic)\\n    Fixed6 tradeOffset;\\n\\n    /// @dev The portion of the trade offset that the makers receive\\n    Fixed6 tradeOffsetMaker;\\n\\n    /// @dev The portion of the trade offset that the market receives (if there are no makers)\\n    UFixed6 tradeOffsetMarket;\\n\\n    /// @dev The adiabatic exposure accrued\\n    Fixed6 adiabaticExposure;\\n\\n    /// @dev The adiabatic exposure accrued by makers\\n    Fixed6 adiabaticExposureMaker;\\n\\n    /// @dev The adiabatic exposure accrued by the market\\n    Fixed6 adiabaticExposureMarket;\\n\\n    /// @dev Funding accrued by makers\\n    Fixed6 fundingMaker;\\n\\n    /// @dev Funding accrued by longs\\n    Fixed6 fundingLong;\\n\\n    /// @dev Funding accrued by shorts\\n    Fixed6 fundingShort;\\n\\n    /// @dev Funding received by the protocol\\n    UFixed6 fundingFee;\\n\\n    /// @dev Interest accrued by makers\\n    Fixed6 interestMaker;\\n\\n    /// @dev Interest accrued by longs\\n    Fixed6 interestLong;\\n\\n    /// @dev Interest accrued by shorts\\n    Fixed6 interestShort;\\n\\n    /// @dev Interest received by the protocol\\n    UFixed6 interestFee;\\n\\n    /// @dev Price-based profit/loss accrued by makers\\n    Fixed6 pnlMaker;\\n\\n    /// @dev Price-based profit/loss accrued by longs\\n    Fixed6 pnlLong;\\n\\n    /// @dev Price-based profit/loss accrued by shorts\\n    Fixed6 pnlShort;\\n\\n    /// @dev Total settlement fee charged\\n    UFixed6 settlementFee;\\n\\n    /// @dev Snapshot of the riskParameter.liquidationFee at the version (0 if not valid)\\n    UFixed6 liquidationFee;\\n}\\n\\n/// @dev The in-memory context for the version accumulation\\nstruct VersionAccumulationContext {\\n    Global global;\\n    Position fromPosition;\\n    uint256 orderId;\\n    Order order;\\n    Guarantee guarantee;\\n    OracleVersion fromOracleVersion;\\n    OracleVersion toOracleVersion;\\n    OracleReceipt toOracleReceipt;\\n    MarketParameter marketParameter;\\n    RiskParameter riskParameter;\\n}\\n\\n/// @title VersionLib\\n/// @dev (external-safe): this library is safe to externalize\\n/// @notice Manages the logic for the global order accumulation\\nlibrary VersionLib {\\n    /// @notice Accumulates the global state for the period from `fromVersion` to `toOracleVersion`\\n    function accumulate(\\n        IMarket.Context memory context,\\n        IMarket.SettlementContext memory settlementContext,\\n        uint256 newOrderId,\\n        Order memory newOrder,\\n        Guarantee memory newGuarantee,\\n        OracleVersion memory oracleVersion,\\n        OracleReceipt memory oracleReceipt\\n    ) external returns (Version memory next, Global memory nextGlobal, VersionAccumulationResponse memory response) {\\n        VersionAccumulationContext memory accumulationContext = VersionAccumulationContext(\\n            context.global,\\n            context.latestPositionGlobal,\\n            newOrderId,\\n            newOrder,\\n            newGuarantee,\\n            settlementContext.orderOracleVersion,\\n            oracleVersion,\\n            oracleReceipt,\\n            context.marketParameter,\\n            context.riskParameter\\n        );\\n\\n        return _accumulate(settlementContext.latestVersion, accumulationContext);\\n    }\\n\\n    /// @notice Accumulates the global state for the period from `fromVersion` to `toOracleVersion`\\n    /// @param self The Version object to update\\n    /// @param context The accumulation context\\n    /// @return next The accumulated version\\n    /// @return nextGlobal The next global state\\n    /// @return response The accumulation response\\n    function _accumulate(\\n        Version memory self,\\n        VersionAccumulationContext memory context\\n    ) private returns (Version memory next, Global memory nextGlobal, VersionAccumulationResponse memory response) {\\n        VersionAccumulationResult memory result;\\n\\n        // setup next accumulators\\n        _next(self, next);\\n\\n        // record oracle version\\n        (next.valid, next.price) = (context.toOracleVersion.valid, context.toOracleVersion.price);\\n        context.global.latestPrice = context.toOracleVersion.price;\\n\\n        // accumulate settlement fee\\n        result.settlementFee = _accumulateSettlementFee(next, context);\\n\\n        // accumulate liquidation fee\\n        result.liquidationFee = _accumulateLiquidationFee(next, context);\\n\\n        // accumulate fee\\n        _accumulateFee(next, context, result);\\n\\n        // accumulate linear fee\\n        _accumulateLinearFee(next, context, result);\\n\\n        // accumulate proportional fee\\n        _accumulateProportionalFee(next, context, result);\\n\\n        // accumulate adiabatic exposure\\n        _accumulateAdiabaticExposure(next, context, result);\\n\\n        // accumulate adiabatic fee\\n        _accumulateAdiabaticFee(next, context, result);\\n\\n        // if closed, don't accrue anything else\\n        if (context.marketParameter.closed) return _return(context, result, next);\\n\\n        // accumulate funding\\n        (result.fundingMaker, result.fundingLong, result.fundingShort, result.fundingFee) =\\n            _accumulateFunding(next, context);\\n\\n        // accumulate interest\\n        (result.interestMaker, result.interestLong, result.interestShort, result.interestFee) =\\n            _accumulateInterest(next, context);\\n\\n        // accumulate P&L\\n        (result.pnlMaker, result.pnlLong, result.pnlShort) = _accumulatePNL(next, context);\\n\\n        return _return(context, result, next);\\n    }\\n\\n    function _return(\\n        VersionAccumulationContext memory context,\\n        VersionAccumulationResult memory result,\\n        Version memory next\\n    ) private returns (Version memory, Global memory, VersionAccumulationResponse memory) {\\n        emit IMarket.PositionProcessed(context.orderId, context.order, result);\\n\\n        return (next, context.global, _response(result));\\n    }\\n\\n    /// @notice Converts the accumulation result into a response\\n    /// @param result The accumulation result\\n    /// @return response The accumulation response\\n    function _response(\\n        VersionAccumulationResult memory result\\n    ) private pure returns (VersionAccumulationResponse memory response) {\\n        response.marketFee = result.tradeFee\\n            .add(result.tradeOffsetMarket)\\n            .add(result.fundingFee)\\n            .add(result.interestFee);\\n        response.settlementFee = result.settlementFee;\\n        response.marketExposure = result.adiabaticExposureMarket;\\n    }\\n\\n    /// @notice Copies over the version-over-version accumulators to prepare the next version\\n    /// @param self The Version object to update\\n    function _next(Version memory self, Version memory next) internal pure {\\n        next.makerValue._value = self.makerValue._value;\\n        next.longValue._value = self.longValue._value;\\n        next.shortValue._value = self.shortValue._value;\\n    }\\n\\n    /// @notice Globally accumulates settlement fees since last oracle update\\n    /// @param next The Version object to update\\n    /// @param context The accumulation context\\n    function _accumulateSettlementFee(\\n        Version memory next,\\n        VersionAccumulationContext memory context\\n    ) private pure returns (UFixed6 settlementFee) {\\n        uint256 orders = context.order.orders - context.guarantee.orders;\\n        settlementFee = orders == 0 ? UFixed6Lib.ZERO : context.toOracleReceipt.settlementFee;\\n        next.settlementFee.decrement(Fixed6Lib.from(settlementFee), UFixed6Lib.from(orders));\\n    }\\n\\n    /// @notice Globally accumulates hypothetical liquidation fee since last oracle update\\n    /// @param next The Version object to update\\n    /// @param context The accumulation context\\n    function _accumulateLiquidationFee(\\n        Version memory next,\\n        VersionAccumulationContext memory context\\n    ) private pure returns (UFixed6 liquidationFee) {\\n        liquidationFee = context.toOracleVersion.valid ?\\n            context.toOracleReceipt.settlementFee.mul(context.riskParameter.liquidationFee) :\\n            UFixed6Lib.ZERO;\\n        next.liquidationFee.decrement(Fixed6Lib.from(liquidationFee), UFixed6Lib.ONE);\\n    }\\n\\n    /// @notice Globally accumulates linear fees since last oracle update\\n    /// @param next The Version object to update\\n    /// @param context The accumulation context\\n    function _accumulateFee(\\n        Version memory next,\\n        VersionAccumulationContext memory context,\\n        VersionAccumulationResult memory result\\n    ) private pure {\\n        UFixed6 makerFee = context.order.makerTotal()\\n            .mul(context.toOracleVersion.price.abs())\\n            .mul(context.marketParameter.makerFee);\\n        next.makerFee.decrement(Fixed6Lib.from(makerFee), context.order.makerTotal());\\n        UFixed6 makerSubtractiveFee = context.order.makerTotal().isZero() ?\\n            UFixed6Lib.ZERO :\\n            makerFee.muldiv(context.order.makerReferral, context.order.makerTotal());\\n\\n        UFixed6 takerTotal = context.order.takerTotal().sub(context.guarantee.takerFee);\\n        UFixed6 takerFee = takerTotal\\n            .mul(context.toOracleVersion.price.abs())\\n            .mul(context.marketParameter.takerFee);\\n        next.takerFee.decrement(Fixed6Lib.from(takerFee), takerTotal);\\n        UFixed6 takerSubtractiveFee = takerTotal.isZero() ?\\n            UFixed6Lib.ZERO :\\n            takerFee.muldiv(context.order.takerReferral, takerTotal);\\n\\n        result.tradeFee = result.tradeFee.add(makerFee).add(takerFee).sub(makerSubtractiveFee).sub(takerSubtractiveFee);\\n        result.subtractiveFee = result.subtractiveFee.add(makerSubtractiveFee).add(takerSubtractiveFee);\\n    }\\n\\n    /// @notice Globally accumulates linear fees since last oracle update\\n    /// @param next The Version object to update\\n    /// @param context The accumulation context\\n    function _accumulateLinearFee(\\n        Version memory next,\\n        VersionAccumulationContext memory context,\\n        VersionAccumulationResult memory result\\n    ) private pure {\\n        UFixed6 makerLinearFee = context.riskParameter.makerFee.linear(\\n            Fixed6Lib.from(context.order.makerTotal()),\\n            context.toOracleVersion.price.abs()\\n        );\\n        next.makerOffset.decrement(Fixed6Lib.from(makerLinearFee), context.order.makerTotal());\\n\\n        UFixed6 takerPosTotal = context.order.takerPos().sub(context.guarantee.takerPos);\\n        UFixed6 takerPosLinearFee = context.riskParameter.takerFee.linear(\\n            Fixed6Lib.from(takerPosTotal),\\n            context.toOracleVersion.price.abs()\\n        );\\n        next.takerPosOffset.decrement(Fixed6Lib.from(takerPosLinearFee), takerPosTotal);\\n\\n        UFixed6 takerNegTotal = context.order.takerNeg().sub(context.guarantee.takerNeg);\\n        UFixed6 takerNegLinearFee = context.riskParameter.takerFee.linear(\\n            Fixed6Lib.from(takerNegTotal),\\n            context.toOracleVersion.price.abs()\\n        );\\n        next.takerNegOffset.decrement(Fixed6Lib.from(takerNegLinearFee), takerNegTotal);\\n\\n        UFixed6 linearFee = makerLinearFee.add(takerPosLinearFee).add(takerNegLinearFee);\\n        UFixed6 marketFee = context.fromPosition.maker.isZero() ? linearFee : UFixed6Lib.ZERO;\\n        UFixed6 makerFee = linearFee.sub(marketFee);\\n        next.makerValue.increment(Fixed6Lib.from(makerFee), context.fromPosition.maker);\\n\\n        result.tradeOffset = result.tradeOffset.add(Fixed6Lib.from(linearFee));\\n        result.tradeOffsetMaker = result.tradeOffsetMaker.add(Fixed6Lib.from(makerFee));\\n        result.tradeOffsetMarket = result.tradeOffsetMarket.add(marketFee);\\n    }\\n\\n    /// @notice Globally accumulates proportional fees since last oracle update\\n    /// @param next The Version object to update\\n    /// @param context The accumulation context\\n    function _accumulateProportionalFee(\\n        Version memory next,\\n        VersionAccumulationContext memory context,\\n        VersionAccumulationResult memory result\\n    ) private pure {\\n        UFixed6 makerProportionalFee = context.riskParameter.makerFee.proportional(\\n            Fixed6Lib.from(context.order.makerTotal()),\\n            context.toOracleVersion.price.abs()\\n        );\\n        next.makerOffset.decrement(Fixed6Lib.from(makerProportionalFee), context.order.makerTotal());\\n\\n        UFixed6 takerPos = context.order.takerPos().sub(context.guarantee.takerPos);\\n        UFixed6 takerPosProportionalFee = context.riskParameter.takerFee.proportional(\\n            Fixed6Lib.from(takerPos),\\n            context.toOracleVersion.price.abs()\\n        );\\n        next.takerPosOffset.decrement(Fixed6Lib.from(takerPosProportionalFee), takerPos);\\n\\n        UFixed6 takerNeg = context.order.takerNeg().sub(context.guarantee.takerNeg);\\n        UFixed6 takerNegProportionalFee = context.riskParameter.takerFee.proportional(\\n            Fixed6Lib.from(takerNeg),\\n            context.toOracleVersion.price.abs()\\n        );\\n        next.takerNegOffset.decrement(Fixed6Lib.from(takerNegProportionalFee), takerNeg);\\n\\n        UFixed6 proportionalFee = makerProportionalFee.add(takerPosProportionalFee).add(takerNegProportionalFee);\\n        UFixed6 marketFee = context.fromPosition.maker.isZero() ? proportionalFee : UFixed6Lib.ZERO;\\n        UFixed6 makerFee = proportionalFee.sub(marketFee);\\n        next.makerValue.increment(Fixed6Lib.from(makerFee), context.fromPosition.maker);\\n\\n        result.tradeOffset = result.tradeOffset.add(Fixed6Lib.from(proportionalFee));\\n        result.tradeOffsetMaker = result.tradeOffsetMaker.add(Fixed6Lib.from(makerFee));\\n        result.tradeOffsetMarket = result.tradeOffsetMarket.add(marketFee);\\n    }\\n\\n    /// @notice Globally accumulates adiabatic fees since last oracle update\\n    /// @param next The Version object to update\\n    /// @param context The accumulation context\\n    function _accumulateAdiabaticFee(\\n        Version memory next,\\n        VersionAccumulationContext memory context,\\n        VersionAccumulationResult memory result\\n    ) private pure {\\n        Fixed6 adiabaticFee;\\n\\n        // position fee from positive skew taker orders\\n        UFixed6 takerPos = context.order.takerPos().sub(context.guarantee.takerPos);\\n        adiabaticFee = context.riskParameter.takerFee.adiabatic(\\n            context.fromPosition.skew(),\\n            Fixed6Lib.from(takerPos),\\n            context.toOracleVersion.price.abs()\\n        );\\n        next.takerPosOffset.decrement(adiabaticFee, takerPos);\\n        result.tradeOffset = result.tradeOffset.add(adiabaticFee);\\n\\n        // position fee from negative skew taker orders\\n        UFixed6 takerNeg = context.order.takerNeg().sub(context.guarantee.takerNeg);\\n        adiabaticFee = context.riskParameter.takerFee.adiabatic(\\n            context.fromPosition.skew().add(Fixed6Lib.from(takerPos)),\\n            Fixed6Lib.from(-1, takerNeg),\\n            context.toOracleVersion.price.abs()\\n        );\\n        next.takerNegOffset.decrement(adiabaticFee, takerNeg);\\n        result.tradeOffset = result.tradeOffset.add(adiabaticFee);\\n    }\\n\\n    /// @notice Globally accumulates single component of the position fees exposure since last oracle update\\n    /// @param next The Version object to update\\n    /// @param context The accumulation context\\n    /// @param result The accumulation result\\n    function _accumulateAdiabaticExposure(\\n        Version memory next,\\n        VersionAccumulationContext memory context,\\n        VersionAccumulationResult memory result\\n    ) private pure {\\n        Fixed6 exposure = context.riskParameter.takerFee.exposure(context.fromPosition.skew());\\n\\n        Fixed6 adiabaticExposure = context.toOracleVersion.price.sub(context.fromOracleVersion.price).mul(exposure);\\n        Fixed6 adiabaticExposureMaker = adiabaticExposure.mul(Fixed6Lib.NEG_ONE);\\n        Fixed6 adiabaticExposureMarket = context.fromPosition.maker.isZero() ? adiabaticExposureMaker : Fixed6Lib.ZERO;\\n        adiabaticExposureMaker = adiabaticExposureMaker.sub(adiabaticExposureMarket);\\n        next.makerValue.increment(adiabaticExposureMaker, context.fromPosition.maker);\\n\\n        result.adiabaticExposure = adiabaticExposure;\\n        result.adiabaticExposureMarket = adiabaticExposureMarket;\\n        result.adiabaticExposureMaker = adiabaticExposureMaker;\\n    }\\n\\n    /// @notice Globally accumulates all long-short funding since last oracle update\\n    /// @param next The Version object to update\\n    /// @param context The accumulation context\\n    /// @return fundingMaker The total funding accrued by makers\\n    /// @return fundingLong The total funding accrued by longs\\n    /// @return fundingShort The total funding accrued by shorts\\n    /// @return fundingFee The total fee accrued from funding accumulation\\n    function _accumulateFunding(Version memory next, VersionAccumulationContext memory context) private pure returns (\\n        Fixed6 fundingMaker,\\n        Fixed6 fundingLong,\\n        Fixed6 fundingShort,\\n        UFixed6 fundingFee\\n    ) {\\n        Fixed6 toSkew = context.toOracleVersion.valid ?\\n            context.fromPosition.skew().add(context.order.long()).sub(context.order.short()) :\\n            context.fromPosition.skew();\\n\\n        // Compute long-short funding rate\\n        Fixed6 funding = context.global.pAccumulator.accumulate(\\n            context.riskParameter.pController,\\n            toSkew.unsafeDiv(Fixed6Lib.from(context.riskParameter.takerFee.scale)).min(Fixed6Lib.ONE).max(Fixed6Lib.NEG_ONE),\\n            context.fromOracleVersion.timestamp,\\n            context.toOracleVersion.timestamp,\\n            context.fromPosition.takerSocialized().mul(context.fromOracleVersion.price.abs())\\n        );\\n\\n        // Handle maker receive-only status\\n        if (context.riskParameter.makerReceiveOnly && funding.sign() != context.fromPosition.skew().sign())\\n            funding = funding.mul(Fixed6Lib.NEG_ONE);\\n\\n        // Initialize long and short funding\\n        (fundingLong, fundingShort) = (Fixed6Lib.NEG_ONE.mul(funding), funding);\\n\\n        // Compute fee spread\\n        fundingFee = funding.abs().mul(context.marketParameter.fundingFee);\\n        Fixed6 fundingSpread = Fixed6Lib.from(fundingFee).div(Fixed6Lib.from(2));\\n\\n        // Adjust funding with spread\\n        (fundingLong, fundingShort) = (\\n            fundingLong.sub(Fixed6Lib.from(fundingFee)).add(fundingSpread),\\n            fundingShort.sub(fundingSpread)\\n        );\\n\\n        // Redirect net portion of minor's side to maker\\n        if (context.fromPosition.long.gt(context.fromPosition.short)) {\\n            fundingMaker = fundingShort.mul(Fixed6Lib.from(context.fromPosition.socializedMakerPortion()));\\n            fundingShort = fundingShort.sub(fundingMaker);\\n        }\\n        if (context.fromPosition.short.gt(context.fromPosition.long)) {\\n            fundingMaker = fundingLong.mul(Fixed6Lib.from(context.fromPosition.socializedMakerPortion()));\\n            fundingLong = fundingLong.sub(fundingMaker);\\n        }\\n\\n        next.makerValue.increment(fundingMaker, context.fromPosition.maker);\\n        next.longValue.increment(fundingLong, context.fromPosition.long);\\n        next.shortValue.increment(fundingShort, context.fromPosition.short);\\n    }\\n\\n    /// @notice Globally accumulates all maker interest since last oracle update\\n    /// @param next The Version object to update\\n    /// @param context The accumulation context\\n    /// @return interestMaker The total interest accrued by makers\\n    /// @return interestLong The total interest accrued by longs\\n    /// @return interestShort The total interest accrued by shorts\\n    /// @return interestFee The total fee accrued from interest accumulation\\n    function _accumulateInterest(\\n        Version memory next,\\n        VersionAccumulationContext memory context\\n    ) private pure returns (Fixed6 interestMaker, Fixed6 interestLong, Fixed6 interestShort, UFixed6 interestFee) {\\n        UFixed6 notional = context.fromPosition.long.add(context.fromPosition.short).min(context.fromPosition.maker).mul(context.fromOracleVersion.price.abs());\\n\\n        // Compute maker interest\\n        UFixed6 interest = context.riskParameter.utilizationCurve.accumulate(\\n            context.fromPosition.utilization(context.riskParameter),\\n            context.fromOracleVersion.timestamp,\\n            context.toOracleVersion.timestamp,\\n            notional\\n        );\\n\\n        // Compute fee\\n        interestFee = interest.mul(context.marketParameter.interestFee);\\n\\n        // Adjust long and short funding with spread\\n        interestLong = Fixed6Lib.from(\\n            context.fromPosition.major().isZero() ?\\n            interest :\\n            interest.muldiv(context.fromPosition.long, context.fromPosition.long.add(context.fromPosition.short))\\n        );\\n        interestShort = Fixed6Lib.from(interest).sub(interestLong);\\n        interestMaker = Fixed6Lib.from(interest.sub(interestFee));\\n\\n        interestLong = interestLong.mul(Fixed6Lib.NEG_ONE);\\n        interestShort = interestShort.mul(Fixed6Lib.NEG_ONE);\\n        next.makerValue.increment(interestMaker, context.fromPosition.maker);\\n        next.longValue.increment(interestLong, context.fromPosition.long);\\n        next.shortValue.increment(interestShort, context.fromPosition.short);\\n    }\\n\\n    /// @notice Globally accumulates position profit & loss since last oracle update\\n    /// @param next The Version object to update\\n    /// @param context The accumulation context\\n    /// @return pnlMaker The total pnl accrued by makers\\n    /// @return pnlLong The total pnl accrued by longs\\n    /// @return pnlShort The total pnl accrued by shorts\\n    function _accumulatePNL(\\n        Version memory next,\\n        VersionAccumulationContext memory context\\n    ) private pure returns (Fixed6 pnlMaker, Fixed6 pnlLong, Fixed6 pnlShort) {\\n        pnlLong = context.toOracleVersion.price.sub(context.fromOracleVersion.price)\\n            .mul(Fixed6Lib.from(context.fromPosition.longSocialized()));\\n        pnlShort = context.fromOracleVersion.price.sub(context.toOracleVersion.price)\\n            .mul(Fixed6Lib.from(context.fromPosition.shortSocialized()));\\n        pnlMaker = pnlLong.add(pnlShort).mul(Fixed6Lib.NEG_ONE);\\n\\n        next.longValue.increment(pnlLong, context.fromPosition.long);\\n        next.shortValue.increment(pnlShort, context.fromPosition.short);\\n        next.makerValue.increment(pnlMaker, context.fromPosition.maker);\\n    }\\n}\\n\",\"keccak256\":\"0xf3468aeda53f7e0d58b88b5d052a87c8cfa665da34c23b3e0b9434aa83bd57ce\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2/contracts/types/Checkpoint.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@equilibria/root/accumulator/types/Accumulator6.sol\\\";\\nimport \\\"./OracleVersion.sol\\\";\\nimport \\\"./RiskParameter.sol\\\";\\nimport \\\"./Global.sol\\\";\\nimport \\\"./Local.sol\\\";\\nimport \\\"./Order.sol\\\";\\nimport \\\"./Version.sol\\\";\\n\\n/// @dev Checkpoint type\\nstruct Checkpoint {\\n    /// @dev The trade fee that the order incurred at the checkpoint settlement\\n    Fixed6 tradeFee;\\n\\n    // @dev The settlement and liquidation fee that the order incurred at the checkpoint settlement\\n    UFixed6 settlementFee;\\n\\n    /// @dev The amount deposited or withdrawn at the checkpoint settlement\\n    Fixed6 transfer;\\n\\n    /// @dev The collateral at the time of the checkpoint settlement\\n    Fixed6 collateral;\\n}\\nstruct CheckpointStorage { uint256 slot0; }\\nusing CheckpointStorageLib for CheckpointStorage global;\\n\\n/// @dev Manually encodes and decodes the Checkpoint struct into storage.\\n///      (external-safe): this library is safe to externalize\\n///\\n///     struct StoredCheckpoint {\\n///         /* slot 0 */\\n///         int48 tradeFee;\\n///         uint48 settlementFee;\\n///         int64 transfer;\\n///         int64 collateral;\\n///     }\\n///\\nlibrary CheckpointStorageLib {\\n    // sig: 0xba85116a\\n    error CheckpointStorageInvalidError();\\n\\n    function read(CheckpointStorage storage self) internal view returns (Checkpoint memory) {\\n        uint256 slot0 = self.slot0;\\n        return Checkpoint(\\n            Fixed6.wrap(int256(slot0 << (256 - 48)) >> (256 - 48)),\\n            UFixed6.wrap(uint256(slot0 << (256 - 48 - 48)) >> (256 - 48)),\\n            Fixed6.wrap(int256(slot0 << (256 - 48 - 48 - 64)) >> (256 - 64)),\\n            Fixed6.wrap(int256(slot0 << (256 - 48 - 48 - 64 - 64)) >> (256 - 64))\\n        );\\n    }\\n\\n    function store(CheckpointStorage storage self, Checkpoint memory newValue) external {\\n        if (newValue.tradeFee.gt(Fixed6.wrap(type(int48).max))) revert CheckpointStorageInvalidError();\\n        if (newValue.tradeFee.lt(Fixed6.wrap(type(int48).min))) revert CheckpointStorageInvalidError();\\n        if (newValue.settlementFee.gt(UFixed6.wrap(type(uint48).max))) revert CheckpointStorageInvalidError();\\n        if (newValue.transfer.gt(Fixed6.wrap(type(int64).max))) revert CheckpointStorageInvalidError();\\n        if (newValue.transfer.lt(Fixed6.wrap(type(int64).min))) revert CheckpointStorageInvalidError();\\n        if (newValue.collateral.gt(Fixed6.wrap(type(int64).max))) revert CheckpointStorageInvalidError();\\n        if (newValue.collateral.lt(Fixed6.wrap(type(int64).min))) revert CheckpointStorageInvalidError();\\n\\n        uint256 encoded0 =\\n            uint256(Fixed6.unwrap(newValue.tradeFee)        << (256 - 48)) >> (256 - 48) |\\n            uint256(UFixed6.unwrap(newValue.settlementFee)  << (256 - 48)) >> (256 - 48 - 48) |\\n            uint256(Fixed6.unwrap(newValue.transfer)        << (256 - 64)) >> (256 - 48 - 48 - 64) |\\n            uint256(Fixed6.unwrap(newValue.collateral)      << (256 - 64)) >> (256 - 48 - 48 - 64 - 64);\\n\\n        assembly {\\n            sstore(self.slot, encoded0)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x19a22222c8bcaa8b09d17023f057b85e70eb0d7be3894f16d41f5872a7957643\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2/contracts/types/Global.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@equilibria/root/pid/types/PAccumulator6.sol\\\";\\nimport \\\"./ProtocolParameter.sol\\\";\\nimport \\\"./MarketParameter.sol\\\";\\nimport \\\"../libs/VersionLib.sol\\\";\\n\\n/// @dev Global type\\nstruct Global {\\n    /// @dev The current position ID\\n    uint256 currentId;\\n\\n    /// @dev The latest position id\\n    uint256 latestId;\\n\\n    /// @dev The accrued protocol fee\\n    UFixed6 protocolFee;\\n\\n    /// @dev The accrued oracle fee\\n    UFixed6 oracleFee;\\n\\n    /// @dev The accrued risk fee\\n    UFixed6 riskFee;\\n\\n    /// @dev The latest valid price in the market\\n    Fixed6 latestPrice;\\n\\n    /// @dev The accumulated market exposure\\n    Fixed6 exposure;\\n\\n    /// @dev The current PAccumulator state\\n    PAccumulator6 pAccumulator;\\n}\\nusing GlobalLib for Global global;\\nstruct GlobalStorage { uint256 slot0; uint256 slot1; } // SECURITY: must remain at (2) slots\\nusing GlobalStorageLib for GlobalStorage global;\\n\\n/// @title Global\\n/// @dev (external-unsafe): this library must be used internally only\\n/// @notice Holds the global market state\\nlibrary GlobalLib {\\n    /// @notice Updates market exposure based on a change in the risk parameter configuration\\n    /// @param self The Global object to update\\n    /// @param latestRiskParameter The latest risk parameter configuration\\n    /// @param newRiskParameter The new risk parameter configuration\\n    /// @param latestPosition The latest position\\n    function update(\\n        Global memory self,\\n        RiskParameter memory latestRiskParameter,\\n        RiskParameter memory newRiskParameter,\\n        Position memory latestPosition\\n    ) internal pure {\\n        Fixed6 exposureChange = latestRiskParameter.takerFee\\n            .exposure(newRiskParameter.takerFee, latestPosition.skew(), self.latestPrice.abs());\\n        self.exposure = self.exposure.sub(exposureChange);\\n    }\\n\\n    /// @notice Increments the fees by `amount` using current parameters\\n    /// @dev Computes the fees based on the current market parameters\\n    ///      market fee -> trade fee + market's trade offset + funding fee + interest fee\\n    ///        1. oracle fee taken out as a percentage of what's left of market fee\\n    ///        2. risk fee taken out as a percentage of what's left of market fee\\n    ///        3. protocol fee is what's left of market fee\\n    /// @param self The Global object to update\\n    /// @param newLatestId The new latest position id\\n    /// @param accumulation The accumulation result\\n    /// @param marketParameter The current market parameters\\n    /// @param oracleReceipt The receipt of the corresponding oracle version\\n    function update(\\n        Global memory self,\\n        uint256 newLatestId,\\n        VersionAccumulationResponse memory accumulation,\\n        MarketParameter memory marketParameter,\\n        OracleReceipt memory oracleReceipt\\n    ) internal pure {\\n        UFixed6 marketFee = accumulation.marketFee;\\n\\n        UFixed6 oracleFee = marketFee.mul(oracleReceipt.oracleFee);\\n        marketFee = marketFee.sub(oracleFee);\\n\\n        UFixed6 riskFee = marketFee.mul(marketParameter.riskFee);\\n        marketFee = marketFee.sub(riskFee);\\n\\n        self.latestId = newLatestId;\\n        self.protocolFee = self.protocolFee.add(marketFee);\\n        self.oracleFee = self.oracleFee.add(accumulation.settlementFee).add(oracleFee);\\n        self.riskFee = self.riskFee.add(riskFee);\\n        self.exposure = self.exposure.add(accumulation.marketExposure);\\n    }\\n\\n    /// @notice Overrides the price of the oracle with the latest global version if it is empty\\n    /// @param self The Global object to read from\\n    /// @param oracleVersion The oracle version to update\\n    function overrideIfZero(Global memory self, OracleVersion memory oracleVersion) internal pure {\\n        if (oracleVersion.price.isZero()) oracleVersion.price = self.latestPrice;\\n    }\\n}\\n\\n/// @dev Manually encodes and decodes the Global struct into storage.\\n///      (external-safe): this library is safe to externalize\\n///\\n///     struct StoredGlobal {\\n///         /* slot 0 */\\n///         uint32 currentId;           // <= 4.29b\\n///         uint32 latestId;            // <= 4.29b\\n///         uint48 protocolFee;         // <= 281m\\n///         uint48 oracleFee;           // <= 281m\\n///         uint48 riskFee;             // <= 281m\\n///\\n///         /* slot 1 */\\n///         int32 pAccumulator.value;   // <= 214000%\\n///         int24 pAccumulator.skew;    // <= 838%\\n///         int64 latestPrice;          // <= 9.22t\\n///         int64 exposure;             // <= 9.22t\\n///     }\\n///\\nlibrary GlobalStorageLib {\\n    // sig: 0x2142bc27\\n    error GlobalStorageInvalidError();\\n\\n    function read(GlobalStorage storage self) internal view returns (Global memory) {\\n        (uint256 slot0, uint256 slot1) = (self.slot0, self.slot1);\\n        return Global(\\n            uint256(slot0 << (256 - 32)) >> (256 - 32),\\n            uint256(slot0 << (256 - 32 - 32)) >> (256 - 32),\\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 48)) >> (256 - 48)),\\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 48 - 48)) >> (256 - 48)),\\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 48 - 48 - 48)) >> (256 - 48)),\\n            Fixed6.wrap(int256(slot1 << (256 - 32 - 24 - 64)) >> (256 - 64)),\\n            Fixed6.wrap(int256(slot1 << (256 - 32 - 24 - 64 - 64)) >> (256 - 64)),\\n            PAccumulator6(\\n                Fixed6.wrap(int256(slot1 << (256 - 32)) >> (256 - 32)),\\n                Fixed6.wrap(int256(slot1 << (256 - 32 - 24)) >> (256 - 24))\\n            )\\n        );\\n    }\\n\\n    function store(GlobalStorage storage self, Global memory newValue) external {\\n        if (newValue.currentId > uint256(type(uint32).max)) revert GlobalStorageInvalidError();\\n        if (newValue.latestId > uint256(type(uint32).max)) revert GlobalStorageInvalidError();\\n        if (newValue.protocolFee.gt(UFixed6.wrap(type(uint48).max))) revert GlobalStorageInvalidError();\\n        if (newValue.oracleFee.gt(UFixed6.wrap(type(uint48).max))) revert GlobalStorageInvalidError();\\n        if (newValue.riskFee.gt(UFixed6.wrap(type(uint48).max))) revert GlobalStorageInvalidError();\\n        if (newValue.latestPrice.gt(Fixed6.wrap(type(int64).max))) revert GlobalStorageInvalidError();\\n        if (newValue.latestPrice.lt(Fixed6.wrap(type(int64).min))) revert GlobalStorageInvalidError();\\n        if (newValue.exposure.gt(Fixed6.wrap(type(int64).max))) revert GlobalStorageInvalidError();\\n        if (newValue.exposure.lt(Fixed6.wrap(type(int64).min))) revert GlobalStorageInvalidError();\\n        if (newValue.pAccumulator._value.gt(Fixed6.wrap(type(int32).max))) revert GlobalStorageInvalidError();\\n        if (newValue.pAccumulator._value.lt(Fixed6.wrap(type(int32).min))) revert GlobalStorageInvalidError();\\n        if (newValue.pAccumulator._skew.gt(Fixed6.wrap(type(int24).max))) revert GlobalStorageInvalidError();\\n        if (newValue.pAccumulator._skew.lt(Fixed6.wrap(type(int24).min))) revert GlobalStorageInvalidError();\\n\\n        uint256 encoded0 =\\n            uint256(newValue.currentId << (256 - 32)) >> (256 - 32) |\\n            uint256(newValue.latestId << (256 - 32)) >> (256 - 32 - 32) |\\n            uint256(UFixed6.unwrap(newValue.protocolFee) << (256 - 48)) >> (256 - 32 - 32 - 48) |\\n            uint256(UFixed6.unwrap(newValue.oracleFee) << (256 - 48)) >> (256 - 32 - 32 - 48 - 48) |\\n            uint256(UFixed6.unwrap(newValue.riskFee) << (256 - 48)) >> (256 - 32 - 32 - 48 - 48 - 48);\\n\\n        uint256 encoded1 =\\n            uint256(Fixed6.unwrap(newValue.pAccumulator._value) << (256 - 32)) >> (256 - 32) |\\n            uint256(Fixed6.unwrap(newValue.pAccumulator._skew) << (256 - 24)) >> (256 - 32 - 24) |\\n            uint256(Fixed6.unwrap(newValue.latestPrice) << (256 - 64)) >> (256 - 32 - 24 - 64) |\\n            uint256(Fixed6.unwrap(newValue.exposure) << (256 - 64)) >> (256 - 32 - 24 - 64 - 64);\\n\\n        assembly {\\n            sstore(self.slot, encoded0)\\n            sstore(add(self.slot, 1), encoded1)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x44686dc21f3a15b1fd1ea0437a893db6501a89508f9a74302707f8c9dcf8ec1f\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2/contracts/types/Guarantee.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"./Order.sol\\\";\\n\\n/// @dev Guarantee type\\nstruct Guarantee {\\n    /// @dev The quantity of guarantees that that will be exempt from the settlement fee\\n    uint256 orders;\\n\\n    /// @dev The notional of the magnitude with the price override (local only)\\n    Fixed6 notional;\\n\\n    /// @dev The positive skew (open long / close short) guarantee size\\n    UFixed6 takerPos;\\n\\n    /// @dev The negative skew (close long / open short) guarantee size\\n    UFixed6 takerNeg;\\n\\n    /// @dev The magnitude of the guarantee that be exempt from the trade fee\\n    UFixed6 takerFee;\\n\\n    /// @dev The referral fee multiplied by the size applicable to the referral (local only)\\n    UFixed6 referral;\\n}\\nusing GuaranteeLib for Guarantee global;\\nstruct GuaranteeStorageGlobal { uint256 slot0; uint256 slot1; } // SECURITY: must remain at (2) slots\\nusing GuaranteeStorageGlobalLib for GuaranteeStorageGlobal global;\\nstruct GuaranteeStorageLocal { uint256 slot0; uint256 slot1; } // SECURITY: must remain at (2) slots\\nusing GuaranteeStorageLocalLib for GuaranteeStorageLocal global;\\n\\n/// @title Guarantee\\n/// @dev (external-unsafe): this library must be used internally only\\n/// @notice Holds the state for an account's update guarantee\\nlibrary GuaranteeLib {\\n    /// @notice Prepares the next guarantee from the current guarantee\\n    /// @param self The guarantee object to update\\n    function next(Guarantee memory self) internal pure  {\\n        invalidate(self);\\n        self.orders = 0;\\n    }\\n\\n    /// @notice Invalidates the guarantee\\n    /// @param self The guarantee object to update\\n    function invalidate(Guarantee memory self) internal pure {\\n        (self.takerPos, self.takerNeg, self.notional, self.takerFee, self.referral) =\\n            (UFixed6Lib.ZERO, UFixed6Lib.ZERO, Fixed6Lib.ZERO, UFixed6Lib.ZERO, UFixed6Lib.ZERO);\\n    }\\n\\n    /// @notice Creates a new guarantee from an order\\n    /// @param order The order to create the guarantee from\\n    /// @param priceOverride The price override\\n    /// @param referralFee The the percentage of the subtractive fee to take as a solver referral fee\\n    /// @param chargeSettlementFee Whether the order will still be charged the settlement fee\\n    /// @param chargeTradeFee Whether the order will still be charged the trade fee\\n    /// @return newGuarantee The resulting guarantee\\n    function from(\\n        Order memory order,\\n        Fixed6 priceOverride,\\n        UFixed6 referralFee,\\n        bool chargeSettlementFee,\\n        bool chargeTradeFee\\n    ) internal pure returns (Guarantee memory newGuarantee) {\\n        // maker orders and one intent order per fill will be required to pay the settlement fee\\n        if (!order.takerTotal().isZero() && !chargeSettlementFee) newGuarantee.orders = order.orders;\\n\\n        (newGuarantee.takerPos, newGuarantee.takerNeg) =\\n            (order.longPos.add(order.shortNeg), order.longNeg.add(order.shortPos));\\n        newGuarantee.takerFee = chargeTradeFee ? UFixed6Lib.ZERO : order.takerTotal();\\n\\n        newGuarantee.notional = taker(newGuarantee).mul(priceOverride);\\n        newGuarantee.referral = order.takerReferral.mul(referralFee);\\n    }\\n\\n    /// @notice Returns the taker delta of the guarantee\\n    /// @param self The guarantee object to check\\n    /// @return The taker delta of the guarantee\\n    function taker(Guarantee memory self) internal pure returns (Fixed6) {\\n        return Fixed6Lib.from(self.takerPos).sub(Fixed6Lib.from(self.takerNeg));\\n    }\\n\\n    /// @notice Returns the total taker delta of the guarantee\\n    /// @param self The guarantee object to check\\n    /// @return The total taker delta of the guarantee\\n    function takerTotal(Guarantee memory self) internal pure returns (UFixed6) {\\n        return self.takerPos.add(self.takerNeg);\\n    }\\n\\n    /// @notice Updates the current global guarantee with a new local guarantee\\n    /// @param self The guarantee object to update\\n    /// @param guarantee The new guarantee\\n    function add(Guarantee memory self, Guarantee memory guarantee) internal pure {\\n        self.orders = self.orders + guarantee.orders;\\n        (self.notional, self.takerPos, self.takerNeg, self.takerFee, self.referral) = (\\n            self.notional.add(guarantee.notional),\\n            self.takerPos.add(guarantee.takerPos),\\n            self.takerNeg.add(guarantee.takerNeg),\\n            self.takerFee.add(guarantee.takerFee),\\n            self.referral.add(guarantee.referral)\\n        );\\n    }\\n}\\n\\n/// @dev Manually encodes and decodes the global Guarantee struct into storage.\\n///      (external-safe): this library is safe to externalize\\n///\\n///     struct StoredGuaranteeGlobal {\\n///         /* slot 0 */\\n///         uint32 orders;\\n///         uint64 takerPos;\\n///         uint64 takerNeg;\\n///         uint64 takerFee;\\n///     }\\n///\\nlibrary GuaranteeStorageGlobalLib {\\n    function read(GuaranteeStorageGlobal storage self) internal view returns (Guarantee memory) {\\n        uint256 slot0 = self.slot0;\\n        return Guarantee(\\n            uint256(slot0 << (256 - 32)) >> (256 - 32),\\n            Fixed6Lib.ZERO,\\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 64)) >> (256 - 64)),\\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 64 - 64)) >> (256 - 64)),\\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 64 - 64 - 64)) >> (256 - 64)),\\n            UFixed6Lib.ZERO\\n        );\\n    }\\n\\n    function store(GuaranteeStorageGlobal storage self, Guarantee memory newValue) internal {\\n        GuaranteeStorageLib.validate(newValue);\\n\\n        uint256 encoded0 =\\n            uint256(newValue.orders << (256 - 32)) >> (256 - 32) |\\n            uint256(UFixed6.unwrap(newValue.takerPos) << (256 - 64)) >> (256 - 32 - 64) |\\n            uint256(UFixed6.unwrap(newValue.takerNeg) << (256 - 64)) >> (256 - 32 - 64 - 64) |\\n            uint256(UFixed6.unwrap(newValue.takerFee) << (256 - 64)) >> (256 - 32 - 64 - 64 - 64);\\n\\n        assembly {\\n            sstore(self.slot, encoded0)\\n        }\\n    }\\n}\\n\\n/// @dev Manually encodes and decodes the local Guarantee struct into storage.\\n///      (external-safe): this library is safe to externalize\\n///\\n///     struct StoredGuaranteeLocal {\\n///         /* slot 0 */\\n///         uint32 orders;\\n///         int64 notional;\\n///         uint64 takerPos;\\n///         uint64 takerNeg;\\n///\\n///         /* slot 1 */\\n///         uint64 takerFee;\\n///         uint64 referral;\\n///     }\\n///\\nlibrary GuaranteeStorageLocalLib {\\n    function read(GuaranteeStorageLocal storage self) internal view returns (Guarantee memory) {\\n        (uint256 slot0, uint256 slot1) = (self.slot0, self.slot1);\\n        return Guarantee(\\n            uint256(slot0 << (256 - 32)) >> (256 - 32),\\n            Fixed6.wrap(int256(slot0 << (256 - 32 - 64)) >> (256 - 64)),\\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 64 - 64)) >> (256 - 64)),\\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 64 - 64 - 64)) >> (256 - 64)),\\n            UFixed6.wrap(uint256(slot1 << (256 - 64)) >> (256 - 64)),\\n            UFixed6.wrap(uint256(slot1 << (256 - 64 - 64)) >> (256 - 64))\\n        );\\n    }\\n\\n    function store(GuaranteeStorageLocal storage self, Guarantee memory newValue) internal {\\n        GuaranteeStorageLib.validate(newValue);\\n\\n        if (newValue.notional.gt(Fixed6.wrap(type(int64).max))) revert GuaranteeStorageLib.GuaranteeStorageInvalidError();\\n        if (newValue.notional.lt(Fixed6.wrap(type(int64).min))) revert GuaranteeStorageLib.GuaranteeStorageInvalidError();\\n        if (newValue.referral.gt(UFixed6.wrap(type(uint64).max))) revert GuaranteeStorageLib.GuaranteeStorageInvalidError();\\n\\n        uint256 encoded0 =\\n            uint256(newValue.orders << (256 - 32)) >> (256 - 32) |\\n            uint256(Fixed6.unwrap(newValue.notional) << (256 - 64)) >> (256 - 32 - 64) |\\n            uint256(UFixed6.unwrap(newValue.takerPos) << (256 - 64)) >> (256 - 32 - 64 - 64) |\\n            uint256(UFixed6.unwrap(newValue.takerNeg) << (256 - 64)) >> (256 - 32 - 64 - 64 - 64);\\n        uint256 encode1 =\\n            uint256(UFixed6.unwrap(newValue.takerFee) << (256 - 64)) >> (256 - 64) |\\n            uint256(UFixed6.unwrap(newValue.referral) << (256 - 64)) >> (256 - 64 - 64);\\n\\n        assembly {\\n            sstore(self.slot, encoded0)\\n            sstore(add(self.slot, 1), encode1)\\n        }\\n    }\\n}\\n\\nlibrary GuaranteeStorageLib {\\n    // sig: 0xfd030f36\\n    error GuaranteeStorageInvalidError();\\n\\n    function validate(Guarantee memory newValue) internal pure {\\n        if (newValue.orders > type(uint32).max) revert GuaranteeStorageInvalidError();\\n        if (newValue.takerPos.gt(UFixed6.wrap(type(uint64).max))) revert GuaranteeStorageLib.GuaranteeStorageInvalidError();\\n        if (newValue.takerNeg.gt(UFixed6.wrap(type(uint64).max))) revert GuaranteeStorageLib.GuaranteeStorageInvalidError();\\n        if (newValue.takerFee.gt(UFixed6.wrap(type(uint64).max))) revert GuaranteeStorageLib.GuaranteeStorageInvalidError();\\n    }\\n}\",\"keccak256\":\"0x903286b562e3c7df7481792dea946edde53a369e93245a2645f914c290927c1d\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2/contracts/types/Local.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@equilibria/root/number/types/Fixed6.sol\\\";\\nimport \\\"@equilibria/root/accumulator/types/UAccumulator6.sol\\\";\\nimport \\\"@equilibria/root/accumulator/types/Accumulator6.sol\\\";\\nimport \\\"./Version.sol\\\";\\nimport \\\"./Position.sol\\\";\\nimport \\\"./RiskParameter.sol\\\";\\nimport \\\"./OracleVersion.sol\\\";\\nimport \\\"./Order.sol\\\";\\nimport \\\"./Checkpoint.sol\\\";\\nimport \\\"../libs/CheckpointLib.sol\\\";\\n\\n/// @dev Local type\\nstruct Local {\\n    /// @dev The current position id\\n    uint256 currentId;\\n\\n    /// @dev The latest position id\\n    uint256 latestId;\\n\\n    /// @dev The collateral balance\\n    Fixed6 collateral;\\n\\n    /// @dev The claimable balance\\n    UFixed6 claimable;\\n}\\nusing LocalLib for Local global;\\nstruct LocalStorage { uint256 slot0; uint256 slot1; }\\nusing LocalStorageLib for LocalStorage global;\\n\\n/// @title Local\\n/// @dev (external-unsafe): this library must be used internally only\\n/// @notice Holds the local account state\\nlibrary LocalLib {\\n    /// @notice Updates the collateral with the new deposit or withdrwal\\n    /// @param self The Local object to update\\n    /// @param transfer The amount to update the collateral by\\n    function update(Local memory self, Fixed6 transfer) internal pure {\\n        self.collateral = self.collateral.add(transfer);\\n    }\\n\\n    /// @notice Updates the collateral with the new collateral change\\n    /// @param self The Local object to update\\n    /// @param accumulation The accumulation result\\n    function update(\\n        Local memory self,\\n        uint256 newId,\\n        CheckpointAccumulationResponse memory accumulation\\n    ) internal pure {\\n        self.collateral = self.collateral.add(accumulation.collateral).sub(Fixed6Lib.from(accumulation.liquidationFee));\\n        self.latestId = newId;\\n    }\\n\\n    /// @notice Updates the claimable with the new amount\\n    /// @param self The Local object to update\\n    /// @param amount The amount to update the claimable by\\n    function credit(Local memory self, UFixed6 amount) internal pure {\\n        self.claimable = self.claimable.add(amount);\\n    }\\n}\\n\\n/// @dev Manually encodes and decodes the Local struct into storage.\\n///      (external-safe): this library is safe to externalize\\n///\\n///     struct StoredLocal {\\n///         /* slot 0 */\\n///         uint32 currentId;       // <= 4.29b\\n///         uint32 latestId;        // <= 4.29b\\n///         int64 collateral;       // <= 9.22t\\n///         uint64 claimable;       // <= 18.44t\\n///         bytes4 __DEPRECATED;    // UNSAFE UNTIL RESET\\n///     }\\n///\\nlibrary LocalStorageLib {\\n    // sig: 0xc83d08ec\\n    error LocalStorageInvalidError();\\n\\n    function read(LocalStorage storage self) internal view returns (Local memory) {\\n        uint256 slot0 = self.slot0;\\n        return Local(\\n            uint256(slot0 << (256 - 32)) >> (256 - 32),\\n            uint256(slot0 << (256 - 32 - 32)) >> (256 - 32),\\n            Fixed6.wrap(int256(slot0 << (256 - 32 - 32 - 64)) >> (256 - 64)),\\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 64 - 64)) >> (256 - 64))\\n        );\\n    }\\n\\n    function store(LocalStorage storage self, Local memory newValue) internal {\\n        if (newValue.currentId > uint256(type(uint32).max)) revert LocalStorageInvalidError();\\n        if (newValue.latestId > uint256(type(uint32).max)) revert LocalStorageInvalidError();\\n        if (newValue.collateral.gt(Fixed6.wrap(type(int64).max))) revert LocalStorageInvalidError();\\n        if (newValue.collateral.lt(Fixed6.wrap(type(int64).min))) revert LocalStorageInvalidError();\\n        if (newValue.claimable.gt(UFixed6.wrap(type(uint64).max))) revert LocalStorageInvalidError();\\n\\n        uint256 encoded0 =\\n            uint256(newValue.currentId << (256 - 32)) >> (256 - 32) |\\n            uint256(newValue.latestId << (256 - 32)) >> (256 - 32 - 32) |\\n            uint256(Fixed6.unwrap(newValue.collateral) << (256 - 64)) >> (256 - 32 - 32 - 64) |\\n            uint256(UFixed6.unwrap(newValue.claimable) << (256 - 64)) >> (256 - 32 - 32 - 64 - 64);\\n\\n        assembly {\\n            sstore(self.slot, encoded0)\\n        }\\n    }\\n}\",\"keccak256\":\"0x813782df64338a7aec64164e5deeed64b10ba4a3656d63fb05083778045fef4d\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2/contracts/types/MarketParameter.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@equilibria/root/token/types/Token18.sol\\\";\\nimport \\\"@equilibria/root/number/types/UFixed6.sol\\\";\\nimport \\\"./ProtocolParameter.sol\\\";\\n\\n/// @dev MarketParameter type\\nstruct MarketParameter {\\n    /// @dev The fee that is taken out of funding\\n    UFixed6 fundingFee;\\n\\n    /// @dev The fee that is taken out of interest\\n    UFixed6 interestFee;\\n\\n    /// @dev The fee that is taken out of maker and taker fees\\n    UFixed6 makerFee;\\n\\n    /// @dev The fee that is taken out of maker and taker fees\\n    UFixed6 takerFee;\\n\\n    /// @dev The share of the collected fees that is paid to the risk coordinator\\n    UFixed6 riskFee;\\n\\n    /// @dev The maximum amount of orders that can be pending at one time globally\\n    uint256 maxPendingGlobal;\\n\\n    /// @dev The maximum amount of orders that can be pending at one time per account\\n    uint256 maxPendingLocal;\\n\\n    /// @dev Whether the market is in close-only mode\\n    bool closed;\\n\\n     /// @dev Whether the market is in settle-only mode\\n    bool settle;\\n}\\nstruct MarketParameterStorage { uint256 slot0; uint256 slot1; } // SECURITY: must remain at (2) slots\\nusing MarketParameterStorageLib for MarketParameterStorage global;\\n\\n/// @dev Manually encodes and decodes the MarketParameter struct into storage.\\n///      (external-safe): this library is safe to externalize\\n///\\n///    struct StoredMarketParameter {\\n///        /* slot 0 */\\n///        uint24 fundingFee;          // <= 1677%\\n///        uint24 interestFee;         // <= 1677%\\n///        uint24 makerFee;            // <= 1677%\\n///        uint24 takerFee;            // <= 1677%\\n///        uint24 __unallocated__;     // <= 1677%\\n///        uint24 riskFee;             // <= 1677%\\n///        uint16 maxPendingGlobal;    // <= 65k\\n///        uint16 maxPendingLocal;     // <= 65k\\n///        uint48 __unallocated__;     // <= 281m\\n///        uint8 flags;\\n///    }\\n///\\nlibrary MarketParameterStorageLib {\\n    // sig: 0x7c53e926\\n    error MarketParameterStorageInvalidError();\\n\\n    function read(MarketParameterStorage storage self) internal view returns (MarketParameter memory) {\\n        uint256 slot0 = self.slot0;\\n\\n        uint256 flags = uint256(slot0 << (256 - 24 - 24 - 24 - 24 - 24 - 24 - 16 - 16 - 48 - 8)) >> (256 - 8);\\n        (bool closed, bool settle) =\\n            (flags & 0x04 == 0x04, flags & 0x08 == 0x08);\\n\\n        return MarketParameter(\\n            UFixed6.wrap(uint256(slot0 << (256 - 24)) >> (256 - 24)),\\n            UFixed6.wrap(uint256(slot0 << (256 - 24 - 24)) >> (256 - 24)),\\n            UFixed6.wrap(uint256(slot0 << (256 - 24 - 24 - 24)) >> (256 - 24)),\\n            UFixed6.wrap(uint256(slot0 << (256 - 24 - 24 - 24 - 24)) >> (256 - 24)),\\n            UFixed6.wrap(uint256(slot0 << (256 - 24 - 24 - 24 - 24 - 24 - 24)) >> (256 - 24)),\\n            uint256(slot0 << (256 - 24 - 24 - 24 - 24 - 24 - 24 - 16)) >> (256 - 16),\\n            uint256(slot0 << (256 - 24 - 24 - 24 - 24 - 24 - 24 - 16 - 16)) >> (256 - 16),\\n            closed,\\n            settle\\n        );\\n    }\\n\\n    function validate(MarketParameter memory self, ProtocolParameter memory protocolParameter) private pure {\\n        if (self.fundingFee.max(self.interestFee).max(self.makerFee).max(self.takerFee).gt(protocolParameter.maxCut))\\n            revert MarketParameterStorageInvalidError();\\n\\n        if (self.riskFee.gt(UFixed6Lib.ONE))\\n            revert MarketParameterStorageInvalidError();\\n    }\\n\\n    function validateAndStore(\\n        MarketParameterStorage storage self,\\n        MarketParameter memory newValue,\\n        ProtocolParameter memory protocolParameter\\n    ) external {\\n        validate(newValue, protocolParameter);\\n\\n        if (newValue.maxPendingGlobal > uint256(type(uint16).max)) revert MarketParameterStorageInvalidError();\\n        if (newValue.maxPendingLocal > uint256(type(uint16).max)) revert MarketParameterStorageInvalidError();\\n\\n        _store(self, newValue);\\n    }\\n\\n    function _store(MarketParameterStorage storage self, MarketParameter memory newValue) private {\\n        uint256 flags = (newValue.closed ? 0x04 : 0x00) |\\n            (newValue.settle ? 0x08 : 0x00);\\n\\n        uint256 encoded0 =\\n            uint256(UFixed6.unwrap(newValue.fundingFee) << (256 - 24)) >> (256 - 24) |\\n            uint256(UFixed6.unwrap(newValue.interestFee) << (256 - 24)) >> (256 - 24 - 24) |\\n            uint256(UFixed6.unwrap(newValue.makerFee) << (256 - 24)) >> (256 - 24 - 24 - 24) |\\n            uint256(UFixed6.unwrap(newValue.takerFee) << (256 - 24)) >> (256 - 24 - 24 - 24 - 24) |\\n            uint256(UFixed6.unwrap(newValue.riskFee) << (256 - 24)) >> (256 - 24 - 24 - 24 - 24 - 24 - 24) |\\n            uint256(newValue.maxPendingGlobal << (256 - 16)) >> (256 - 24 - 24 - 24 - 24 - 24 - 24 - 16) |\\n            uint256(newValue.maxPendingLocal << (256 - 16)) >> (256 - 24 - 24 - 24 - 24 - 24 - 24 - 16 - 16) |\\n            uint256(flags << (256 - 8)) >> (256 - 24 - 24 - 24 - 24 - 24 - 24 - 16 - 16 - 48 - 8);\\n\\n        assembly {\\n            sstore(self.slot, encoded0)\\n        }\\n    }\\n}\",\"keccak256\":\"0x95338665ec5f9b4f85492ca8c02f5a2a29cf08933bd899f072f062eb966dcc23\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2/contracts/types/OracleReceipt.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport { UFixed6 } from \\\"@equilibria/root/number/types/UFixed6.sol\\\";\\n\\n/// @dev The cost receipt of for a corresponding oracle version\\nstruct OracleReceipt {\\n    /// @dev The fixed settlement fee of the request\\n    UFixed6 settlementFee;\\n\\n    /// @dev The relative oracle fee percentage of the request\\n    UFixed6 oracleFee;\\n}\\n\",\"keccak256\":\"0x686ef41f5b492f41fdbfe8b27afd42beac4d70b08e90e6f93e6ecffbe9b175a2\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2/contracts/types/OracleVersion.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@equilibria/root/number/types/Fixed6.sol\\\";\\n\\n/// @dev A singular oracle version with its corresponding data\\nstruct OracleVersion {\\n    /// @dev the timestamp of the oracle update\\n    uint256 timestamp;\\n\\n    /// @dev The oracle price of the corresponding version\\n    Fixed6 price;\\n\\n    /// @dev Whether the version is valid\\n    bool valid;\\n}\\n\",\"keccak256\":\"0x543d36affe7b862bf72fac9cfb40a639d2b3fe1b32d9181552d523bc64d9a0f7\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2/contracts/types/Order.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"./OracleVersion.sol\\\";\\nimport \\\"./RiskParameter.sol\\\";\\nimport \\\"./Global.sol\\\";\\nimport \\\"./Local.sol\\\";\\nimport \\\"./Position.sol\\\";\\nimport \\\"./MarketParameter.sol\\\";\\n\\n/// @dev Order type\\nstruct Order {\\n    /// @dev The timestamp of the order\\n    uint256 timestamp;\\n\\n    /// @dev The quantity of orders that are included in this order\\n    uint256 orders;\\n\\n    /// @dev The change in the collateral\\n    Fixed6 collateral;\\n\\n    /// @dev The positive skew maker order size\\n    UFixed6 makerPos;\\n\\n    /// @dev The negative skew maker order size\\n    UFixed6 makerNeg;\\n\\n    /// @dev The positive skew long order size\\n    UFixed6 longPos;\\n\\n    /// @dev The negative skew long order size\\n    UFixed6 longNeg;\\n\\n    /// @dev The positive skew short order size\\n    UFixed6 shortPos;\\n\\n    /// @dev The negative skew short order size\\n    UFixed6 shortNeg;\\n\\n    /// @dev The protection status semaphore (local only)\\n    uint256 protection;\\n\\n    /// @dev The referral fee multiplied by the size applicable to the referral\\n    UFixed6 makerReferral;\\n\\n    /// @dev The referral fee multiplied by the size applicable to the referral\\n    UFixed6 takerReferral;\\n}\\nusing OrderLib for Order global;\\nstruct OrderStorageGlobal { uint256 slot0; uint256 slot1; uint256 slot2; } // SECURITY: must remain at (3) slots\\nusing OrderStorageGlobalLib for OrderStorageGlobal global;\\nstruct OrderStorageLocal { uint256 slot0; uint256 slot1; } // SECURITY: must remain at (2) slots\\nusing OrderStorageLocalLib for OrderStorageLocal global;\\n\\n/// @title Order\\n/// @dev (external-unsafe): this library must be used internally only\\n/// @notice Holds the state for an account's update order\\nlibrary OrderLib {\\n    /// @notice Returns whether the order is ready to be settled\\n    /// @param self The order object to check\\n    /// @param latestVersion The latest oracle version\\n    /// @return Whether the order is ready to be settled\\n    function ready(Order memory self, OracleVersion memory latestVersion) internal pure returns (bool) {\\n        return latestVersion.timestamp >= self.timestamp;\\n    }\\n\\n    /// @notice Prepares the next order from the current order\\n    /// @param self The order object to update\\n    /// @param timestamp The current timestamp\\n    function next(Order memory self, uint256 timestamp) internal pure  {\\n        invalidate(self);\\n        (self.timestamp, self.orders, self.collateral, self.protection) = (timestamp, 0, Fixed6Lib.ZERO, 0);\\n    }\\n\\n    /// @notice Invalidates the order\\n    /// @param self The order object to update\\n    function invalidate(Order memory self) internal pure {\\n        (self.makerReferral, self.takerReferral) =\\n            (UFixed6Lib.ZERO, UFixed6Lib.ZERO);\\n        (self.makerPos, self.makerNeg, self.longPos, self.longNeg, self.shortPos, self.shortNeg) =\\n            (UFixed6Lib.ZERO, UFixed6Lib.ZERO, UFixed6Lib.ZERO, UFixed6Lib.ZERO, UFixed6Lib.ZERO, UFixed6Lib.ZERO);\\n    }\\n\\n    /// @notice Creates a new order from the an intent order request\\n    /// @param timestamp The current timestamp\\n    /// @param position The current position\\n    /// @param amount The magnitude and direction of the order\\n    /// @param collateral The change in the collateral\\n    /// @param referralFee The referral fee\\n    /// @return newOrder The resulting order\\n    function from(\\n        uint256 timestamp,\\n        Position memory position,\\n        Fixed6 amount,\\n        Fixed6 collateral,\\n        UFixed6 referralFee\\n    ) internal pure returns (Order memory newOrder) {\\n        newOrder.timestamp = timestamp;\\n        newOrder.collateral = collateral;\\n        newOrder.orders = amount.isZero() ? 0 : 1;\\n        newOrder.takerReferral = amount.abs().mul(referralFee);\\n\\n        // If the order is not counter to the current position, it is opening\\n        if (amount.sign() == 0 || position.skew().sign() == 0 || position.skew().sign() == amount.sign()) {\\n            newOrder.longPos = amount.max(Fixed6Lib.ZERO).abs();\\n            newOrder.shortPos = amount.min(Fixed6Lib.ZERO).abs();\\n\\n        // If the order is counter to the current position, it is closing\\n        } else {\\n            newOrder.shortNeg = amount.max(Fixed6Lib.ZERO).abs();\\n            newOrder.longNeg = amount.min(Fixed6Lib.ZERO).abs();\\n        }\\n    }\\n\\n    /// @notice Creates a new order from the current position and an update request\\n    /// @param timestamp The current timestamp\\n    /// @param position The current position\\n    /// @param collateral The change in the collateral\\n    /// @param newMaker The new maker\\n    /// @param newLong The new long\\n    /// @param newShort The new short\\n    /// @param protect Whether to protect the order\\n    /// @param referralFee The referral fee\\n    /// @return newOrder The resulting order\\n    function from(\\n        uint256 timestamp,\\n        Position memory position,\\n        Fixed6 collateral,\\n        UFixed6 newMaker,\\n        UFixed6 newLong,\\n        UFixed6 newShort,\\n        bool protect,\\n        UFixed6 referralFee\\n    ) internal pure returns (Order memory newOrder) {\\n        (Fixed6 makerAmount, Fixed6 longAmount, Fixed6 shortAmount) = (\\n            Fixed6Lib.from(newMaker).sub(Fixed6Lib.from(position.maker)),\\n            Fixed6Lib.from(newLong).sub(Fixed6Lib.from(position.long)),\\n            Fixed6Lib.from(newShort).sub(Fixed6Lib.from(position.short))\\n        );\\n\\n        UFixed6 referral = makerAmount.abs().add(longAmount.abs()).add(shortAmount.abs()).mul(referralFee);\\n\\n        newOrder = Order(\\n            timestamp,\\n            0,\\n            collateral,\\n            makerAmount.max(Fixed6Lib.ZERO).abs(),\\n            makerAmount.min(Fixed6Lib.ZERO).abs(),\\n            longAmount.max(Fixed6Lib.ZERO).abs(),\\n            longAmount.min(Fixed6Lib.ZERO).abs(),\\n            shortAmount.max(Fixed6Lib.ZERO).abs(),\\n            shortAmount.min(Fixed6Lib.ZERO).abs(),\\n            protect ? 1 : 0,\\n            makerAmount.isZero() ? UFixed6Lib.ZERO : referral,\\n            makerAmount.isZero() ? referral : UFixed6Lib.ZERO\\n        );\\n        if (!isEmpty(newOrder)) newOrder.orders = 1;\\n    }\\n\\n    /// @notice Returns whether the order increases any of the account's positions\\n    /// @return Whether the order increases any of the account's positions\\n    function increasesPosition(Order memory self) internal pure returns (bool) {\\n        return increasesMaker(self) || increasesTaker(self);\\n    }\\n\\n    /// @notice Returns whether the order increases the account's long or short positions\\n    /// @return Whether the order increases the account's long or short positions\\n    function increasesTaker(Order memory self) internal pure returns (bool) {\\n        return !self.longPos.isZero() || !self.shortPos.isZero();\\n    }\\n\\n    /// @notice Returns whether the order increases the account's maker position\\n    /// @return Whether the order increases the account's maker positions\\n    function increasesMaker(Order memory self) internal pure returns (bool) {\\n        return !self.makerPos.isZero();\\n    }\\n\\n    /// @notice Returns whether the order decreases the liquidity of the market\\n    /// @return Whether the order decreases the liquidity of the market\\n    function decreasesLiquidity(Order memory self, Position memory currentPosition) internal pure returns (bool) {\\n        Fixed6 currentSkew = currentPosition.skew();\\n        Fixed6 latestSkew = currentSkew.sub(long(self)).add(short(self));\\n        return !self.makerNeg.isZero() || currentSkew.abs().gt(latestSkew.abs());\\n    }\\n\\n    /// @notice Returns whether the order decreases the efficieny of the market\\n    /// @dev Decreased efficiency ratio intuitively means that the market is \\\"more efficient\\\" on an OI to LP basis.\\n    /// @return Whether the order decreases the liquidity of the market\\n    function decreasesEfficiency(Order memory self, Position memory currentPosition) internal pure returns (bool) {\\n        UFixed6 currentMajor = currentPosition.major();\\n        UFixed6 latestMajor = UFixed6Lib.from(Fixed6Lib.from(currentPosition.long).sub(long(self)))\\n            .max(UFixed6Lib.from(Fixed6Lib.from(currentPosition.short).sub(short(self))));\\n        return !self.makerNeg.isZero() || currentMajor.gt(latestMajor);\\n    }\\n\\n    /// @notice Returns whether the order is applicable for liquidity checks\\n    /// @param self The Order object to check\\n    /// @param marketParameter The market parameter\\n    /// @return Whether the order is applicable for liquidity checks\\n    function liquidityCheckApplicable(\\n        Order memory self,\\n        MarketParameter memory marketParameter\\n    ) internal pure returns (bool) {\\n        return !marketParameter.closed &&\\n        // not \\\"a taker order that is increasing\\\" ->\\n        // not (any of the following)\\n        //  - taker is empty (not a taker order)\\n        //  - taker is increasing (position going more long or short)\\n            ((long(self).isZero() && short(self).isZero()) || increasesTaker(self));\\n    }\\n\\n    /// @notice Returns whether the order is protected\\n    /// @param self The order object to check\\n    /// @return Whether the order is protected\\n    function protected(Order memory self) internal pure returns (bool) {\\n        return self.protection != 0;\\n    }\\n\\n    /// @notice Returns whether the order is empty\\n    /// @param self The order object to check\\n    /// @return Whether the order is empty\\n    function isEmpty(Order memory self) internal pure returns (bool) {\\n        return pos(self).isZero() && neg(self).isZero();\\n    }\\n\\n     /// @notice Returns the direction of the order\\n    /// @dev 0 = maker, 1 = long, 2 = short\\n    /// @param self The position object to check\\n    /// @return The direction of the position\\n    function direction(Order memory self) internal pure returns (uint256) {\\n        if (!self.longPos.isZero() || !self.longNeg.isZero()) return 1;\\n        if (!self.shortPos.isZero() || !self.shortNeg.isZero()) return 2;\\n\\n        return 0;\\n    }\\n\\n    /// @notice Returns the magnitude of the order\\n    /// @param self The order object to check\\n    /// @return The magnitude of the order\\n    function magnitude(Order memory self) internal pure returns (Fixed6) {\\n        return maker(self).add(long(self)).add(short(self));\\n    }\\n\\n    /// @notice Returns the maker delta of the order\\n    /// @param self The order object to check\\n    /// @return The maker delta of the order\\n    function maker(Order memory self) internal pure returns (Fixed6) {\\n        return Fixed6Lib.from(self.makerPos).sub(Fixed6Lib.from(self.makerNeg));\\n    }\\n\\n    /// @notice Returns the long delta of the order\\n    /// @param self The order object to check\\n    /// @return The long delta of the order\\n    function long(Order memory self) internal pure returns (Fixed6) {\\n        return Fixed6Lib.from(self.longPos).sub(Fixed6Lib.from(self.longNeg));\\n    }\\n\\n    /// @notice Returns the short delta of the order\\n    /// @param self The order object to check\\n    /// @return The short delta of the order\\n    function short(Order memory self) internal pure returns (Fixed6) {\\n        return Fixed6Lib.from(self.shortPos).sub(Fixed6Lib.from(self.shortNeg));\\n    }\\n\\n    /// @notice Returns the positive taker delta of the order\\n    /// @param self The order object to check\\n    /// @return The positive taker delta of the order\\n    function takerPos(Order memory self) internal pure returns (UFixed6) {\\n        return self.longPos.add(self.shortNeg);\\n    }\\n\\n    /// @notice Returns the negative taker delta of the order\\n    /// @param self The order object to check\\n    /// @return The negative taker delta of the order\\n    function takerNeg(Order memory self) internal pure returns (UFixed6) {\\n        return self.shortPos.add(self.longNeg);\\n    }\\n\\n    /// @notice Returns the total maker delta of the order\\n    /// @param self The order object to check\\n    /// @return The total maker delta of the order\\n    function makerTotal(Order memory self) internal pure returns (UFixed6) {\\n        return self.makerPos.add(self.makerNeg);\\n    }\\n\\n    /// @notice Returns the total taker delta of the order\\n    /// @param self The order object to check\\n    /// @return The total taker delta of the order\\n    function takerTotal(Order memory self) internal pure returns (UFixed6) {\\n        return self.takerPos().add(self.takerNeg());\\n    }\\n\\n    /// @notice Returns the positive delta of the order\\n    /// @param self The order object to check\\n    /// @return The positive delta of the order\\n    function pos(Order memory self) internal pure returns (UFixed6) {\\n        return self.makerPos.add(self.longPos).add(self.shortPos);\\n    }\\n\\n    /// @notice Returns the positive delta of the order\\n    /// @param self The order object to check\\n    /// @return The positive delta of the order\\n    function neg(Order memory self) internal pure returns (UFixed6) {\\n        return self.makerNeg.add(self.longNeg).add(self.shortNeg);\\n    }\\n\\n    /// @notice Updates the current global order with a new local order\\n    /// @param self The order object to update\\n    /// @param order The new order\\n    function add(Order memory self, Order memory order) internal pure {\\n        (self.orders, self.collateral, self.protection, self.makerReferral, self.takerReferral) = (\\n            self.orders + order.orders,\\n            self.collateral.add(order.collateral),\\n            self.protection + order.protection,\\n            self.makerReferral.add(order.makerReferral),\\n            self.takerReferral.add(order.takerReferral)\\n        );\\n\\n        (self.makerPos, self.makerNeg, self.longPos, self.longNeg, self.shortPos, self.shortNeg) = (\\n            self.makerPos.add(order.makerPos),\\n            self.makerNeg.add(order.makerNeg),\\n            self.longPos.add(order.longPos),\\n            self.longNeg.add(order.longNeg),\\n            self.shortPos.add(order.shortPos),\\n            self.shortNeg.add(order.shortNeg)\\n        );\\n    }\\n\\n    /// @notice Subtracts the latest local order from current global order\\n    /// @param self The order object to update\\n    /// @param order The latest order\\n    function sub(Order memory self, Order memory order) internal pure {\\n        (self.orders, self.collateral, self.protection, self.makerReferral, self.takerReferral) = (\\n            self.orders - order.orders,\\n            self.collateral.sub(order.collateral),\\n            self.protection - order.protection,\\n            self.makerReferral.sub(order.makerReferral),\\n            self.takerReferral.sub(order.takerReferral)\\n        );\\n\\n        (self.makerPos, self.makerNeg, self.longPos, self.longNeg, self.shortPos, self.shortNeg) = (\\n            self.makerPos.sub(order.makerPos),\\n            self.makerNeg.sub(order.makerNeg),\\n            self.longPos.sub(order.longPos),\\n            self.longNeg.sub(order.longNeg),\\n            self.shortPos.sub(order.shortPos),\\n            self.shortNeg.sub(order.shortNeg)\\n        );\\n    }\\n}\\n\\n/// @dev Manually encodes and decodes the global Order struct into storage.\\n///      (external-safe): this library is safe to externalize\\n///\\n///     struct StoredOrderGlobal {\\n///         /* slot 0 */\\n///         uint32 timestamp;\\n///         uint32 orders;\\n///         int64 collateral;\\n///         uint64 makerPos;\\n///         uint64 makerNeg;\\n///\\n///         /* slot 1 */\\n///         uint64 longPos;\\n///         uint64 longNeg;\\n///         uint64 shortPos;\\n///         uint64 shortNeg;\\n///\\n///         /* slot 2 */\\n///         uint64 takerReferral;\\n///         uint64 makerReferral;\\n///     }\\n///\\nlibrary OrderStorageGlobalLib {\\n    function read(OrderStorageGlobal storage self) internal view returns (Order memory) {\\n        (uint256 slot0, uint256 slot1, uint256 slot2) = (self.slot0, self.slot1, self.slot2);\\n\\n        return Order(\\n            uint256(slot0 << (256 - 32)) >> (256 - 32),\\n            uint256(slot0 << (256 - 32 - 32)) >> (256 - 32),\\n            Fixed6.wrap(int256(slot0 << (256 - 32 - 32 - 64)) >> (256 - 64)),\\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 64 - 64)) >> (256 - 64)),\\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 64 - 64 - 64)) >> (256 - 64)),\\n            UFixed6.wrap(uint256(slot1 << (256 - 64)) >> (256 - 64)),\\n            UFixed6.wrap(uint256(slot1 << (256 - 64 - 64)) >> (256 - 64)),\\n            UFixed6.wrap(uint256(slot1 << (256 - 64 - 64 - 64)) >> (256 - 64)),\\n            UFixed6.wrap(uint256(slot1 << (256 - 64 - 64 - 64 - 64)) >> (256 - 64)),\\n            0,\\n            UFixed6.wrap(uint256(slot2 << (256 - 64)) >> (256 - 64)),\\n            UFixed6.wrap(uint256(slot2 << (256 - 64 - 64)) >> (256 - 64))\\n        );\\n    }\\n\\n    function store(OrderStorageGlobal storage self, Order memory newValue) internal {\\n        OrderStorageLib.validate(newValue);\\n\\n        if (newValue.makerPos.gt(UFixed6.wrap(type(uint64).max))) revert OrderStorageLib.OrderStorageInvalidError();\\n        if (newValue.makerNeg.gt(UFixed6.wrap(type(uint64).max))) revert OrderStorageLib.OrderStorageInvalidError();\\n        if (newValue.longPos.gt(UFixed6.wrap(type(uint64).max))) revert OrderStorageLib.OrderStorageInvalidError();\\n        if (newValue.longNeg.gt(UFixed6.wrap(type(uint64).max))) revert OrderStorageLib.OrderStorageInvalidError();\\n        if (newValue.shortPos.gt(UFixed6.wrap(type(uint64).max))) revert OrderStorageLib.OrderStorageInvalidError();\\n        if (newValue.shortNeg.gt(UFixed6.wrap(type(uint64).max))) revert OrderStorageLib.OrderStorageInvalidError();\\n\\n        uint256 encoded0 =\\n            uint256(newValue.timestamp << (256 - 32)) >> (256 - 32) |\\n            uint256(newValue.orders << (256 - 32)) >> (256 - 32 - 32) |\\n            uint256(Fixed6.unwrap(newValue.collateral) << (256 - 64)) >> (256 - 32 - 32 - 64) |\\n            uint256(UFixed6.unwrap(newValue.makerPos) << (256 - 64)) >> (256 - 32 - 32 - 64 - 64) |\\n            uint256(UFixed6.unwrap(newValue.makerNeg) << (256 - 64)) >> (256 - 32 - 32 - 64 - 64 - 64);\\n        uint256 encoded1 =\\n            uint256(UFixed6.unwrap(newValue.longPos) << (256 - 64)) >> (256 - 64) |\\n            uint256(UFixed6.unwrap(newValue.longNeg) << (256 - 64)) >> (256 - 64 - 64) |\\n            uint256(UFixed6.unwrap(newValue.shortPos) << (256 - 64)) >> (256 - 64 - 64 - 64) |\\n            uint256(UFixed6.unwrap(newValue.shortNeg) << (256 - 64)) >> (256 - 64 - 64 - 64 - 64);\\n        uint256 encoded2 =\\n            uint256(UFixed6.unwrap(newValue.makerReferral) << (256 - 64)) >> (256 - 64) |\\n            uint256(UFixed6.unwrap(newValue.takerReferral) << (256 - 64)) >> (256 - 64 - 64);\\n\\n        assembly {\\n            sstore(self.slot, encoded0)\\n            sstore(add(self.slot, 1), encoded1)\\n            sstore(add(self.slot, 2), encoded2)\\n        }\\n    }\\n}\\n\\n/// @dev Manually encodes and decodes the local Order struct into storage.\\n///\\n///     struct StoredOrderLocal {\\n///         /* slot 0 */\\n///         uint32 timestamp;\\n///         uint32 orders;\\n///         int64 collateral;\\n///         uint2 direction;\\n///         uint62 magnitudePos;\\n///         uint62 magnitudeNeg;\\n///         uint1 protection;\\n///\\n///         /* slot 1 */\\n///         uint64 takerReferral;\\n///         uint64 makerReferral;\\n///     }\\n///\\nlibrary OrderStorageLocalLib {\\n    function read(OrderStorageLocal storage self) internal view returns (Order memory) {\\n        (uint256 slot0, uint256 slot1) = (self.slot0, self.slot1);\\n\\n        uint256 direction = uint256(slot0 << (256 - 32 - 32 - 64 - 2)) >> (256 - 2);\\n        UFixed6 magnitudePos = UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 64 - 2 - 62)) >> (256 - 62));\\n        UFixed6 magnitudeNeg = UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 64 - 2 - 62 - 62)) >> (256 - 62));\\n\\n        return Order(\\n            uint256(slot0 << (256 - 32)) >> (256 - 32),\\n            uint256(slot0 << (256 - 32 - 32)) >> (256 - 32),\\n            Fixed6.wrap(int256(slot0 << (256 - 32 - 32 - 64)) >> (256 - 64)),\\n            direction == 0 ? magnitudePos : UFixed6Lib.ZERO,\\n            direction == 0 ? magnitudeNeg : UFixed6Lib.ZERO,\\n            direction == 1 ? magnitudePos : UFixed6Lib.ZERO,\\n            direction == 1 ? magnitudeNeg : UFixed6Lib.ZERO,\\n            direction == 2 ? magnitudePos : UFixed6Lib.ZERO,\\n            direction == 2 ? magnitudeNeg : UFixed6Lib.ZERO,\\n            uint256(slot0 << (256 - 32 - 32 - 64 - 2 - 62 - 62 - 1)) >> (256 - 1),\\n            UFixed6.wrap(uint256(slot1 << (256 - 64)) >> (256 - 64)),\\n            UFixed6.wrap(uint256(slot1 << (256 - 64 - 64)) >> (256 - 64))\\n        );\\n    }\\n\\n    function store(OrderStorageLocal storage self, Order memory newValue) internal {\\n        OrderStorageLib.validate(newValue);\\n\\n        (UFixed6 magnitudePos, UFixed6 magnitudeNeg) = (newValue.pos(), newValue.neg());\\n\\n        if (magnitudePos.gt(UFixed6.wrap(2 ** 62 - 1))) revert OrderStorageLib.OrderStorageInvalidError();\\n        if (magnitudeNeg.gt(UFixed6.wrap(2 ** 62 - 1))) revert OrderStorageLib.OrderStorageInvalidError();\\n        if (newValue.protection > 1) revert OrderStorageLib.OrderStorageInvalidError();\\n\\n        uint256 encoded0 =\\n            uint256(newValue.timestamp << (256 - 32)) >> (256 - 32) |\\n            uint256(newValue.orders << (256 - 32)) >> (256 - 32 - 32) |\\n            uint256(Fixed6.unwrap(newValue.collateral) << (256 - 64)) >> (256 - 32 - 32 - 64) |\\n            uint256(newValue.direction() << (256 - 2)) >> (256 - 32 - 32 - 64 - 2) |\\n            uint256(UFixed6.unwrap(magnitudePos) << (256 - 62)) >> (256 - 32 - 32 - 64 - 2 - 62) |\\n            uint256(UFixed6.unwrap(magnitudeNeg) << (256 - 62)) >> (256 - 32 - 32 - 64 - 2 - 62 - 62) |\\n            uint256(newValue.protection << (256 - 1)) >> (256 - 32 - 32 - 64 - 2 - 62 - 62 - 1);\\n        uint256 encoded1 =\\n            uint256(UFixed6.unwrap(newValue.makerReferral) << (256 - 64)) >> (256 - 64) |\\n            uint256(UFixed6.unwrap(newValue.takerReferral) << (256 - 64)) >> (256 - 64 - 64);\\n\\n        assembly {\\n            sstore(self.slot, encoded0)\\n            sstore(add(self.slot, 1), encoded1)\\n        }\\n    }\\n}\\n\\nlibrary OrderStorageLib {\\n    // sig: 0x67e45965\\n    error OrderStorageInvalidError();\\n\\n    function validate(Order memory newValue) internal pure {\\n        if (newValue.timestamp > type(uint32).max) revert OrderStorageInvalidError();\\n        if (newValue.orders > type(uint32).max) revert OrderStorageInvalidError();\\n        if (newValue.collateral.gt(Fixed6.wrap(type(int64).max))) revert OrderStorageInvalidError();\\n        if (newValue.collateral.lt(Fixed6.wrap(type(int64).min))) revert OrderStorageInvalidError();\\n        if (newValue.makerReferral.gt(UFixed6.wrap(type(uint64).max))) revert OrderStorageInvalidError();\\n        if (newValue.takerReferral.gt(UFixed6.wrap(type(uint64).max))) revert OrderStorageInvalidError();\\n    }\\n}\",\"keccak256\":\"0x91cd953e4d8fd43f71ca914ae137a844a74bb436b2f2b6d3e2b79200db4ae98e\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2/contracts/types/Position.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"./OracleVersion.sol\\\";\\nimport \\\"./RiskParameter.sol\\\";\\nimport \\\"./Global.sol\\\";\\nimport \\\"./Local.sol\\\";\\nimport \\\"./Order.sol\\\";\\n\\n/// @dev Order type\\nstruct Position {\\n    /// @dev The timestamp of the position\\n    uint256 timestamp;\\n\\n    /// @dev The maker position size\\n    UFixed6 maker;\\n\\n    /// @dev The long position size\\n    UFixed6 long;\\n\\n    /// @dev The short position size\\n    UFixed6 short;\\n}\\nusing PositionLib for Position global;\\nstruct PositionStorageGlobal { uint256 slot0; uint256 slot1; } // SECURITY: must remain at (2) slots\\nusing PositionStorageGlobalLib for PositionStorageGlobal global;\\nstruct PositionStorageLocal { uint256 slot0; uint256 slot1; } // SECURITY: must remain at (2) slots\\nusing PositionStorageLocalLib for PositionStorageLocal global;\\n\\n/// @title Position\\n/// @dev (external-unsafe): this library must be used internally only\\n/// @notice Holds the state for a position\\nlibrary PositionLib {\\n    /// @notice Returns a cloned copy of the position\\n    /// @param self The position object to clone\\n    /// @return A cloned copy of the position\\n    function clone(Position memory self) internal pure returns (Position memory) {\\n        return Position(self.timestamp, self.maker, self.long, self.short);\\n    }\\n\\n    /// @notice Updates the position with a new order\\n    /// @param self The position object to update\\n    /// @param order The new order\\n    function update(Position memory self, Order memory order) internal pure {\\n        self.timestamp = order.timestamp;\\n\\n        (self.maker, self.long, self.short) = (\\n            UFixed6Lib.from(Fixed6Lib.from(self.maker).add(order.maker())),\\n            UFixed6Lib.from(Fixed6Lib.from(self.long).add(order.long())),\\n            UFixed6Lib.from(Fixed6Lib.from(self.short).add(order.short()))\\n        );\\n    }\\n\\n    /// @notice Returns the direction of the position\\n    /// @dev 0 = maker, 1 = long, 2 = short\\n    /// @param self The position object to check\\n    /// @return The direction of the position\\n    function direction(Position memory self) internal pure returns (uint256) {\\n        return self.long.isZero() ? (self.short.isZero() ? 0 : 2) : 1;\\n    }\\n\\n    /// @notice Returns the maximum position size\\n    /// @param self The position object to check\\n    /// @return The maximum position size\\n    function magnitude(Position memory self) internal pure returns (UFixed6) {\\n        return self.long.max(self.short).max(self.maker);\\n    }\\n\\n    /// @notice Returns the maximum taker position size\\n    /// @param self The position object to check\\n    /// @return The maximum taker position size\\n    function major(Position memory self) internal pure returns (UFixed6) {\\n        return self.long.max(self.short);\\n    }\\n\\n    /// @notice Returns the minimum maker position size\\n    /// @param self The position object to check\\n    /// @return The minimum maker position size\\n    function minor(Position memory self) internal pure returns (UFixed6) {\\n        return self.long.min(self.short);\\n    }\\n\\n    /// @notice Returns the skew of the position\\n    /// @param self The position object to check\\n    /// @return The skew of the position\\n    function skew(Position memory self) internal pure returns (Fixed6) {\\n        return Fixed6Lib.from(self.long).sub(Fixed6Lib.from(self.short));\\n    }\\n\\n    /// @notice Returns the utilization of the position\\n    /// @dev utilization = major / (maker + minor)\\n    /// @param self The position object to check\\n    /// @param riskParameter The current risk parameter\\n    /// @return The utilization of the position\\n    function utilization(Position memory self, RiskParameter memory riskParameter) internal pure returns (UFixed6) {\\n        // long-short net utilization of the maker position\\n        UFixed6 netUtilization = major(self).unsafeDiv(self.maker.add(minor(self)));\\n\\n        // efficiency limit utilization of the maker position\\n        UFixed6 efficiencyUtilization = major(self).mul(riskParameter.efficiencyLimit).unsafeDiv(self.maker);\\n\\n        // maximum of the two utilizations, capped at 100%\\n        return netUtilization.max(efficiencyUtilization).min(UFixed6Lib.ONE);\\n    }\\n\\n    /// @notice Returns the portion of the position that is covered by the maker\\n    /// @param self The position object to check\\n    /// @return The portion of the position that is covered by the maker\\n    function socializedMakerPortion(Position memory self) internal pure returns (UFixed6) {\\n        return takerSocialized(self).isZero() ?\\n            UFixed6Lib.ZERO :\\n            takerSocialized(self).sub(minor(self)).div(takerSocialized(self));\\n    }\\n\\n    /// @notice Returns the long position with socialization taken into account\\n    /// @param self The position object to check\\n    /// @return The long position with socialization taken into account\\n    function longSocialized(Position memory self) internal pure returns (UFixed6) {\\n        return self.maker.add(self.short).min(self.long);\\n    }\\n\\n    /// @notice Returns the short position with socialization taken into account\\n    /// @param self The position object to check\\n    /// @return The short position with socialization taken into account\\n    function shortSocialized(Position memory self) internal pure returns (UFixed6) {\\n        return self.maker.add(self.long).min(self.short);\\n    }\\n\\n    /// @notice Returns the major position with socialization taken into account\\n    /// @param self The position object to check\\n    /// @return The major position with socialization taken into account\\n    function takerSocialized(Position memory self) internal pure returns (UFixed6) {\\n        return major(self).min(minor(self).add(self.maker));\\n    }\\n\\n    /// @notice Returns the efficiency of the position\\n    /// @dev efficiency = maker / major\\n    /// @param self The position object to check\\n    /// @return The efficiency of the position\\n    function efficiency(Position memory self) internal pure returns (UFixed6) {\\n        return self.maker.unsafeDiv(major(self)).min(UFixed6Lib.ONE);\\n    }\\n\\n    /// @notice Returns the whether the position is socialized\\n    /// @param self The position object to check\\n    /// @return Whether the position is socialized\\n    function socialized(Position memory self) internal pure returns (bool) {\\n        return self.maker.add(self.short).lt(self.long) || self.maker.add(self.long).lt(self.short);\\n    }\\n\\n    /// @notice Returns the whether the position is single-sided\\n    /// @param self The position object to check\\n    /// @return Whether the position is single-sided\\n    function singleSided(Position memory self) internal pure returns (bool) {\\n        return magnitude(self).eq(self.long.add(self.short).add(self.maker));\\n    }\\n\\n    /// @notice Returns the whether the position is empty\\n    /// @param self The position object to check\\n    /// @return Whether the position is empty\\n    function empty(Position memory self) internal pure returns (bool) {\\n        return magnitude(self).isZero();\\n    }\\n\\n    /// @notice Returns the maintenance requirement of the position\\n    /// @param positionMagnitude The position magnitude value to check\\n    /// @param latestVersion The latest oracle version\\n    /// @param riskParameter The current risk parameter\\n    /// @return The maintenance requirement of the position\\n    function maintenance(\\n        UFixed6 positionMagnitude,\\n        OracleVersion memory latestVersion,\\n        RiskParameter memory riskParameter\\n    ) internal pure returns (UFixed6) {\\n        return _collateralRequirement(positionMagnitude, latestVersion, riskParameter.maintenance, riskParameter.minMaintenance);\\n    }\\n\\n    /// @notice Returns the margin requirement of the position\\n    /// @param positionMagnitude The position magnitude value to check\\n    /// @param latestVersion The latest oracle version\\n    /// @param riskParameter The current risk parameter\\n    /// @param collateralization The collateralization requirement override provided by the caller\\n    /// @return The margin requirement of the position\\n    function margin(\\n        UFixed6 positionMagnitude,\\n        OracleVersion memory latestVersion,\\n        RiskParameter memory riskParameter,\\n        UFixed6 collateralization\\n    ) internal pure returns (UFixed6) {\\n        return _collateralRequirement(positionMagnitude, latestVersion, riskParameter.margin.max(collateralization), riskParameter.minMargin);\\n    }\\n\\n    /// @notice Returns the maintenance requirement of the position\\n    /// @param self The position object to check\\n    /// @param latestVersion The latest oracle version\\n    /// @param riskParameter The current risk parameter\\n    /// @return The maintenance requirement of the position\\n    function maintenance(\\n        Position memory self,\\n        OracleVersion memory latestVersion,\\n        RiskParameter memory riskParameter\\n    ) internal pure returns (UFixed6) {\\n        return maintenance(magnitude(self), latestVersion, riskParameter);\\n    }\\n\\n    /// @notice Returns the margin requirement of the position\\n    /// @param self The position object to check\\n    /// @param latestVersion The latest oracle version\\n    /// @param riskParameter The current risk parameter\\n    /// @return The margin requirement of the position\\n    function margin(\\n        Position memory self,\\n        OracleVersion memory latestVersion,\\n        RiskParameter memory riskParameter\\n    ) internal pure returns (UFixed6) {\\n        return margin(magnitude(self), latestVersion, riskParameter, UFixed6Lib.ZERO);\\n    }\\n\\n    /// @notice Returns the collateral requirement of the position magnitude\\n    /// @param positionMagnitude The position magnitude value to check\\n    /// @param latestVersion The latest oracle version\\n    /// @param requirementRatio The ratio requirement to the notional\\n    /// @param requirementFixed The fixed requirement\\n    /// @return The collateral requirement of the position magnitude\\n    function _collateralRequirement(\\n        UFixed6 positionMagnitude,\\n        OracleVersion memory latestVersion,\\n        UFixed6 requirementRatio,\\n        UFixed6 requirementFixed\\n    ) private pure returns (UFixed6) {\\n        if (positionMagnitude.isZero()) return UFixed6Lib.ZERO;\\n        return positionMagnitude.mul(latestVersion.price.abs()).mul(requirementRatio).max(requirementFixed);\\n    }\\n\\n    /// @notice Returns the whether the position is maintained\\n    /// @dev shortfall is considered solvent for 0-position\\n    /// @param positionMagnitude The position magnitude value to check\\n    /// @param latestVersion The latest oracle version\\n    /// @param riskParameter The current risk parameter\\n    /// @param collateral The current account's collateral\\n    /// @return Whether the position is maintained\\n    function maintained(\\n        UFixed6 positionMagnitude,\\n        OracleVersion memory latestVersion,\\n        RiskParameter memory riskParameter,\\n        Fixed6 collateral\\n    ) internal pure returns (bool) {\\n        return UFixed6Lib.unsafeFrom(collateral).gte(maintenance(positionMagnitude, latestVersion, riskParameter));\\n    }\\n\\n    /// @notice Returns the whether the position is margined\\n    /// @dev shortfall is considered solvent for 0-position\\n    /// @param positionMagnitude The position magnitude value to check\\n    /// @param latestVersion The latest oracle version\\n    /// @param riskParameter The current risk parameter\\n    /// @param collateralization The collateralization requirement override provided by the caller\\n    /// @param collateral The current account's collateral\\n    /// @return Whether the position is margined\\n    function margined(\\n        UFixed6 positionMagnitude,\\n        OracleVersion memory latestVersion,\\n        RiskParameter memory riskParameter,\\n        UFixed6 collateralization,\\n        Fixed6 collateral\\n    ) internal pure returns (bool) {\\n        return UFixed6Lib.unsafeFrom(collateral).gte(margin(positionMagnitude, latestVersion, riskParameter, collateralization));\\n    }\\n\\n    /// @notice Returns the whether the position is maintained\\n    /// @dev shortfall is considered solvent for 0-position\\n    /// @param self The position object to check\\n    /// @param latestVersion The latest oracle version\\n    /// @param riskParameter The current risk parameter\\n    /// @param collateral The current account's collateral\\n    /// @return Whether the position is maintained\\n    function maintained(\\n        Position memory self,\\n        OracleVersion memory latestVersion,\\n        RiskParameter memory riskParameter,\\n        Fixed6 collateral\\n    ) internal pure returns (bool) {\\n        return maintained(magnitude(self), latestVersion, riskParameter, collateral);\\n    }\\n\\n    /// @notice Returns the whether the position is margined\\n    /// @dev shortfall is considered solvent for 0-position\\n    /// @param self The position object to check\\n    /// @param latestVersion The latest oracle version\\n    /// @param riskParameter The current risk parameter\\n    /// @param collateralization The collateralization requirement override provided by the caller\\n    /// @param collateral The current account's collateral\\n    /// @return Whether the position is margined\\n    function margined(\\n        Position memory self,\\n        OracleVersion memory latestVersion,\\n        RiskParameter memory riskParameter,\\n        UFixed6 collateralization,\\n        Fixed6 collateral\\n    ) internal pure returns (bool) {\\n        return margined(magnitude(self), latestVersion, riskParameter, collateralization, collateral);\\n    }\\n}\\n\\n/// @dev Manually encodes and decodes the global Position struct into storage.\\n///      (external-safe): this library is safe to externalize\\n///\\n///     struct StoredPositionGlobal {\\n///         /* slot 0 */\\n///         uint32 timestamp;\\n///         uint32 __unallocated__;\\n///         uint64 maker;\\n///         uint64 long;\\n///         uint64 short;\\n///\\n///         /* slot 1 */\\n///         uint64 maker (deprecated);\\n///         uint192 __unallocated__;\\n///     }\\n///\\nlibrary PositionStorageGlobalLib {\\n    function read(PositionStorageGlobal storage self) internal view returns (Position memory) {\\n        uint256 slot0 = self.slot0;\\n        return Position(\\n            uint256(slot0 << (256 - 32)) >> (256 - 32),\\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 64)) >> (256 - 64)),\\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 64 - 64)) >> (256 - 64)),\\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 64 - 64 - 64)) >> (256 - 64))\\n        );\\n    }\\n\\n    function store(PositionStorageGlobal storage self, Position memory newValue) public {\\n        PositionStorageLib.validate(newValue);\\n\\n        if (newValue.maker.gt(UFixed6.wrap(type(uint64).max))) revert PositionStorageLib.PositionStorageInvalidError();\\n        if (newValue.long.gt(UFixed6.wrap(type(uint64).max))) revert PositionStorageLib.PositionStorageInvalidError();\\n        if (newValue.short.gt(UFixed6.wrap(type(uint64).max))) revert PositionStorageLib.PositionStorageInvalidError();\\n\\n        uint256 encoded0 =\\n            uint256(newValue.timestamp << (256 - 32)) >> (256 - 32) |\\n            uint256(UFixed6.unwrap(newValue.maker) << (256 - 64)) >> (256 - 32 - 32 - 64) |\\n            uint256(UFixed6.unwrap(newValue.long) << (256 - 64)) >> (256 - 32 - 32 - 64 - 64) |\\n            uint256(UFixed6.unwrap(newValue.short) << (256 - 64)) >> (256 - 32 - 32 - 64 - 64 - 64);\\n\\n        assembly {\\n            sstore(self.slot, encoded0)\\n        }\\n    }\\n\\n    function migrate(PositionStorageGlobal storage self) external {\\n        Position memory position = read(self);\\n        uint256 slot1 = self.slot1;\\n        UFixed6 deprecatedMaker = UFixed6.wrap(uint256(slot1 << (256 - 64)) >> (256 - 64));\\n\\n        // only migrate if the deprecated maker is set and new maker is unset to avoid double-migration\\n        if (!position.maker.isZero())\\n            revert PositionStorageLib.PositionStorageInvalidMigrationError();\\n\\n        position.maker = deprecatedMaker;\\n        store(self, position);\\n        assembly {\\n            sstore(add(self.slot, 1), 0) // Part of the v2.3 migration. Can be removed once migration is complete.\\n        }\\n    }\\n}\\n\\n/// @dev Manually encodes and decodes the local Position struct into storage.\\n///      (external-safe): this library is safe to externalize\\n///\\n///     struct StoredPositionLocal (v0) {\\n///         /* slot 0 */\\n///         uint32 timestamp;\\n///         uint216 __unallocated__;\\n///         uint8 layout;\\n///\\n///         /* slot 1 */\\n///         uint2 direction;\\n///         uint62 magnitude;\\n///         uint192 __unallocated__;\\n///     }\\n///\\n///     note: fresh Positions will still default to v0 until they are saved to, but this is safe because\\n///           slot1 is still reserved and will return correct default values.\\n///\\n///     struct StoredPositionLocal (v1) {\\n///         /* slot 0 */\\n///         uint32 timestamp;\\n///         uint2 direction;\\n///         uint62 magnitude;\\n///         uint152 __unallocated__;\\n///         uint8 layout; // v2.3 migration -- can remove once all accounts have been migrated\\n///     }\\n///\\nlibrary PositionStorageLocalLib {\\n    function read(PositionStorageLocal storage self) internal view returns (Position memory) {\\n        (uint256 slot0, uint256 slot1) = (self.slot0, self.slot1);\\n        uint256 layout = uint256(slot0 << (256 - 32 - 216 - 8)) >> (256 - 8);\\n\\n        uint256 direction = layout == 0 ?\\n            uint256(slot1 << (256 - 2)) >> (256 - 2) :\\n            uint256(slot0 << (256 - 32 - 2)) >> (256 - 2);\\n        UFixed6 magnitude = layout == 0 ?\\n            UFixed6.wrap(uint256(slot1 << (256 - 2 - 62)) >> (256 - 62)) :\\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 2 - 62)) >> (256 - 62));\\n\\n        return Position(\\n            uint256(slot0 << (256 - 32)) >> (256 - 32),\\n            direction == 0 ? magnitude : UFixed6Lib.ZERO,\\n            direction == 1 ? magnitude : UFixed6Lib.ZERO,\\n            direction == 2 ? magnitude : UFixed6Lib.ZERO\\n        );\\n    }\\n\\n    function store(PositionStorageLocal storage self, Position memory newValue) external {\\n        PositionStorageLib.validate(newValue);\\n\\n        uint256 layout = 1;\\n        UFixed6 magnitude = newValue.magnitude();\\n\\n        if (magnitude.gt(UFixed6.wrap(2 ** 62 - 1))) revert PositionStorageLib.PositionStorageInvalidError();\\n\\n        uint256 encoded0 =\\n            uint256(newValue.timestamp << (256 - 32)) >> (256 - 32) |\\n            uint256(newValue.direction() << (256 - 2)) >> (256 - 32 - 2) |\\n            uint256(UFixed6.unwrap(magnitude) << (256 - 62)) >> (256 - 32 - 2 - 62) |\\n            uint256(layout << (256 - 8)) >> (256 - 32 - 2 - 62 - 152 - 8);\\n\\n        assembly {\\n            sstore(self.slot, encoded0)\\n            sstore(add(self.slot, 1), 0) // Part of the v2.3 migration. Can be removed once migration is complete.\\n        }\\n    }\\n}\\n\\nlibrary PositionStorageLib {\\n    // sig: 0x52a8a97f\\n    error PositionStorageInvalidError();\\n    // sig: 0x1bacb3a2\\n    error PositionStorageInvalidMigrationError();\\n\\n    function validate(Position memory newValue) internal pure {\\n        if (newValue.timestamp > type(uint32).max) revert PositionStorageInvalidError();\\n    }\\n}\",\"keccak256\":\"0x36ed4d9bfacef9ebe8e1ef2dd398d66d820b06df563751f2a759626bbc8e27b2\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2/contracts/types/ProtocolParameter.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@equilibria/root/number/types/UFixed6.sol\\\";\\n\\n/// @dev ProtocolParameter type\\nstruct ProtocolParameter {\\n    /// @dev The maximum for market fee parameters\\n    UFixed6 maxFee;\\n\\n    /// @dev The maximum for market absolute fee parameters\\n    UFixed6 maxFeeAbsolute;\\n\\n    /// @dev The maximum for market cut parameters\\n    UFixed6 maxCut;\\n\\n    /// @dev The maximum for market rate parameters\\n    UFixed6 maxRate;\\n\\n    /// @dev The minimum for market maintenance parameters\\n    UFixed6 minMaintenance;\\n\\n    /// @dev The minimum for market efficiency parameters\\n    UFixed6 minEfficiency;\\n\\n    /// @dev The default referrer fee percentage for orders\\n    UFixed6 referralFee;\\n\\n    /// @dev The minimum ratio between scale vs makerLimit / efficiencyLimit\\n    UFixed6 minScale;\\n}\\nstruct StoredProtocolParameter {\\n    /* slot 0 (28) */\\n    uint24 maxFee;                  // <= 1677%\\n    uint48 maxFeeAbsolute;          // <= 281m\\n    uint24 maxCut;                  // <= 1677%\\n    uint32 maxRate;                 // <= 214748% (capped at 31 bits to accommodate int32 rates)\\n    uint24 minMaintenance;          // <= 1677%\\n    uint24 minEfficiency;           // <= 1677%\\n    uint24 referralFee;             // <= 1677%\\n    uint24 minScale;                // <= 1677%\\n}\\nstruct ProtocolParameterStorage { StoredProtocolParameter value; } // SECURITY: must remain at (1) slots\\nusing ProtocolParameterStorageLib for ProtocolParameterStorage global;\\n\\n/// @dev (external-safe): this library is safe to externalize\\nlibrary ProtocolParameterStorageLib {\\n    // sig: 0x4dc1bc59\\n    error ProtocolParameterStorageInvalidError();\\n\\n    function read(ProtocolParameterStorage storage self) internal view returns (ProtocolParameter memory) {\\n        StoredProtocolParameter memory value = self.value;\\n        return ProtocolParameter(\\n            UFixed6.wrap(uint256(value.maxFee)),\\n            UFixed6.wrap(uint256(value.maxFeeAbsolute)),\\n            UFixed6.wrap(uint256(value.maxCut)),\\n            UFixed6.wrap(uint256(value.maxRate)),\\n            UFixed6.wrap(uint256(value.minMaintenance)),\\n            UFixed6.wrap(uint256(value.minEfficiency)),\\n            UFixed6.wrap(uint256(value.referralFee)),\\n            UFixed6.wrap(uint256(value.minScale))\\n        );\\n    }\\n\\n    function validate(ProtocolParameter memory self) internal pure {\\n        if (self.maxCut.gt(UFixed6Lib.ONE)) revert ProtocolParameterStorageInvalidError();\\n        if (self.referralFee.gt(UFixed6Lib.ONE)) revert ProtocolParameterStorageInvalidError();\\n        if (self.minScale.gt(UFixed6Lib.ONE)) revert ProtocolParameterStorageInvalidError();\\n    }\\n\\n    function validateAndStore(ProtocolParameterStorage storage self, ProtocolParameter memory newValue) internal {\\n        validate(newValue);\\n\\n        if (newValue.maxFee.gt(UFixed6.wrap(type(uint24).max))) revert ProtocolParameterStorageInvalidError();\\n        if (newValue.maxFeeAbsolute.gt(UFixed6.wrap(type(uint48).max))) revert ProtocolParameterStorageInvalidError();\\n        if (newValue.maxRate.gt(UFixed6.wrap(type(uint32).max / 2))) revert ProtocolParameterStorageInvalidError();\\n        if (newValue.minMaintenance.gt(UFixed6.wrap(type(uint24).max))) revert ProtocolParameterStorageInvalidError();\\n        if (newValue.minEfficiency.gt(UFixed6.wrap(type(uint24).max))) revert ProtocolParameterStorageInvalidError();\\n\\n        self.value = StoredProtocolParameter(\\n            uint24(UFixed6.unwrap(newValue.maxFee)),\\n            uint48(UFixed6.unwrap(newValue.maxFeeAbsolute)),\\n            uint24(UFixed6.unwrap(newValue.maxCut)),\\n            uint32(UFixed6.unwrap(newValue.maxRate)),\\n            uint24(UFixed6.unwrap(newValue.minMaintenance)),\\n            uint24(UFixed6.unwrap(newValue.minEfficiency)),\\n            uint24(UFixed6.unwrap(newValue.referralFee)),\\n            uint24(UFixed6.unwrap(newValue.minScale))\\n        );\\n    }\\n}\",\"keccak256\":\"0x5579346699f5dbf17553654cd03ed38e6f4503452120c2afe2998354a17c002e\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2/contracts/types/RiskParameter.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@equilibria/root/number/types/UFixed6.sol\\\";\\nimport \\\"@equilibria/root/utilization/types/UJumpRateUtilizationCurve6.sol\\\";\\nimport \\\"@equilibria/root/pid/types/PController6.sol\\\";\\nimport \\\"@equilibria/root/adiabatic/types/LinearAdiabatic6.sol\\\";\\nimport \\\"@equilibria/root/adiabatic/types/NoopAdiabatic6.sol\\\";\\nimport \\\"../interfaces/IOracleProvider.sol\\\";\\nimport \\\"./ProtocolParameter.sol\\\";\\n\\n/// @dev RiskParameter type\\nstruct RiskParameter {\\n    /// @dev The minimum amount of collateral required to open a new position as a percentage of notional\\n    UFixed6 margin;\\n\\n    /// @dev The minimum amount of collateral that must be maintained as a percentage of notional\\n    UFixed6 maintenance;\\n\\n    /// @dev The taker impact fee\\n    LinearAdiabatic6 takerFee;\\n\\n    /// @dev The maker fee configuration\\n    NoopAdiabatic6 makerFee;\\n\\n    /// @dev The maximum amount of maker positions that opened\\n    UFixed6 makerLimit;\\n\\n    /// @dev The minimum limit of the efficiency metric\\n    UFixed6 efficiencyLimit;\\n\\n    /// @dev The percentage fee on the notional that is charged when a position is liquidated\\n    UFixed6 liquidationFee;\\n\\n    /// @dev The utilization curve that is used to compute maker interest\\n    UJumpRateUtilizationCurve6 utilizationCurve;\\n\\n    /// @dev The p controller that is used to compute long-short funding\\n    PController6 pController;\\n\\n    /// @dev The minimum fixed amount that is required to open a position\\n    UFixed6 minMargin;\\n\\n    /// @dev The minimum fixed amount that is required for maintenance\\n    UFixed6 minMaintenance;\\n\\n    /// @dev The maximum amount of time since the latest oracle version that update may still be called\\n    uint256 staleAfter;\\n\\n    /// @dev Whether or not the maker should always receive positive funding\\n    bool makerReceiveOnly;\\n}\\nstruct RiskParameterStorage { uint256 slot0; uint256 slot1; uint256 slot2; } // SECURITY: must remain at (3) slots\\nusing RiskParameterStorageLib for RiskParameterStorage global;\\n\\n/// @dev Manually encodes and decodes the local Position struct into storage.\\n///      (external-safe): this library is safe to externalize\\n///\\n///    struct StoredRiskParameter {\\n///        /* slot 0 */ (30)\\n///        uint24 margin;                              // <= 1677%\\n///        uint24 maintenance;                         // <= 1677%\\n///        uint24 takerLinearFee;                      // <= 1677%\\n///        uint24 takerProportionalFee;                // <= 1677%\\n///        uint24 takerAdiabaticFee;                   // <= 1677% (must maintain location due to updateRiskParameter)\\n///        uint24 makerLinearFee;                      // <= 1677%\\n///        uint24 makerProportionalFee;                // <= 1677%\\n///        uint48 makerLimit;                          // <= 281t (no decimals)\\n///        uint24 efficiencyLimit;                     // <= 1677%\\n///\\n///        /* slot 1 */ (28)\\n///        bytes3 __unallocated__;\\n///        uint48 takerSkewScale;                      // <= 281t (no decimals) (must maintain location due to updateRiskParameter)\\n///        uint24 utilizationCurveMinRate;             // <= 1677%\\n///        uint24 utilizationCurveMaxRate;             // <= 1677%\\n///        uint24 utilizationCurveTargetRate;          // <= 1677%\\n///        uint24 utilizationCurveTargetUtilization;   // <= 1677%\\n///        int32 pControllerMin;                       // <= 214748%\\n///\\n///        /* slot 2 */ (32)\\n///        uint48 pControllerK;                        // <= 281m\\n///        int32 pControllerMax;                       // <= 214748%\\n///        uint48 minMargin;                           // <= 281m\\n///        uint48 minMaintenance;                      // <= 281m\\n///        uint48 liquidationFee;                      // <= 281m\\n///        uint24 staleAfter;                          // <= 16m s\\n///        bool makerReceiveOnly;\\n///    }\\nlibrary RiskParameterStorageLib {\\n    // sig: 0x7ecd083f\\n    error RiskParameterStorageInvalidError();\\n\\n    function read(RiskParameterStorage storage self) internal view returns (RiskParameter memory) {\\n        (uint256 slot0, uint256 slot1, uint256 slot2) = (self.slot0, self.slot1, self.slot2);\\n        return RiskParameter(\\n            UFixed6.wrap(uint256(       slot0 << (256 - 24)) >> (256 - 24)),\\n            UFixed6.wrap(uint256(       slot0 << (256 - 24 - 24)) >> (256 - 24)),\\n            LinearAdiabatic6(\\n                UFixed6.wrap(uint256(   slot0 << (256 - 24 - 24 - 24)) >> (256 - 24)),\\n                UFixed6.wrap(uint256(   slot0 << (256 - 24 - 24 - 24 - 24)) >> (256 - 24)),\\n                UFixed6.wrap(uint256(   slot0 << (256 - 24 - 24 - 24 - 24 - 24)) >> (256 - 24)),\\n                UFixed6Lib.from(uint256(slot1 << (256 - 24 - 48 - 48)) >> (256 - 48))\\n            ),\\n            NoopAdiabatic6(\\n                UFixed6.wrap(uint256(   slot0 << (256 - 24 - 24 - 24 - 24 - 24 - 24)) >> (256 - 24)),\\n                UFixed6.wrap(uint256(   slot0 << (256 - 24 - 24 - 24 - 24 - 24 - 24 - 24)) >> (256 - 24)),\\n                UFixed6Lib.from(uint256(slot1 << (256 - 24 - 48)) >> (256 - 48))\\n            ),\\n            UFixed6Lib.from(uint256(    slot0 << (256 - 24 - 24 - 24 - 24 - 24 - 24 - 24 - 48)) >> (256 - 48)),\\n            UFixed6.wrap(uint256(       slot0 << (256 - 24 - 24 - 24 - 24 - 24 - 24 - 24 - 48 - 24)) >> (256 - 24)),\\n\\n            UFixed6.wrap(uint256(       slot2 << (256 - 48 - 32 - 48 - 48 - 48)) >> (256 - 48)),\\n            UJumpRateUtilizationCurve6(\\n                UFixed6.wrap(uint256(   slot1 << (256 - 24 - 48 - 48 - 24)) >> (256 - 24)),\\n                UFixed6.wrap(uint256(   slot1 << (256 - 24 - 48 - 48 - 24 - 24)) >> (256 - 24)),\\n                UFixed6.wrap(uint256(   slot1 << (256 - 24 - 48 - 48 - 24 - 24 - 24)) >> (256 - 24)),\\n                UFixed6.wrap(uint256(   slot1 << (256 - 24 - 48 - 48 - 24 - 24 - 24 - 24)) >> (256 - 24))\\n            ),\\n\\n            PController6(\\n                UFixed6.wrap(uint256(   slot2 << (256 - 48)) >> (256 - 48)),\\n                Fixed6.wrap(int256(     slot1 << (256 - 24 - 48 - 48 - 24 - 24 - 24 - 24 - 32)) >> (256 - 32)),\\n                Fixed6.wrap(int256(     slot2 << (256 - 48 - 32)) >> (256 - 32))\\n            ),\\n            UFixed6.wrap(uint256(       slot2 << (256 - 48 - 32 - 48)) >> (256 - 48)),\\n            UFixed6.wrap(uint256(       slot2 << (256 - 48 - 32 - 48 - 48)) >> (256 - 48)),\\n                         uint256(       slot2 << (256 - 48 - 32 - 48 - 48 - 48 - 24)) >> (256 - 24),\\n            0 !=        (uint256(       slot2 << (256 - 48 - 32 - 48 - 48 - 48 - 24 - 8)) >> (256 - 8))\\n        );\\n    }\\n\\n    function validate(RiskParameter memory self, ProtocolParameter memory protocolParameter) private pure {\\n        if (\\n            self.takerFee.linearFee.max(self.takerFee.proportionalFee).max(self.takerFee.adiabaticFee)\\n                .max(self.makerFee.linearFee).max(self.makerFee.proportionalFee)\\n                .gt(protocolParameter.maxFee)\\n        ) revert RiskParameterStorageInvalidError();\\n\\n        if (self.liquidationFee.gt(protocolParameter.maxFeeAbsolute)) revert RiskParameterStorageInvalidError();\\n\\n        if (\\n            self.utilizationCurve.minRate.max(self.utilizationCurve.maxRate).max(self.utilizationCurve.targetRate)\\n                .max(self.pController.max.abs()).max(self.pController.min.abs())\\n                .gt(protocolParameter.maxRate)\\n        ) revert RiskParameterStorageInvalidError();\\n\\n        if (self.maintenance.lt(protocolParameter.minMaintenance)) revert RiskParameterStorageInvalidError();\\n\\n        if (self.margin.lt(self.maintenance)) revert RiskParameterStorageInvalidError();\\n\\n        if (self.efficiencyLimit.lt(protocolParameter.minEfficiency)) revert RiskParameterStorageInvalidError();\\n\\n        if (self.utilizationCurve.targetUtilization.gt(UFixed6Lib.ONE)) revert RiskParameterStorageInvalidError();\\n\\n        if (self.minMaintenance.lt(self.liquidationFee)) revert RiskParameterStorageInvalidError();\\n\\n        if (self.minMargin.lt(self.minMaintenance)) revert RiskParameterStorageInvalidError();\\n\\n        UFixed6 scaleLimit = self.makerLimit.div(self.efficiencyLimit).mul(protocolParameter.minScale);\\n        if (self.takerFee.scale.lt(scaleLimit) || self.makerFee.scale.lt(scaleLimit))\\n            revert RiskParameterStorageInvalidError();\\n    }\\n\\n    function validateAndStore(\\n        RiskParameterStorage storage self,\\n        RiskParameter memory newValue,\\n        ProtocolParameter memory protocolParameter\\n    ) external {\\n        validate(newValue, protocolParameter);\\n\\n        if (newValue.margin.gt(UFixed6.wrap(type(uint24).max))) revert RiskParameterStorageInvalidError();\\n        if (newValue.minMargin.gt(UFixed6.wrap(type(uint48).max))) revert RiskParameterStorageInvalidError();\\n        if (newValue.efficiencyLimit.gt(UFixed6.wrap(type(uint24).max))) revert RiskParameterStorageInvalidError();\\n        if (newValue.makerLimit.gt(UFixed6Lib.from(type(uint48).max))) revert RiskParameterStorageInvalidError();\\n        if (newValue.pController.k.gt(UFixed6.wrap(type(uint48).max))) revert RiskParameterStorageInvalidError();\\n        if (newValue.takerFee.scale.gt(UFixed6Lib.from(type(uint48).max))) revert RiskParameterStorageInvalidError();\\n        if (newValue.makerFee.scale.gt(UFixed6Lib.from(type(uint48).max))) revert RiskParameterStorageInvalidError();\\n        if (newValue.staleAfter > uint256(type(uint24).max)) revert RiskParameterStorageInvalidError();\\n\\n        uint256 encoded0 =\\n            uint256(UFixed6.unwrap(newValue.margin)                    << (256 - 24)) >> (256 - 24) |\\n            uint256(UFixed6.unwrap(newValue.maintenance)               << (256 - 24)) >> (256 - 24 - 24) |\\n            uint256(UFixed6.unwrap(newValue.takerFee.linearFee)        << (256 - 24)) >> (256 - 24 - 24 - 24) |\\n            uint256(UFixed6.unwrap(newValue.takerFee.proportionalFee)  << (256 - 24)) >> (256 - 24 - 24 - 24 - 24) |\\n            uint256(UFixed6.unwrap(newValue.takerFee.adiabaticFee)     << (256 - 24)) >> (256 - 24 - 24 - 24 - 24 - 24) |\\n            uint256(UFixed6.unwrap(newValue.makerFee.linearFee)        << (256 - 24)) >> (256 - 24 - 24 - 24 - 24 - 24 - 24) |\\n            uint256(UFixed6.unwrap(newValue.makerFee.proportionalFee)  << (256 - 24)) >> (256 - 24 - 24 - 24 - 24 - 24 - 24 - 24) |\\n            uint256(newValue.makerLimit.truncate()                     << (256 - 48)) >> (256 - 24 - 24 - 24 - 24 - 24 - 24 - 24 - 48) |\\n            uint256(UFixed6.unwrap(newValue.efficiencyLimit)           << (256 - 24)) >> (256 - 24 - 24 - 24 - 24 - 24 - 24 - 24 - 48 - 24);\\n\\n        uint256 encoded1 =\\n            uint256(newValue.makerFee.scale.truncate()                          << (256 - 48)) >> (256 - 24 - 48) |\\n            uint256(newValue.takerFee.scale.truncate()                          << (256 - 48)) >> (256 - 24 - 48 - 48) |\\n            uint256(UFixed6.unwrap(newValue.utilizationCurve.minRate)           << (256 - 24)) >> (256 - 24 - 48 - 48 - 24) |\\n            uint256(UFixed6.unwrap(newValue.utilizationCurve.maxRate)           << (256 - 24)) >> (256 - 24 - 48 - 48 - 24 - 24) |\\n            uint256(UFixed6.unwrap(newValue.utilizationCurve.targetRate)        << (256 - 24)) >> (256 - 24 - 48 - 48 - 24 - 24 - 24) |\\n            uint256(UFixed6.unwrap(newValue.utilizationCurve.targetUtilization) << (256 - 24)) >> (256 - 24 - 48 - 48 - 24 - 24 - 24 - 24) |\\n            uint256(Fixed6.unwrap(newValue.pController.min)                     << (256 - 32)) >> (256 - 24 - 48 - 48 - 24 - 24 - 24 - 24 - 32);\\n\\n        uint256 encoded2 =\\n            uint256(UFixed6.unwrap(newValue.pController.k)                  << (256 - 48)) >> (256 - 48) |\\n            uint256(Fixed6.unwrap(newValue.pController.max)                 << (256 - 32)) >> (256 - 48 - 32) |\\n            uint256(UFixed6.unwrap(newValue.minMargin)                      << (256 - 48)) >> (256 - 48 - 32 - 48) |\\n            uint256(UFixed6.unwrap(newValue.minMaintenance)                 << (256 - 48)) >> (256 - 48 - 32 - 48 - 48) |\\n            uint256(UFixed6.unwrap(newValue.liquidationFee)                 << (256 - 48)) >> (256 - 48 - 32 - 48 - 48 - 48) |\\n            uint256(newValue.staleAfter                                     << (256 - 24)) >> (256 - 48 - 32 - 48 - 48 - 48 - 24) |\\n            uint256((newValue.makerReceiveOnly ? uint256(1) : uint256(0))   << (256 - 8))  >> (256 - 48 - 32 - 48 - 48 - 48 - 24 - 8);\\n\\n        assembly {\\n            sstore(self.slot, encoded0)\\n            sstore(add(self.slot, 1), encoded1)\\n            sstore(add(self.slot, 2), encoded2)\\n        }\\n    }\\n}\",\"keccak256\":\"0x90af6779c06bcca0c852369861872b5df6ff3e2091bbad2286516b65e624afcd\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2/contracts/types/Version.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@equilibria/root/accumulator/types/Accumulator6.sol\\\";\\nimport \\\"./ProtocolParameter.sol\\\";\\nimport \\\"./MarketParameter.sol\\\";\\nimport \\\"./RiskParameter.sol\\\";\\nimport \\\"./Global.sol\\\";\\nimport \\\"./Position.sol\\\";\\nimport \\\"./Order.sol\\\";\\n\\n/// @dev Version type\\nstruct Version {\\n    /// @dev whether this version had a valid oracle price\\n    bool valid;\\n\\n    /// @dev The price of the version\\n    Fixed6 price;\\n\\n    /// @dev The maker accumulator value\\n    Accumulator6 makerValue;\\n\\n    /// @dev The long accumulator value\\n    Accumulator6 longValue;\\n\\n    /// @dev The short accumulator value\\n    Accumulator6 shortValue;\\n\\n    /// @dev The accumulated fee for maker orders\\n    Accumulator6 makerFee;\\n\\n    /// @dev The accumulated fee for taker orders\\n    Accumulator6 takerFee;\\n\\n    /// @dev The accumulated offset for maker orders\\n    Accumulator6 makerOffset;\\n\\n    /// @dev The accumulated offset for positive taker orders (open long / close short)\\n    Accumulator6 takerPosOffset;\\n\\n    /// @dev The accumulated offset for negative taker orders (close long / open short)\\n    Accumulator6 takerNegOffset;\\n\\n    /// @dev The accumulated settlement fee for each individual order\\n    Accumulator6 settlementFee;\\n\\n    /// @dev The accumulated liquidation fee for each individual order\\n    Accumulator6 liquidationFee;\\n}\\nstruct VersionStorage { uint256 slot0; uint256 slot1; uint256 slot2; }\\nusing VersionStorageLib for VersionStorage global;\\n\\n/// @dev Manually encodes and decodes the Version struct into storage.\\n///      (external-safe): this library is safe to externalize\\n///\\n///     struct StoredVersion {\\n///         /* slot 0 */\\n///         bool valid;\\n///         int64 makerValue;\\n///         int64 longValue;\\n///         int64 shortValue;\\n///         uint48 liquidationFee;\\n///\\n///         /* slot 1 */\\n///         int64 price;\\n///         int48 makerOffset;\\n///         int48 takerPosOffset;\\n///         int48 takerNegOffset;\\n///         uint48 settlementFee;\\n///\\n///         /* slot 2 */\\n///         int48 makerFee;\\n///         int48 takerFee;\\n///     }\\n///\\nlibrary VersionStorageLib {\\n    // sig: 0xd2777e72\\n    error VersionStorageInvalidError();\\n\\n    function read(VersionStorage storage self) internal view returns (Version memory) {\\n        (uint256 slot0, uint256 slot1, uint256 slot2) = (self.slot0, self.slot1, self.slot2);\\n        return Version(\\n            (uint256(slot0 << (256 - 8)) >> (256 - 8)) != 0,\\n            Fixed6.wrap(int256(slot1 << (256 - 64)) >> (256 - 64)),\\n\\n            Accumulator6(Fixed6.wrap(int256(slot0 << (256 - 8 - 64)) >> (256 - 64))),\\n            Accumulator6(Fixed6.wrap(int256(slot0 << (256 - 8 - 64 - 64)) >> (256 - 64))),\\n            Accumulator6(Fixed6.wrap(int256(slot0 << (256 - 8 - 64 - 64 - 64)) >> (256 - 64))),\\n\\n            Accumulator6(Fixed6.wrap(int256(slot2 << (256 - 48)) >> (256 - 48))),\\n            Accumulator6(Fixed6.wrap(int256(slot2 << (256 - 48 - 48)) >> (256 - 48))),\\n\\n            Accumulator6(Fixed6.wrap(int256(slot1 << (256 - 64 - 48)) >> (256 - 48))),\\n            Accumulator6(Fixed6.wrap(int256(slot1 << (256 - 64 - 48 - 48)) >> (256 - 48))),\\n            Accumulator6(Fixed6.wrap(int256(slot1 << (256 - 64 - 48 - 48 - 48)) >> (256 - 48))),\\n\\n            Accumulator6(Fixed6.wrap(int256(slot1 << (256 - 64 - 48 - 48 - 48 - 48)) >> (256 - 48))),\\n            Accumulator6(Fixed6.wrap(int256(slot0 << (256 - 8 - 64 - 64 - 64 - 48)) >> (256 - 48)))\\n        );\\n    }\\n\\n    function store(VersionStorage storage self, Version memory newValue) external {\\n        if (newValue.price.gt(Fixed6.wrap(type(int64).max))) revert VersionStorageInvalidError();\\n        if (newValue.price.lt(Fixed6.wrap(type(int64).min))) revert VersionStorageInvalidError();\\n        if (newValue.makerValue._value.gt(Fixed6.wrap(type(int64).max))) revert VersionStorageInvalidError();\\n        if (newValue.makerValue._value.lt(Fixed6.wrap(type(int64).min))) revert VersionStorageInvalidError();\\n        if (newValue.longValue._value.gt(Fixed6.wrap(type(int64).max))) revert VersionStorageInvalidError();\\n        if (newValue.longValue._value.lt(Fixed6.wrap(type(int64).min))) revert VersionStorageInvalidError();\\n        if (newValue.shortValue._value.gt(Fixed6.wrap(type(int64).max))) revert VersionStorageInvalidError();\\n        if (newValue.shortValue._value.lt(Fixed6.wrap(type(int64).min))) revert VersionStorageInvalidError();\\n        if (newValue.makerFee._value.gt(Fixed6.wrap(type(int48).max))) revert VersionStorageInvalidError();\\n        if (newValue.makerFee._value.lt(Fixed6.wrap(type(int48).min))) revert VersionStorageInvalidError();\\n        if (newValue.takerFee._value.gt(Fixed6.wrap(type(int48).max))) revert VersionStorageInvalidError();\\n        if (newValue.takerFee._value.lt(Fixed6.wrap(type(int48).min))) revert VersionStorageInvalidError();\\n        if (newValue.makerOffset._value.gt(Fixed6.wrap(type(int48).max))) revert VersionStorageInvalidError();\\n        if (newValue.makerOffset._value.lt(Fixed6.wrap(type(int48).min))) revert VersionStorageInvalidError();\\n        if (newValue.takerPosOffset._value.gt(Fixed6.wrap(type(int48).max))) revert VersionStorageInvalidError();\\n        if (newValue.takerPosOffset._value.lt(Fixed6.wrap(type(int48).min))) revert VersionStorageInvalidError();\\n        if (newValue.takerNegOffset._value.gt(Fixed6.wrap(type(int48).max))) revert VersionStorageInvalidError();\\n        if (newValue.takerNegOffset._value.lt(Fixed6.wrap(type(int48).min))) revert VersionStorageInvalidError();\\n        if (newValue.settlementFee._value.gt(Fixed6.wrap(type(int48).max))) revert VersionStorageInvalidError();\\n        if (newValue.settlementFee._value.lt(Fixed6.wrap(type(int48).min))) revert VersionStorageInvalidError();\\n        if (newValue.liquidationFee._value.gt(Fixed6.wrap(type(int48).max))) revert VersionStorageInvalidError();\\n        if (newValue.liquidationFee._value.lt(Fixed6.wrap(type(int48).min))) revert VersionStorageInvalidError();\\n\\n        uint256 encoded0 =\\n            uint256((newValue.valid ? uint256(1) : uint256(0)) << (256 - 8)) >> (256 - 8) |\\n            uint256(Fixed6.unwrap(newValue.makerValue._value) << (256 - 64)) >> (256 - 8 - 64) |\\n            uint256(Fixed6.unwrap(newValue.longValue._value) << (256 - 64)) >> (256 - 8 - 64 - 64) |\\n            uint256(Fixed6.unwrap(newValue.shortValue._value) << (256 - 64)) >> (256 - 8 - 64 - 64 - 64) |\\n            uint256(Fixed6.unwrap(newValue.liquidationFee._value) << (256 - 48)) >> (256 - 8 - 64 - 64 - 64 - 48);\\n        uint256 encoded1 =\\n            uint256(Fixed6.unwrap(newValue.price) << (256 - 64)) >> (256 - 64) |\\n            uint256(Fixed6.unwrap(newValue.makerOffset._value) << (256 - 48)) >> (256 - 64 - 48) |\\n            uint256(Fixed6.unwrap(newValue.takerPosOffset._value) << (256 - 48)) >> (256 - 64 - 48 - 48) |\\n            uint256(Fixed6.unwrap(newValue.takerNegOffset._value) << (256 - 48)) >> (256 - 64 - 48 - 48 - 48) |\\n            uint256(Fixed6.unwrap(newValue.settlementFee._value) << (256 - 48)) >> (256 - 64 - 48 - 48 - 48 - 48);\\n        uint256 encoded2 =\\n            uint256(Fixed6.unwrap(newValue.makerFee._value) << (256 - 48)) >> (256 - 48) |\\n            uint256(Fixed6.unwrap(newValue.takerFee._value) << (256 - 48)) >> (256 - 48 - 48);\\n\\n        assembly {\\n            sstore(self.slot, encoded0)\\n            sstore(add(self.slot, 1), encoded1)\\n            sstore(add(self.slot, 2), encoded2)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc09b897e589a729fa89bf183515fba9808a2d5a5a6cd4e4b92360d2a522ad060\",\"license\":\"Apache-2.0\"},\"@equilibria/root/accumulator/types/Accumulator6.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"../../number/types/Fixed6.sol\\\";\\nimport \\\"../../number/types/UFixed6.sol\\\";\\n\\n/// @dev Accumulator6 type\\nstruct Accumulator6 {\\n    Fixed6 _value;\\n}\\n\\nusing Accumulator6Lib for Accumulator6 global;\\nstruct StoredAccumulator6 {\\n    int256 _value;\\n}\\nstruct Accumulator6Storage { StoredAccumulator6 value; }\\nusing Accumulator6StorageLib for Accumulator6Storage global;\\n\\n\\n/**\\n * @title Accumulator6Lib\\n * @notice Library that surfaces math operations for the signed Accumulator type.\\n * @dev This accumulator tracks cumulative changes to a value over time. Using the `accumulated` function, one\\n * can determine how much a value has changed between two points in time. The `increment` and `decrement` functions\\n * can be used to update the accumulator.\\n */\\nlibrary Accumulator6Lib {\\n    /**\\n     * Returns how much has been accumulated between two accumulators\\n     * @param self The current point of the accumulation to compare with `from`\\n     * @param from The starting point of the accumulation\\n     * @param total Demoninator of the ratio (see `increment` and `decrement` functions)\\n     */\\n    function accumulated(Accumulator6 memory self, Accumulator6 memory from, UFixed6 total) internal pure returns (Fixed6) {\\n        return _mul(self._value.sub(from._value), total);\\n    }\\n\\n    /**\\n     * @notice Increments an accumulator by a given ratio\\n     * @dev Always rounds down in order to prevent overstating the accumulated value\\n     * @param self The accumulator to increment\\n     * @param amount Numerator of the ratio\\n     * @param total Denominator of the ratio\\n     */\\n    function increment(Accumulator6 memory self, Fixed6 amount, UFixed6 total) internal pure {\\n        if (amount.isZero()) return;\\n        self._value = self._value.add(_div(amount, total));\\n    }\\n\\n    /**\\n     * @notice Decrements an accumulator by a given ratio\\n     * @dev Always rounds down in order to prevent overstating the accumulated value\\n     * @param self The accumulator to decrement\\n     * @param amount Numerator of the ratio\\n     * @param total Denominator of the ratio\\n     */\\n    function decrement(Accumulator6 memory self, Fixed6 amount, UFixed6 total) internal pure {\\n        if (amount.isZero()) return;\\n        self._value = self._value.add(_div(amount.mul(Fixed6Lib.NEG_ONE), total));\\n    }\\n\\n    function _div(Fixed6 amount, UFixed6 total) private pure returns (Fixed6) {\\n        return amount.sign() == -1 ? amount.divOut(Fixed6Lib.from(total)) : amount.div(Fixed6Lib.from(total));\\n    }\\n\\n    function _mul(Fixed6 amount, UFixed6 total) private pure returns (Fixed6) {\\n        return amount.sign() == -1 ? amount.mulOut(Fixed6Lib.from(total)) : amount.mul(Fixed6Lib.from(total));\\n    }\\n}\\n\\nlibrary Accumulator6StorageLib {\\n    function read(Accumulator6Storage storage self) internal view returns (Accumulator6 memory) {\\n        StoredAccumulator6 memory storedValue = self.value;\\n        return Accumulator6(Fixed6.wrap(int256(storedValue._value)));\\n    }\\n\\n    function store(Accumulator6Storage storage self, Accumulator6 memory newValue) internal {\\n        self.value = StoredAccumulator6(Fixed6.unwrap(newValue._value));\\n    }\\n}\\n\",\"keccak256\":\"0x21202b20328506bda86043889dca7b699732a9bf6ec735cc50ac8a444e643724\",\"license\":\"Apache-2.0\"},\"@equilibria/root/accumulator/types/UAccumulator6.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"../../number/types/UFixed6.sol\\\";\\n\\n/// @dev UAccumulator6 type\\nstruct UAccumulator6 {\\n    UFixed6 _value;\\n}\\n\\nusing UAccumulator6Lib for UAccumulator6 global;\\nstruct StoredUAccumulator6 {\\n    uint256 _value;\\n}\\nstruct UAccumulator6Storage { StoredUAccumulator6 value; }\\nusing UAccumulator6StorageLib for UAccumulator6Storage global;\\n\\n\\n/**\\n * @title UAccumulator6Lib\\n * @notice Library that surfaces math operations for the unsigned Accumulator type.\\n * @dev This accumulator tracks cumulative changes to a monotonically increasing value over time. Using the `accumulated` function, one\\n * can determine how much a value has changed between two points in time. The `increment` function can be used to update the accumulator.\\n */\\nlibrary UAccumulator6Lib {\\n    /**\\n     * Returns how much has been accumulated between two accumulators\\n     * @param self The current point of the accumulation to compare with `from`\\n     * @param from The starting point of the accumulation\\n     * @param total Demoninator of the ratio (see `increment` function)\\n     */\\n    function accumulated(UAccumulator6 memory self, UAccumulator6 memory from, UFixed6 total) internal pure returns (UFixed6) {\\n        return self._value.sub(from._value).mul(total);\\n    }\\n\\n    /**\\n     * @notice Increments an accumulator by a given ratio\\n     * @dev Always rounds down in order to prevent overstating the accumulated value\\n     * @param self The accumulator to increment\\n     * @param amount Numerator of the ratio\\n     * @param total Denominator of the ratio\\n     */\\n    function increment(UAccumulator6 memory self, UFixed6 amount, UFixed6 total) internal pure {\\n        if (amount.isZero()) return;\\n        self._value = self._value.add(amount.div(total));\\n    }\\n}\\n\\nlibrary UAccumulator6StorageLib {\\n    function read(UAccumulator6Storage storage self) internal view returns (UAccumulator6 memory) {\\n        StoredUAccumulator6 memory storedValue = self.value;\\n        return UAccumulator6(UFixed6.wrap(uint256(storedValue._value)));\\n    }\\n\\n    function store(UAccumulator6Storage storage self, UAccumulator6 memory newValue) internal {\\n        self.value = StoredUAccumulator6(UFixed6.unwrap(newValue._value));\\n    }\\n}\\n\",\"keccak256\":\"0x6c8f1e358099c02e441e396172c0d8920e85185946a72eff0af9a678588d0636\",\"license\":\"Apache-2.0\"},\"@equilibria/root/adiabatic/AdiabaticMath6.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"../number/types/UFixed6.sol\\\";\\nimport \\\"../number/types/Fixed6.sol\\\";\\n\\n/**\\n * @title AdiabaticMath6\\n * @notice Library for managing math operations for adiabatic fees.\\n */\\nlibrary AdiabaticMath6 {\\n    error Adiabatic6ZeroScaleError();\\n\\n    /// @notice Computes the base fees for an order\\n    /// @param fee The linear fee percentage\\n    /// @param change The change in skew in asset terms\\n    /// @param price The price of the underlying asset\\n    /// @return The linear fee in underlying terms\\n    function linearFee(UFixed6 fee, Fixed6 change, UFixed6 price) internal pure returns (UFixed6) {\\n        return change.abs().mul(price).mul(fee);\\n    }\\n\\n    /// @notice Computes the base fees for an order\\n    /// @param scale The scale of the skew\\n    /// @param fee The proportional fee percentage\\n    /// @param change The change in skew in asset terms\\n    /// @param price The price of the underlying asset\\n    /// @return The proportional fee in underlying terms\\n    function proportionalFee(UFixed6 scale, UFixed6 fee, Fixed6 change, UFixed6 price) internal pure returns (UFixed6) {\\n        return change.abs().mul(price).muldiv(change.abs(), scale).mul(fee);\\n    }\\n\\n    /// @notice Computes the adiabatic fee from a latest skew and change in skew over a linear function\\n    /// @param scale The scale of the skew\\n    /// @param adiabaticFee The adiabatic fee percentage\\n    /// @param latest The latest skew in asset terms\\n    /// @param change The change in skew in asset terms\\n    /// @param price The price of the underlying asset\\n    /// @return The adiabatic fee in underlying terms\\n    function linearCompute(\\n        UFixed6 scale,\\n        UFixed6 adiabaticFee,\\n        Fixed6 latest,\\n        Fixed6 change,\\n        UFixed6 price\\n    ) internal pure returns (Fixed6) {\\n        if (latest.isZero() && change.isZero()) return Fixed6Lib.ZERO;\\n        if (scale.isZero()) revert Adiabatic6ZeroScaleError();\\n\\n        // normalize for skew scale\\n        (Fixed6 latestScaled, Fixed6 changeScaled) =\\n            (latest.div(Fixed6Lib.from(scale)), change.div(Fixed6Lib.from(scale)));\\n\\n        // adiabatic fee = notional * fee percentage * mean of skew range\\n        return change.mul(Fixed6Lib.from(price)).mul(Fixed6Lib.from(adiabaticFee))\\n            .mul(_linearMean(latestScaled, latestScaled.add(changeScaled)));\\n    }\\n\\n    /// @notice Finds the mean value of the function f(x) = x over `from` to `to`\\n    /// @param from The lower bound\\n    /// @param to The upper bound\\n    /// @return The mean value\\n    function _linearMean(Fixed6 from, Fixed6 to) private pure returns (Fixed6) {\\n        return from.add(to).div(Fixed6Lib.from(2));\\n    }\\n}\\n\",\"keccak256\":\"0x9fea7ff94667e1ce3c4666940d21ad2fcc57058ec456f326e35f98b59a724433\",\"license\":\"Apache-2.0\"},\"@equilibria/root/adiabatic/types/LinearAdiabatic6.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"../../number/types/Fixed6.sol\\\";\\nimport \\\"../../number/types/UFixed6.sol\\\";\\nimport \\\"../AdiabaticMath6.sol\\\";\\n\\n/// @dev LinearAdiabatic6 type\\nstruct LinearAdiabatic6 {\\n    UFixed6 linearFee;\\n    UFixed6 proportionalFee;\\n    UFixed6 adiabaticFee;\\n    UFixed6 scale;\\n}\\nusing LinearAdiabatic6Lib for LinearAdiabatic6 global;\\n\\n/**\\n * @title LinearAdiabatic6Lib\\n * @notice Library that that manages the linear adiabatic fee algorithm\\n * @dev This algorithm specifies an adiatatic fee over the function:\\n *\\n *      f(skew) = adiabaticFee * skew\\n *\\n *      This is used to reward or penalize actions that move skew up or down this curve accordingly with net-zero\\n *      value to the system with respect to the underlying asset.\\n */\\nlibrary LinearAdiabatic6Lib {\\n    /// @notice Computes the adiabatic fee from a latest skew and change in skew\\n    /// @param self The adiabatic configuration\\n    /// @param latest The latest skew in asset terms\\n    /// @param change The change in skew in asset terms\\n    /// @param price The price of the underlying asset\\n    /// @return The adiabatic fee in underlying terms\\n    function compute(\\n        LinearAdiabatic6 memory self,\\n        Fixed6 latest,\\n        Fixed6 change,\\n        UFixed6 price\\n    ) internal pure returns (Fixed6) {\\n        return AdiabaticMath6.linearCompute(\\n            self.scale,\\n            self.adiabaticFee,\\n            latest,\\n            change,\\n            price\\n        );\\n    }\\n\\n    /// @notice Computes the latest exposure along with all fees\\n    /// @param self The adiabatic configuration\\n    /// @param latest The latest skew in asset terms\\n    /// @return The latest total exposure in asset terms\\n    function exposure(LinearAdiabatic6 memory self, Fixed6 latest) internal pure returns (Fixed6) {\\n        return compute(self, Fixed6Lib.ZERO, latest, UFixed6Lib.ONE);\\n    }\\n\\n    /// @dev Computes the change in exposure from a new configuration\\n    /// @param self The latest fee configuration\\n    /// @param newConfig The new fee configuration\\n    /// @param latest The latest skew in asset terms\\n    /// @param price The price of the underlying asset\\n    /// @return The update fee in underlying terms\\n    function exposure(\\n        LinearAdiabatic6 memory self,\\n        LinearAdiabatic6 memory newConfig,\\n        Fixed6 latest,\\n        UFixed6 price\\n    ) internal pure returns (Fixed6) {\\n        return compute(newConfig, Fixed6Lib.ZERO, latest, price).sub(compute(self, Fixed6Lib.ZERO, latest, price));\\n    }\\n\\n    /// @notice Computes the linear fee\\n    /// @param self The adiabatic configuration\\n    /// @param change The change in skew in asset terms\\n    /// @param price The price of the underlying asset\\n    /// @return The linear fee in underlying terms\\n    function linear(LinearAdiabatic6 memory self, Fixed6 change, UFixed6 price) internal pure returns (UFixed6) {\\n        return AdiabaticMath6.linearFee(self.linearFee, change, price);\\n    }\\n\\n    /// @notice Computes the proportional fee\\n    /// @param self The adiabatic configuration\\n    /// @param change The change in skew in asset terms\\n    /// @param price The price of the underlying asset\\n    /// @return The proportional fee in underlying terms\\n    function proportional(LinearAdiabatic6 memory self, Fixed6 change, UFixed6 price) internal pure returns (UFixed6) {\\n        return AdiabaticMath6.proportionalFee(self.scale, self.proportionalFee, change, price);\\n    }\\n\\n    /// @notice Computes the adiabatic fee\\n    /// @param self The adiabatic configuration\\n    /// @param latest The latest skew in asset terms\\n    /// @param change The change in skew in asset terms\\n    /// @param price The price of the underlying asset\\n    /// @return The adiabatic fee in underlying terms\\n    function adiabatic(\\n        LinearAdiabatic6 memory self,\\n        Fixed6 latest,\\n        Fixed6 change,\\n        UFixed6 price\\n    ) internal pure returns (Fixed6) {\\n        return compute(self, latest, change, price);\\n    }\\n}\\n\",\"keccak256\":\"0x5cb33ae31f4c44194e9fd8576eb15af0e29c0ff7cb91fd54c1f8010f125993a6\",\"license\":\"Apache-2.0\"},\"@equilibria/root/adiabatic/types/NoopAdiabatic6.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"../../number/types/Fixed6.sol\\\";\\nimport \\\"../../number/types/UFixed6.sol\\\";\\nimport \\\"../AdiabaticMath6.sol\\\";\\n\\n/// @dev NoopAdiabatic6 type\\nstruct NoopAdiabatic6 {\\n    UFixed6 linearFee;\\n    UFixed6 proportionalFee;\\n    UFixed6 scale;\\n}\\nusing NoopAdiabatic6Lib for NoopAdiabatic6 global;\\n\\n/**\\n * @title NoopAdiabatic6Lib\\n * @notice Library that that manages the no-op adiabatic fee algorithm\\n * @dev This algorithm specifies a fee schedule without an adiabatic fee. This is used for fees that need unsigned\\n *      fee impact without a signed shift fee based on skew.\\n */\\nlibrary NoopAdiabatic6Lib {\\n    /// @notice Computes the linear fee\\n    /// @param self The adiabatic configuration\\n    /// @param change The change in skew in asset terms\\n    /// @param price The price of the underlying asset\\n    /// @return The linear fee in underlying terms\\n    function linear(NoopAdiabatic6 memory self, Fixed6 change, UFixed6 price) internal pure returns (UFixed6) {\\n        return AdiabaticMath6.linearFee(self.linearFee, change, price);\\n    }\\n\\n    /// @notice Computes the proportional fee\\n    /// @param self The adiabatic configuration\\n    /// @param change The change in skew in asset terms\\n    /// @param price The price of the underlying asset\\n    /// @return The proportional fee in underlying terms\\n    function proportional(NoopAdiabatic6 memory self, Fixed6 change, UFixed6 price) internal pure returns (UFixed6) {\\n        return AdiabaticMath6.proportionalFee(self.scale, self.proportionalFee, change, price);\\n    }\\n}\\n\",\"keccak256\":\"0x711415003ec7bbb170c5d6afc7ccb884b059dab8c4908d930573ccaa4c22ed9d\",\"license\":\"Apache-2.0\"},\"@equilibria/root/attribute/Factory.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/utils/Create2.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\\\";\\nimport \\\"./interfaces/IFactory.sol\\\";\\nimport \\\"./interfaces/IInstance.sol\\\";\\nimport \\\"./Pausable.sol\\\";\\n\\n/// @title Factory\\n/// @notice An abstract factory that manages creates and manages instances\\n/// @dev Ownable and Pausable, and satisfies the IBeacon interface by default.\\nabstract contract Factory is IFactory, Ownable, Pausable {\\n    /// @notice The instances mapping storage slot\\n    bytes32 private constant INSTANCE_MAP_SLOT = keccak256(\\\"equilibria.root.Factory.instances\\\");\\n\\n    /// @notice The instance implementation address\\n    address public immutable implementation;\\n\\n    /// @notice Constructs the contract\\n    /// @param implementation_ The instance implementation address\\n    constructor(address implementation_) { implementation = implementation_; }\\n\\n    /// @notice Initializes the contract state\\n    function __Factory__initialize() internal onlyInitializer {\\n        __Ownable__initialize();\\n    }\\n\\n    /// @notice Returns whether the instance is valid\\n    /// @param instance The instance to check\\n    /// @return Whether the instance is valid\\n    function instances(IInstance instance) public view returns (bool) {\\n        return _instances()[instance];\\n    }\\n\\n    /// @notice Creates a new instance\\n    /// @dev Deploys a BeaconProxy with the this contract as the beacon\\n    /// @param data The initialization data\\n    /// @return newInstance The new instance\\n    function _create(bytes memory data) internal returns (IInstance newInstance) {\\n        newInstance = IInstance(address(new BeaconProxy(address(this), data)));\\n        _register(newInstance);\\n    }\\n    /// @notice Creates a new instance at a deterministic address\\n    /// @dev Deploys a BeaconProxy with the this contract as the beacon\\n    /// @param data The initialization data\\n    /// @param salt Used along with initialization data to determine a unique BeaconProxy address\\n    /// @return newInstance The new instance\\n    function _create2(bytes memory data, bytes32 salt) internal returns (IInstance newInstance) {\\n        newInstance = IInstance(address(new BeaconProxy{salt: salt}(address(this), data)));\\n        _register(newInstance);\\n    }\\n\\n    // @notice Calculates the address at which the instance will be deployed\\n    // @dev Passes the proxy's creation code along with this factory's address\\n    // @param data The same initialization data used in the _create2 call\\n    // @param salt Used along with initialization data to determine a unique BeaconProxy address\\n    function _computeCreate2Address(bytes memory data, bytes32 salt) internal view returns (address) {\\n        bytes memory bytecode = abi.encodePacked(\\n            type(BeaconProxy).creationCode,\\n            abi.encode(address(this), data)\\n        );\\n        return Create2.computeAddress(salt, keccak256(bytecode));\\n    }\\n\\n    /// @notice Registers a new instance\\n    /// @dev Called by _create automatically, or can be called manually in an extending implementation\\n    /// @param newInstance The new instance\\n    function _register(IInstance newInstance) internal {\\n        _instances()[newInstance] = true;\\n        emit InstanceRegistered(newInstance);\\n    }\\n\\n    /// @notice Returns the storage mapping for instances\\n    /// @return r The storage mapping for instances\\n    function _instances() private pure returns (mapping(IInstance => bool) storage r) {\\n        bytes32 slot = INSTANCE_MAP_SLOT;\\n        /// @solidity memory-safe-assembly\\n        assembly { r.slot := slot }\\n    }\\n\\n    /// @notice Only allow the function by a valid instance\\n    modifier onlyInstance {\\n        if (!instances(IInstance(msg.sender))) revert FactoryNotInstanceError();\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0x3c3032ea9b50308b11d62cf2e14028aeedb648ed8c3aeec854ac5d8f8256f6d7\",\"license\":\"Apache-2.0\"},\"@equilibria/root/attribute/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"./interfaces/IInitializable.sol\\\";\\nimport \\\"../storage/Storage.sol\\\";\\n\\n/**\\n * @title Initializable\\n * @notice Library to manage the initialization lifecycle of upgradeable contracts\\n * @dev `Initializable.sol` allows the creation of pseudo-constructors for upgradeable contracts. One\\n *      `initializer` should be declared per top-level contract. Child contracts can use the `onlyInitializer`\\n *      modifier to tag their internal initialization functions to ensure that they can only be called\\n *      from a top-level `initializer` or a constructor.\\n */\\nabstract contract Initializable is IInitializable {\\n    /// @dev The initialized flag\\n    Uint256Storage private constant _version = Uint256Storage.wrap(keccak256(\\\"equilibria.root.Initializable.version\\\"));\\n\\n    /// @dev The initializing flag\\n    BoolStorage private constant _initializing = BoolStorage.wrap(keccak256(\\\"equilibria.root.Initializable.initializing\\\"));\\n\\n    /// @dev Can only be called once per version, `version` is 1-indexed\\n    modifier initializer(uint256 version) {\\n        if (version == 0) revert InitializableZeroVersionError();\\n        if (_version.read() >= version) revert InitializableAlreadyInitializedError(version);\\n\\n        _version.store(version);\\n        _initializing.store(true);\\n\\n        _;\\n\\n        _initializing.store(false);\\n        emit Initialized(version);\\n    }\\n\\n    /// @dev Can only be called from an initializer or constructor\\n    modifier onlyInitializer() {\\n        if (!_constructing() && !_initializing.read()) revert InitializableNotInitializingError();\\n        _;\\n    }\\n\\n    /**\\n     * @notice Returns whether the contract is currently being constructed\\n     * @dev {Address.isContract} returns false for contracts currently in the process of being constructed\\n     * @return Whether the contract is currently being constructed\\n     */\\n    function _constructing() private view returns (bool) {\\n        return !Address.isContract(address(this));\\n    }\\n}\\n\",\"keccak256\":\"0xaae151abc669fe2ec33a80e4e62da1849b7863034aeb9c16122c728d041cfb0b\",\"license\":\"Apache-2.0\"},\"@equilibria/root/attribute/Instance.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"../storage/Storage.sol\\\";\\nimport \\\"./interfaces/IInstance.sol\\\";\\nimport \\\"./Initializable.sol\\\";\\n\\n/// @title Instance\\n/// @notice An abstract contract that is created and managed by a factory\\nabstract contract Instance is IInstance, Initializable {\\n    /// @dev The factory address storage slot\\n    AddressStorage private constant _factory = AddressStorage.wrap(keccak256(\\\"equilibria.root.Instance.factory\\\"));\\n\\n    /// @notice Returns the factory that created this instance\\n    /// @return The factory that created this instance\\n    function factory() public view returns (IFactory) { return IFactory(_factory.read()); }\\n\\n    /// @notice Initializes the contract setting `msg.sender` as the factory\\n    function __Instance__initialize() internal onlyInitializer {\\n        _factory.store(msg.sender);\\n    }\\n\\n    /// @notice Only allow the owner defined by the factory to call the function\\n    modifier onlyOwner {\\n        if (msg.sender != factory().owner()) revert InstanceNotOwnerError(msg.sender);\\n        _;\\n    }\\n\\n    /// @notice Only allow the factory to call the function\\n    modifier onlyFactory {\\n        if (msg.sender != address(factory())) revert InstanceNotFactoryError(msg.sender);\\n        _;\\n    }\\n\\n    /// @notice Only allow the function to be called when the factory is not paused\\n    modifier whenNotPaused {\\n        if (factory().paused()) revert InstancePausedError();\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0x4350fbc81d27a2470de4ee319e036f69153f6f42e163b912d5fa458400e774ac\",\"license\":\"Apache-2.0\"},\"@equilibria/root/attribute/Kept/Kept.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"../Initializable.sol\\\";\\nimport \\\"../interfaces/IKept.sol\\\";\\nimport \\\"../../storage/Storage.sol\\\";\\n\\n/// @title Kept\\n/// @notice Library to manage keeper incentivization.\\n/// @dev Surfaces a keep() modifier that handles measuring job gas costs and paying out rewards the keeper.\\nabstract contract Kept is IKept, Initializable {\\n    /// @dev The legacy Chainlink feed that is used to convert price ETH relative to the keeper token\\n    AddressStorage private constant _ethTokenOracleFeed = AddressStorage.wrap(keccak256(\\\"equilibria.root.Kept.ethTokenOracleFeed\\\"));\\n    function ethTokenOracleFeed() public view returns (AggregatorV3Interface) { return AggregatorV3Interface(_ethTokenOracleFeed.read()); }\\n\\n    /// @dev The token that the keeper is paid in\\n    Token18Storage private constant _keeperToken = Token18Storage.wrap(keccak256(\\\"equilibria.root.Kept.keeperToken\\\"));\\n    function keeperToken() public view returns (Token18) { return _keeperToken.read(); }\\n\\n    /// @notice Initializes the contract\\n    /// @param ethTokenOracleFeed_ The legacy Chainlink feed that is used to convert price ETH relative to the keeper token\\n    /// @param keeperToken_ The token that the keeper is paid in\\n    function __Kept__initialize(\\n        AggregatorV3Interface ethTokenOracleFeed_,\\n        Token18 keeperToken_\\n    ) internal onlyInitializer {\\n        _ethTokenOracleFeed.store(address(ethTokenOracleFeed_));\\n        _keeperToken.store(keeperToken_);\\n    }\\n\\n    /// @notice Called by the keep modifier to raise the optionally raise the keeper fee\\n    /// @param amount The amount of keeper fee to raise\\n    /// @param data Arbitrary data passed in from the keep modifier\\n    /// @return The amount of keeper fee that was actually raised\\n    function _raiseKeeperFee(UFixed18 amount, bytes memory data) internal virtual returns (UFixed18) { return amount; }\\n\\n    /// @notice Computes the calldata portion of the keeper fee\\n    /// @dev Used for L2 implementation with significant calldata costs\\n    /// @param applicableCalldata The applicable calldata\\n    /// @param multiplierCalldata The multiplier to apply to the calldata cost\\n    /// @param bufferCalldata The buffer to apply to the calldata cost\\n    /// @return The calldata portion of the keeper fee\\n    function _calldataFee(\\n        bytes memory applicableCalldata,\\n        UFixed18 multiplierCalldata,\\n        uint256 bufferCalldata\\n    ) internal view virtual returns (UFixed18) { return UFixed18Lib.ZERO; }\\n\\n    /// @notice Computes the base gas portion of the keeper fee\\n    /// @param applicableGas The applicable gas cost\\n    /// @param multiplierBase The multiplier to apply to the gas cost\\n    /// @param bufferBase The buffer to apply to the gas cost\\n    /// @return The gas cost portion of the keeper fee\\n    function _baseFee(\\n        uint256 applicableGas,\\n        UFixed18 multiplierBase,\\n        uint256 bufferBase\\n    ) internal view returns (UFixed18) {\\n        return _fee(applicableGas, multiplierBase, bufferBase, block.basefee);\\n    }\\n\\n    /// @notice Computes a generic keeper fee based on parameters\\n    /// @dev Helper function to consolidate keeper fee computation logic\\n    /// @param gas The gas cost\\n    /// @param multiplier The multiplier to apply to the gas cost\\n    /// @param buffer The buffer to apply to the gas cost\\n    /// @return The resulting keeper fee\\n    function _fee(uint256 gas, UFixed18 multiplier, uint256 buffer, uint256 baseFee) internal pure returns (UFixed18) {\\n        return UFixed18Lib.from(gas).mul(multiplier).add(UFixed18Lib.from(buffer)).mul(UFixed18.wrap(baseFee));\\n    }\\n\\n    /// @notice Placed on a function to incentivize keepers to call it\\n    /// @param config The multiplier and buffer configuration to apply\\n    /// @param data Arbitrary data to pass to the _raiseKeeperFee function\\n    /// @param applicableCalldata The applicable calldata\\n    /// @param applicableValue The applicable value\\n    /// @param data Arbitrary data to pass to the _raiseKeeperFee function\\n    modifier keep(\\n        KeepConfig memory config,\\n        bytes memory applicableCalldata,\\n        uint256 applicableValue,\\n        bytes memory data\\n    ) {\\n        uint256 startGas = gasleft();\\n\\n        _;\\n\\n        uint256 applicableGas = startGas - gasleft();\\n\\n        _handleKeeperFee(config, applicableGas, applicableCalldata, applicableValue, data);\\n    }\\n\\n    /// @notice Called by the keep modifier to handle keeper fee computation and payment\\n    /// @param config The multiplier and buffer configuration to apply\\n    /// @param applicableGas The applicable gas cost\\n    /// @param applicableCalldata The applicable calldata\\n    /// @param applicableValue The applicable value\\n    /// @param data Arbitrary data to pass to the _raiseKeeperFee function\\n    function _handleKeeperFee(\\n        KeepConfig memory config,\\n        uint256 applicableGas,\\n        bytes memory applicableCalldata,\\n        uint256 applicableValue,\\n        bytes memory data\\n    ) internal {\\n        (UFixed18 baseFee, UFixed18 calldataFee) = (\\n            _baseFee(applicableGas, config.multiplierBase, config.bufferBase),\\n            _calldataFee(applicableCalldata, config.multiplierCalldata, config.bufferCalldata)\\n        );\\n\\n        UFixed18 keeperFee = UFixed18.wrap(applicableValue).add(baseFee).add(calldataFee).mul(_etherPrice());\\n        keeperFee = _raiseKeeperFee(keeperFee, data);\\n        keeperToken().push(msg.sender, keeperFee);\\n\\n        emit KeeperCall(msg.sender, applicableGas, applicableValue, baseFee, calldataFee, keeperFee);\\n    }\\n\\n    /// @notice Returns the price of ETH in terms of the keeper token\\n    /// @return The price of ETH in terms of the keeper token\\n    function _etherPrice() private view returns (UFixed18) {\\n        (, int256 answer, , ,) = ethTokenOracleFeed().latestRoundData();\\n        return UFixed18Lib.from(Fixed18Lib.ratio(answer, 1e8)); // chainlink eth-usd feed uses 8 decimals\\n    }\\n}\\n\",\"keccak256\":\"0x02b283032d840d309fa8109b1c578553e6b8c37f6291e10a7b6a9413e60df03b\",\"license\":\"Apache-2.0\"},\"@equilibria/root/attribute/Kept/Kept_Arbitrum.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"./Kept.sol\\\";\\nimport { ArbGasInfo } from \\\"../../gas/GasOracle_Arbitrum.sol\\\";\\n\\n/// @dev Arbitrum Kept implementation\\nabstract contract Kept_Arbitrum is Kept {\\n    ArbGasInfo constant ARB_GAS = ArbGasInfo(0x000000000000000000000000000000000000006C);\\n    uint256 public constant ARB_GAS_MULTIPLIER = 16;\\n    uint256 public constant ARB_FIXED_OVERHEAD = 140;\\n\\n    // https://docs.arbitrum.io/devs-how-tos/how-to-estimate-gas#breaking-down-the-formula\\n    // Tx Fee = block.baseFee * l2GasUsed + ArbGasInfo.getL1BaseFeeEstimate() * 16 * (calldataLength + fixedOverhead)\\n    // Dynamic buffer = (ArbGasInfo.getL1BaseFeeEstimate() * 16 * (calldataLength + fixedOverhead))\\n    function _calldataFee(\\n        bytes memory applicableCalldata,\\n        UFixed18 multiplierCalldata,\\n        uint256 bufferCalldata\\n    ) internal view virtual override returns (UFixed18) {\\n        return _fee(\\n            ARB_GAS_MULTIPLIER * (applicableCalldata.length + ARB_FIXED_OVERHEAD),\\n            multiplierCalldata,\\n            bufferCalldata,\\n            ARB_GAS.getL1BaseFeeEstimate()\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x8b4447cd9bd95e01422980c303dc10cb5164d5b4e9ba639e0a7215e9f1f6bc5a\",\"license\":\"Apache-2.0\"},\"@equilibria/root/attribute/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"./Initializable.sol\\\";\\nimport \\\"./interfaces/IOwnable.sol\\\";\\nimport \\\"../storage/Storage.sol\\\";\\n\\n/**\\n * @title Ownable\\n * @notice Library to manage the ownership lifecycle of upgradeable contracts.\\n * @dev This contract has been extended from the Open Zeppelin library to include an\\n *      unstructured storage pattern so that it can be safely mixed in with upgradeable\\n *      contracts without affecting their storage patterns through inheritance.\\n */\\nabstract contract Ownable is IOwnable, Initializable {\\n    /// @dev The owner address\\n    AddressStorage private constant _owner = AddressStorage.wrap(keccak256(\\\"equilibria.root.Ownable.owner\\\"));\\n    function owner() public view returns (address) { return _owner.read(); }\\n\\n    /// @dev The pending owner address\\n    AddressStorage private constant _pendingOwner = AddressStorage.wrap(keccak256(\\\"equilibria.root.Ownable.pendingOwner\\\"));\\n    function pendingOwner() public view returns (address) { return _pendingOwner.read(); }\\n\\n    /**\\n     * @notice Initializes the contract setting `msg.sender` as the initial owner\\n     */\\n    function __Ownable__initialize() internal onlyInitializer {\\n        if (owner() != address(0)) revert OwnableAlreadyInitializedError();\\n        _updateOwner(_sender());\\n    }\\n\\n    /**\\n     * @notice Updates the new pending owner\\n     * @dev Can only be called by the current owner\\n     *      New owner does not take affect until that address calls `acceptOwner()`\\n     * @param newPendingOwner New pending owner address\\n     */\\n    function updatePendingOwner(address newPendingOwner) public onlyOwner {\\n        _pendingOwner.store(newPendingOwner);\\n        emit PendingOwnerUpdated(newPendingOwner);\\n    }\\n\\n    /**\\n     * @notice Accepts and transfers the ownership of the contract to the pending owner\\n     * @dev Can only be called by the pending owner to ensure correctness. Calls to the `_beforeAcceptOwner` hook\\n     *      to perform logic before updating ownership.\\n     */\\n    function acceptOwner() public {\\n        _beforeAcceptOwner();\\n\\n        if (_sender() != pendingOwner()) revert OwnableNotPendingOwnerError(_sender());\\n\\n        _updateOwner(pendingOwner());\\n        updatePendingOwner(address(0));\\n    }\\n\\n\\n    /// @dev Hook for inheriting contracts to perform logic before accepting ownership\\n    function _beforeAcceptOwner() internal virtual {}\\n\\n    /**\\n     * @notice Updates the owner address\\n     * @param newOwner New owner address\\n     */\\n    function _updateOwner(address newOwner) private {\\n        _owner.store(newOwner);\\n        emit OwnerUpdated(newOwner);\\n    }\\n\\n    function _sender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    /// @dev Throws if called by any account other than the owner\\n    modifier onlyOwner {\\n        if (owner() != _sender()) revert OwnableNotOwnerError(_sender());\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0x1024f8c5f541167dc2afd266a97e3a301a96bc9cac21e163288ac1d35ac0c3a9\",\"license\":\"Apache-2.0\"},\"@equilibria/root/attribute/Pausable.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"./Initializable.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./interfaces/IPausable.sol\\\";\\nimport \\\"../storage/Storage.sol\\\";\\n\\n/**\\n * @title Pausable\\n * @notice Library to allow for the emergency pausing and unpausing of contract functions\\n *         by an authorized account.\\n * @dev This contract has been extended from the Open Zeppelin library to include an\\n *      unstructured storage pattern so that it can be safely mixed in with upgradeable\\n *      contracts without affecting their storage patterns through inheritance.\\n */\\nabstract contract Pausable is IPausable, Ownable {\\n    /// @dev The pauser address\\n    AddressStorage private constant _pauser = AddressStorage.wrap(keccak256(\\\"equilibria.root.Pausable.pauser\\\"));\\n    function pauser() public view returns (address) { return _pauser.read(); }\\n\\n    /// @dev Whether the contract is paused\\n    BoolStorage private constant _paused = BoolStorage.wrap(keccak256(\\\"equilibria.root.Pausable.paused\\\"));\\n    function paused() public view returns (bool) { return _paused.read(); }\\n\\n    /**\\n     * @notice Initializes the contract setting `msg.sender` as the initial pauser\\n     */\\n    function __Pausable__initialize() internal onlyInitializer {\\n        __Ownable__initialize();\\n        updatePauser(_sender());\\n    }\\n\\n    /**\\n     * @notice Updates the new pauser\\n     * @dev Can only be called by the current owner\\n     * @param newPauser New pauser address\\n     */\\n    function updatePauser(address newPauser) public onlyOwner {\\n        _pauser.store(newPauser);\\n        emit PauserUpdated(newPauser);\\n    }\\n\\n    /**\\n     * @notice Pauses the contract\\n     * @dev Can only be called by the pauser\\n     */\\n    function pause() external onlyPauser {\\n        _paused.store(true);\\n        emit Paused();\\n    }\\n\\n    /**\\n     * @notice Unpauses the contract\\n     * @dev Can only be called by the pauser\\n     */\\n    function unpause() external onlyPauser {\\n        _paused.store(false);\\n        emit Unpaused();\\n    }\\n\\n    /// @dev Throws if called by any account other than the pauser\\n    modifier onlyPauser {\\n        if (_sender() != pauser() && _sender() != owner()) revert PausableNotPauserError(_sender());\\n        _;\\n    }\\n\\n    /// @dev Throws if called when the contract is paused\\n    modifier whenNotPaused {\\n        if (paused()) revert PausablePausedError();\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0x84576da194beb42bd63d486e7b2ad623201f0f77a34574eae35871cf5a6b5021\",\"license\":\"Apache-2.0\"},\"@equilibria/root/attribute/interfaces/IFactory.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\\\";\\nimport \\\"./IPausable.sol\\\";\\nimport \\\"./IInstance.sol\\\";\\n\\ninterface IFactory is IBeacon, IOwnable, IPausable {\\n    event InstanceRegistered(IInstance indexed instance);\\n\\n    error FactoryNotInstanceError();\\n\\n    function instances(IInstance instance) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x64c821ff5b6ff536a295bc0a24bf76dac44cd67b89183d224903f9fe1d6d3e65\",\"license\":\"Apache-2.0\"},\"@equilibria/root/attribute/interfaces/IInitializable.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\ninterface IInitializable {\\n    error InitializableZeroVersionError();\\n    error InitializableAlreadyInitializedError(uint256 version);\\n    error InitializableNotInitializingError();\\n\\n    event Initialized(uint256 version);\\n}\\n\",\"keccak256\":\"0xa626c401aab111b5ccdaa280b4d0137e2f4261a71796cd89a1435025083b4035\",\"license\":\"Apache-2.0\"},\"@equilibria/root/attribute/interfaces/IInstance.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"./IFactory.sol\\\";\\nimport \\\"./IInitializable.sol\\\";\\n\\ninterface IInstance is IInitializable {\\n    error InstanceNotOwnerError(address sender);\\n    error InstanceNotFactoryError(address sender);\\n    error InstancePausedError();\\n\\n    function factory() external view returns (IFactory);\\n}\\n\",\"keccak256\":\"0x9c25e710af0e06bde4bc5b63a8fb4c020a55e7f2dc93ca061d0b74318cd4a8a0\",\"license\":\"Apache-2.0\"},\"@equilibria/root/attribute/interfaces/IKept.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport { AggregatorV3Interface } from \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\nimport \\\"../interfaces/IInitializable.sol\\\";\\nimport \\\"../../number/types/UFixed18.sol\\\";\\nimport \\\"../../token/types/Token18.sol\\\";\\n\\ninterface IKept is IInitializable {\\n    struct KeepConfig {\\n        UFixed18 multiplierBase;\\n        uint256 bufferBase;\\n        UFixed18 multiplierCalldata;\\n        uint256 bufferCalldata;\\n    }\\n\\n    event KeeperCall(address indexed sender, uint256 applicableGas, uint256 applicableValue, UFixed18 baseFee, UFixed18 calldataFee, UFixed18 keeperFee);\\n\\n    function ethTokenOracleFeed() external view returns (AggregatorV3Interface);\\n    function keeperToken() external view returns (Token18);\\n}\\n\",\"keccak256\":\"0xf4e1f5a6d115bca2636223d6516ddec2b92c9f587b416a737aff120fd02d6c5d\",\"license\":\"Apache-2.0\"},\"@equilibria/root/attribute/interfaces/IOwnable.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"./IInitializable.sol\\\";\\n\\ninterface IOwnable is IInitializable {\\n    event OwnerUpdated(address indexed newOwner);\\n    event PendingOwnerUpdated(address indexed newPendingOwner);\\n\\n    error OwnableNotOwnerError(address sender);\\n    error OwnableNotPendingOwnerError(address sender);\\n    error OwnableAlreadyInitializedError();\\n\\n    function owner() external view returns (address);\\n    function pendingOwner() external view returns (address);\\n    function updatePendingOwner(address newPendingOwner) external;\\n    function acceptOwner() external;\\n}\\n\",\"keccak256\":\"0x6b3d8a25d98d049ba4cfdbf36dd7f0e8b9ab8c3d514c2b2b730b459e0092717a\",\"license\":\"Apache-2.0\"},\"@equilibria/root/attribute/interfaces/IPausable.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"./IInitializable.sol\\\";\\nimport \\\"./IOwnable.sol\\\";\\n\\ninterface IPausable is IInitializable, IOwnable {\\n    event PauserUpdated(address indexed newPauser);\\n    event Paused();\\n    event Unpaused();\\n\\n    error PausablePausedError();\\n    error PausableNotPauserError(address sender);\\n\\n    function pauser() external view returns (address);\\n    function paused() external view returns (bool);\\n    function updatePauser(address newPauser) external;\\n    function pause() external;\\n    function unpause() external;\\n}\\n\",\"keccak256\":\"0x8ae48b036875291c763787ba6730d56f4a9cb30d7d4132ec8711544b99689338\",\"license\":\"Apache-2.0\"},\"@equilibria/root/gas/GasOracle.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport { AggregatorV3Interface } from \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\nimport { UFixed18, UFixed18Lib } from \\\"../number/types/UFixed18.sol\\\";\\nimport { Fixed18Lib } from \\\"../number/types/Fixed18.sol\\\";\\nimport { IGasOracle } from \\\"./interfaces/IGasOracle.sol\\\";\\n\\n/// @title GasOracle\\n/// @notice Standalone gas oracle for externally computing keeper rewards based on ether gas costs\\ncontract GasOracle is IGasOracle {\\n    /// @notice The total compute gas rewarded\\n    UFixed18 public immutable COMPUTE_GAS;\\n\\n    /// @notice The total calldata gas rewarded\\n    UFixed18 public immutable CALLDATA_GAS;\\n\\n    /// @notice Chainlink ETH-Token feed, where cost is expressed in terms of Token\\n    AggregatorV3Interface public immutable FEED;\\n\\n    /// @notice The precomputed offset of the Chainlink feed (10 ^ decimals)\\n    int256 public immutable FEED_OFFSET;\\n\\n    constructor(\\n        AggregatorV3Interface feed,\\n        uint256 decimals,\\n        uint256 computeGas,\\n        UFixed18 computeMultiplier,\\n        uint256 computeBase,\\n        uint256 calldataGas,\\n        UFixed18 calldataMultiplier,\\n        uint256 calldataBase\\n    ) {\\n        FEED = feed;\\n        FEED_OFFSET = int256(10 ** decimals);\\n        COMPUTE_GAS = _precompute(computeGas, computeMultiplier, computeBase);\\n        CALLDATA_GAS = _precompute(calldataGas, calldataMultiplier, calldataBase);\\n    }\\n\\n   /// @inheritdoc IGasOracle\\n    function cost(uint256 value) external view returns (UFixed18) {\\n        (UFixed18 baseFee, UFixed18 calldataFee) =\\n            (UFixed18.wrap(block.basefee).mul(COMPUTE_GAS), UFixed18.wrap(_calldataBaseFee()).mul(CALLDATA_GAS));\\n\\n        return UFixed18.wrap(value).add(baseFee).add(calldataFee).mul(_etherPrice());\\n    }\\n\\n    /// @notice Precomputes the total rewarded gas cost\\n    /// @param gas The applicable gas cost\\n    /// @param multiplier The reward multiplier to apply to the gas cost\\n    /// @param base The base gas reward to add on to the gas cost\\n    /// @return The total rewarded gas cost\\n    function _precompute(uint256 gas, UFixed18 multiplier, uint256 base) private pure returns (UFixed18) {\\n        return UFixed18Lib.from(gas).mul(multiplier).add(UFixed18Lib.from(base));\\n    }\\n\\n    /// @notice Returns the price of ether in terms of the underlying token\\n    /// @return The price of ether in terms of the underlyingtoken\\n    function _etherPrice() private view returns (UFixed18) {\\n        (, int256 answer, , ,) = FEED.latestRoundData();\\n        return UFixed18Lib.from(Fixed18Lib.ratio(answer, FEED_OFFSET));\\n    }\\n\\n    /// @notice Returns the base fee of the calldata\\n    /// @dev Can be overridden to provide a non-zero calldata base fee for L2 implementations\\n    /// @return The base fee of the calldata\\n    function _calldataBaseFee() internal virtual view returns (uint256) { return 0; }\\n}\\n\",\"keccak256\":\"0x7a7bcdf2d8f5aad3a520eb2d35388bd74787f3ea7c83ad9d003960b05d2973c5\",\"license\":\"Apache-2.0\"},\"@equilibria/root/gas/GasOracle_Arbitrum.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport { AggregatorV3Interface } from \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\nimport { UFixed18, UFixed18Lib } from \\\"../number/types/UFixed18.sol\\\";\\nimport { Fixed18Lib } from \\\"../number/types/Fixed18.sol\\\";\\nimport { GasOracle } from \\\"./GasOracle.sol\\\";\\n\\n// https://github.com/OffchainLabs/nitro/blob/v2.0.14/contracts/src/precompiles/ArbGasInfo.sol#L93\\ninterface ArbGasInfo {\\n    /// @notice Get ArbOS's estimate of the L1 basefee in wei\\n    function getL1BaseFeeEstimate() external view returns (uint256);\\n}\\n\\ncontract GasOracle_Arbitrum is GasOracle {\\n    ArbGasInfo constant ARB_GAS = ArbGasInfo(0x000000000000000000000000000000000000006C);\\n\\n    constructor(\\n        AggregatorV3Interface feed,\\n        uint256 decimals,\\n        uint256 computeGas,\\n        UFixed18 computeMultiplier,\\n        uint256 computeBase,\\n        uint256 calldataGas,\\n        UFixed18 calldataMultiplier,\\n        uint256 calldataBase\\n    ) GasOracle(feed, decimals, computeGas, computeMultiplier, computeBase, calldataGas, calldataMultiplier, calldataBase) { }\\n\\n    function _calldataBaseFee() internal override view returns (uint256) { return ARB_GAS.getL1BaseFeeEstimate(); }\\n}\\n\",\"keccak256\":\"0xb29dadf9642713b3d30278106cef01528360025f4acfdebbd56952899d3b3bc4\",\"license\":\"Apache-2.0\"},\"@equilibria/root/gas/interfaces/IGasOracle.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport { AggregatorV3Interface } from \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\nimport { UFixed18 } from \\\"../../number/types/UFixed18.sol\\\";\\n\\ninterface IGasOracle {\\n    function COMPUTE_GAS() external view returns (UFixed18);\\n    function CALLDATA_GAS() external view returns (UFixed18);\\n    function FEED() external view returns (AggregatorV3Interface);\\n    function FEED_OFFSET() external view returns (int256);\\n\\n    /// @notice Computes the reward of a transaction\\n    /// @param value The ether value of the transaction in addition to the gas cost rewarded\\n    /// @return The reward of the transaction\\n    function cost(uint256 value) external view returns (UFixed18);\\n}\\n\",\"keccak256\":\"0xcfbc5523e5c152b031d1b2152702d2e5665c9b9e39a9330bdb9a0940974939ac\",\"license\":\"Apache-2.0\"},\"@equilibria/root/number/NumberMath.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SignedMath.sol\\\";\\n\\n/**\\n * @title NumberMath\\n * @notice Library for additional math functions that are not included in the OpenZeppelin libraries.\\n */\\nlibrary NumberMath {\\n    error DivisionByZero();\\n\\n    /**\\n     * @notice Divides `a` by `b`, rounding the result away from zero if there is a remainder\\n     * @param a Dividend\\n     * @param b Divisor\\n     * @return Resulting quotient\\n     */\\n    function divOut(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (b == 0) revert DivisionByZero();\\n        return Math.ceilDiv(a, b);\\n    }\\n\\n    /**\\n     * @notice Divides `a` by `b`, rounding the result away from zero if there is a remainder\\n     * @param a Dividend\\n     * @param b Divisor\\n     * @return Resulting quotient\\n     */\\n    function divOut(int256 a, int256 b) internal pure returns (int256) {\\n        return sign(a) * sign(b) * int256(divOut(SignedMath.abs(a), SignedMath.abs(b)));\\n    }\\n\\n    /**\\n     * @notice Returns the sign of an int256\\n     * @dev Returns: -1 for negative\\n     *                0 for zero\\n     *                1 for positive\\n     * @param a int256 to find the sign of\\n     * @return Sign of the int256\\n     */\\n    function sign(int256 a) internal pure returns (int256) {\\n        if (a > 0) return 1;\\n        if (a < 0) return -1;\\n        return 0;\\n    }\\n}\\n\",\"keccak256\":\"0x8d3578ce6e74ee6589ba0468e2c539ef1eb51d6687b508e637620926eb8396b4\",\"license\":\"Apache-2.0\"},\"@equilibria/root/number/types/Fixed18.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SignedMath.sol\\\";\\nimport \\\"../NumberMath.sol\\\";\\nimport \\\"./Fixed6.sol\\\";\\nimport \\\"./UFixed18.sol\\\";\\n\\n/// @dev Fixed18 type\\ntype Fixed18 is int256;\\nusing Fixed18Lib for Fixed18 global;\\ntype Fixed18Storage is bytes32;\\nusing Fixed18StorageLib for Fixed18Storage global;\\n\\n/**\\n * @title Fixed18Lib\\n * @notice Library for the signed fixed-decimal type.\\n */\\nlibrary Fixed18Lib {\\n    error Fixed18OverflowError(uint256 value);\\n\\n    int256 private constant BASE = 1e18;\\n    Fixed18 public constant ZERO = Fixed18.wrap(0);\\n    Fixed18 public constant ONE = Fixed18.wrap(BASE);\\n    Fixed18 public constant NEG_ONE = Fixed18.wrap(-1 * BASE);\\n    Fixed18 public constant MAX = Fixed18.wrap(type(int256).max);\\n    Fixed18 public constant MIN = Fixed18.wrap(type(int256).min);\\n\\n    /**\\n     * @notice Creates a signed fixed-decimal from an unsigned fixed-decimal\\n     * @param a Unsigned fixed-decimal\\n     * @return New signed fixed-decimal\\n     */\\n    function from(UFixed18 a) internal pure returns (Fixed18) {\\n        uint256 value = UFixed18.unwrap(a);\\n        if (value > uint256(type(int256).max)) revert Fixed18OverflowError(value);\\n        return Fixed18.wrap(int256(value));\\n    }\\n\\n    /**\\n     * @notice Creates a signed fixed-decimal from a sign and an unsigned fixed-decimal\\n     * @param s Sign\\n     * @param m Unsigned fixed-decimal magnitude\\n     * @return New signed fixed-decimal\\n     */\\n    function from(int256 s, UFixed18 m) internal pure returns (Fixed18) {\\n        if (s > 0) return from(m);\\n        if (s < 0) {\\n            // Since from(m) multiplies m by BASE, from(m) cannot be type(int256).min\\n            // which is the only value that would overflow when negated. Therefore,\\n            // we can safely negate from(m) without checking for overflow.\\n            unchecked { return Fixed18.wrap(-1 * Fixed18.unwrap(from(m))); }\\n        }\\n        return ZERO;\\n    }\\n\\n    /**\\n     * @notice Creates a signed fixed-decimal from a signed integer\\n     * @param a Signed number\\n     * @return New signed fixed-decimal\\n     */\\n    function from(int256 a) internal pure returns (Fixed18) {\\n        return Fixed18.wrap(a * BASE);\\n    }\\n\\n    /**\\n     * @notice Creates a signed fixed-decimal from a base-6 signed fixed-decimal\\n     * @param a Base-6 signed fixed-decimal\\n     * @return New signed fixed-decimal\\n     */\\n    function from(Fixed6 a) internal pure returns (Fixed18) {\\n        return Fixed18.wrap(Fixed6.unwrap(a) * 1e12);\\n    }\\n\\n    /**\\n     * @notice Returns whether the signed fixed-decimal is equal to zero.\\n     * @param a Signed fixed-decimal\\n     * @return Whether the signed fixed-decimal is zero.\\n     */\\n    function isZero(Fixed18 a) internal pure returns (bool) {\\n        return Fixed18.unwrap(a) == 0;\\n    }\\n\\n    /**\\n     * @notice Adds two signed fixed-decimals `a` and `b` together\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Resulting summed signed fixed-decimal\\n     */\\n    function add(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\\n        return Fixed18.wrap(Fixed18.unwrap(a) + Fixed18.unwrap(b));\\n    }\\n\\n    /**\\n     * @notice Subtracts signed fixed-decimal `b` from `a`\\n     * @param a Signed fixed-decimal to subtract from\\n     * @param b Signed fixed-decimal to subtract\\n     * @return Resulting subtracted signed fixed-decimal\\n     */\\n    function sub(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\\n        return Fixed18.wrap(Fixed18.unwrap(a) - Fixed18.unwrap(b));\\n    }\\n\\n    /**\\n     * @notice Multiplies two signed fixed-decimals `a` and `b` together\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Resulting multiplied signed fixed-decimal\\n     */\\n    function mul(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\\n        return Fixed18.wrap(Fixed18.unwrap(a) * Fixed18.unwrap(b) / BASE);\\n    }\\n\\n    /**\\n     * @notice Multiplies two signed fixed-decimals `a` and `b` together, rounding the result away from zero if there is a remainder\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Resulting multiplied signed fixed-decimal\\n     */\\n    function mulOut(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\\n        return Fixed18.wrap(NumberMath.divOut(Fixed18.unwrap(a) * Fixed18.unwrap(b), BASE));\\n    }\\n\\n    /**\\n     * @notice Divides signed fixed-decimal `a` by `b`\\n     * @param a Signed fixed-decimal to divide\\n     * @param b Signed fixed-decimal to divide by\\n     * @return Resulting divided signed fixed-decimal\\n     */\\n    function div(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\\n        return Fixed18.wrap(Fixed18.unwrap(a) * BASE / Fixed18.unwrap(b));\\n    }\\n\\n    /**\\n     * @notice Divides signed fixed-decimal `a` by `b`, rounding the result away from zero if there is a remainder\\n     * @param a Signed fixed-decimal to divide\\n     * @param b Signed fixed-decimal to divide by\\n     * @return Resulting divided signed fixed-decimal\\n     */\\n    function divOut(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\\n        return Fixed18Lib.from(sign(a) * sign(b), a.abs().divOut(b.abs()));\\n    }\\n\\n    /**\\n     * @notice Divides unsigned fixed-decimal `a` by `b`\\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0`, `MAX` for `n/0`, and `MIN` for `-n/0`.\\n     * @param a Unsigned fixed-decimal to divide\\n     * @param b Unsigned fixed-decimal to divide by\\n     * @return Resulting divided unsigned fixed-decimal\\n     */\\n    function unsafeDiv(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\\n        if (isZero(b)) {\\n            if (gt(a, ZERO)) return MAX;\\n            if (lt(a, ZERO)) return MIN;\\n            return ONE;\\n        } else {\\n            return div(a, b);\\n        }\\n    }\\n\\n    /**\\n     * @notice Divides unsigned fixed-decimal `a` by `b`, rounding the result away from zero if there is a remainder\\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0`, `MAX` for `n/0`, and `MIN` for `-n/0`.\\n     * @param a Unsigned fixed-decimal to divide\\n     * @param b Unsigned fixed-decimal to divide by\\n     * @return Resulting divided unsigned fixed-decimal\\n     */\\n    function unsafeDivOut(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\\n        if (isZero(b)) {\\n            if (gt(a, ZERO)) return MAX;\\n            if (lt(a, ZERO)) return MIN;\\n            return ONE;\\n        } else {\\n            return divOut(a, b);\\n        }\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\\n     * @param a First signed fixed-decimal\\n     * @param b Signed number to multiply by\\n     * @param c Signed number to divide by\\n     * @return Resulting computation\\n     */\\n    function muldiv(Fixed18 a, int256 b, int256 c) internal pure returns (Fixed18) {\\n        return muldiv(a, Fixed18.wrap(b), Fixed18.wrap(c));\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\\n     * @param a First signed fixed-decimal\\n     * @param b Signed number to multiply by\\n     * @param c Signed number to divide by\\n     * @return Resulting computation\\n     */\\n    function muldivOut(Fixed18 a, int256 b, int256 c) internal pure returns (Fixed18) {\\n        return muldivOut(a, Fixed18.wrap(b), Fixed18.wrap(c));\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\\n     * @param a First signed fixed-decimal\\n     * @param b Signed fixed-decimal to multiply by\\n     * @param c Signed fixed-decimal to divide by\\n     * @return Resulting computation\\n     */\\n    function muldiv(Fixed18 a, Fixed18 b, Fixed18 c) internal pure returns (Fixed18) {\\n        return Fixed18.wrap(Fixed18.unwrap(a) * Fixed18.unwrap(b) / Fixed18.unwrap(c));\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\\n     * @param a First signed fixed-decimal\\n     * @param b Signed fixed-decimal to multiply by\\n     * @param c Signed fixed-decimal to divide by\\n     * @return Resulting computation\\n     */\\n    function muldivOut(Fixed18 a, Fixed18 b, Fixed18 c) internal pure returns (Fixed18) {\\n        return Fixed18.wrap(NumberMath.divOut(Fixed18.unwrap(a) * Fixed18.unwrap(b), Fixed18.unwrap(c)));\\n    }\\n\\n    /**\\n     * @notice Returns whether signed fixed-decimal `a` is equal to `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Whether `a` is equal to `b`\\n     */\\n    function eq(Fixed18 a, Fixed18 b) internal pure returns (bool) {\\n        return compare(a, b) == 1;\\n    }\\n\\n    /**\\n     * @notice Returns whether signed fixed-decimal `a` is greater than `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Whether `a` is greater than `b`\\n     */\\n    function gt(Fixed18 a, Fixed18 b) internal pure returns (bool) {\\n        return compare(a, b) == 2;\\n    }\\n\\n    /**\\n     * @notice Returns whether signed fixed-decimal `a` is less than `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Whether `a` is less than `b`\\n     */\\n    function lt(Fixed18 a, Fixed18 b) internal pure returns (bool) {\\n        return compare(a, b) == 0;\\n    }\\n\\n    /**\\n     * @notice Returns whether signed fixed-decimal `a` is greater than or equal to `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Whether `a` is greater than or equal to `b`\\n     */\\n    function gte(Fixed18 a, Fixed18 b) internal pure returns (bool) {\\n        return gt(a, b) || eq(a, b);\\n    }\\n\\n    /**\\n     * @notice Returns whether signed fixed-decimal `a` is less than or equal to `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Whether `a` is less than or equal to `b`\\n     */\\n    function lte(Fixed18 a, Fixed18 b) internal pure returns (bool) {\\n        return lt(a, b) || eq(a, b);\\n    }\\n\\n    /**\\n     * @notice Compares the signed fixed-decimals `a` and `b`\\n     * @dev Returns: 2 for greater than\\n     *               1 for equal to\\n     *               0 for less than\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Compare result of `a` and `b`\\n     */\\n    function compare(Fixed18 a, Fixed18 b) internal pure returns (uint256) {\\n        (int256 au, int256 bu) = (Fixed18.unwrap(a), Fixed18.unwrap(b));\\n        if (au > bu) return 2;\\n        if (au < bu) return 0;\\n        return 1;\\n    }\\n\\n    /**\\n     * @notice Returns a signed fixed-decimal representing the ratio of `a` over `b`\\n     * @param a First signed number\\n     * @param b Second signed number\\n     * @return Ratio of `a` over `b`\\n     */\\n    function ratio(int256 a, int256 b) internal pure returns (Fixed18) {\\n        return Fixed18.wrap(a * BASE / b);\\n    }\\n\\n    /**\\n     * @notice Returns the minimum of signed fixed-decimals `a` and `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Minimum of `a` and `b`\\n     */\\n    function min(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\\n        return Fixed18.wrap(SignedMath.min(Fixed18.unwrap(a), Fixed18.unwrap(b)));\\n    }\\n\\n    /**\\n     * @notice Returns the maximum of signed fixed-decimals `a` and `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Maximum of `a` and `b`\\n     */\\n    function max(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\\n        return Fixed18.wrap(SignedMath.max(Fixed18.unwrap(a), Fixed18.unwrap(b)));\\n    }\\n\\n    /**\\n     * @notice Converts the signed fixed-decimal into an integer, truncating any decimal portion\\n     * @param a Signed fixed-decimal\\n     * @return Truncated signed number\\n     */\\n    function truncate(Fixed18 a) internal pure returns (int256) {\\n        return Fixed18.unwrap(a) / BASE;\\n    }\\n\\n    /**\\n     * @notice Returns the sign of the signed fixed-decimal\\n     * @dev Returns: -1 for negative\\n     *                0 for zero\\n     *                1 for positive\\n     * @param a Signed fixed-decimal\\n     * @return Sign of the signed fixed-decimal\\n     */\\n    function sign(Fixed18 a) internal pure returns (int256) {\\n        if (Fixed18.unwrap(a) > 0) return 1;\\n        if (Fixed18.unwrap(a) < 0) return -1;\\n        return 0;\\n    }\\n\\n    /**\\n     * @notice Returns the absolute value of the signed fixed-decimal\\n     * @param a Signed fixed-decimal\\n     * @return Absolute value of the signed fixed-decimal\\n     */\\n    function abs(Fixed18 a) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(SignedMath.abs(Fixed18.unwrap(a)));\\n    }\\n}\\n\\nlibrary Fixed18StorageLib {\\n    function read(Fixed18Storage self) internal view returns (Fixed18 value) {\\n        assembly (\\\"memory-safe\\\") {\\n            value := sload(self)\\n        }\\n    }\\n\\n    function store(Fixed18Storage self, Fixed18 value) internal {\\n        assembly (\\\"memory-safe\\\") {\\n            sstore(self, value)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xdd3541bc1dbe5ca81f996a1ed5a05a7b8c74247426aab221d1a8f37be91d0e4f\",\"license\":\"Apache-2.0\"},\"@equilibria/root/number/types/Fixed6.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SignedMath.sol\\\";\\nimport \\\"../NumberMath.sol\\\";\\nimport \\\"./Fixed18.sol\\\";\\nimport \\\"./UFixed6.sol\\\";\\n\\n/// @dev Fixed6 type\\ntype Fixed6 is int256;\\nusing Fixed6Lib for Fixed6 global;\\ntype Fixed6Storage is bytes32;\\nusing Fixed6StorageLib for Fixed6Storage global;\\n\\n/**\\n * @title Fixed6Lib\\n * @notice Library for the signed fixed-decimal type.\\n */\\nlibrary Fixed6Lib {\\n    error Fixed6OverflowError(uint256 value);\\n\\n    int256 private constant BASE = 1e6;\\n    Fixed6 public constant ZERO = Fixed6.wrap(0);\\n    Fixed6 public constant ONE = Fixed6.wrap(BASE);\\n    Fixed6 public constant NEG_ONE = Fixed6.wrap(-1 * BASE);\\n    Fixed6 public constant MAX = Fixed6.wrap(type(int256).max);\\n    Fixed6 public constant MIN = Fixed6.wrap(type(int256).min);\\n\\n    /**\\n     * @notice Creates a signed fixed-decimal from an unsigned fixed-decimal\\n     * @param a Unsigned fixed-decimal\\n     * @return New signed fixed-decimal\\n     */\\n    function from(UFixed6 a) internal pure returns (Fixed6) {\\n        uint256 value = UFixed6.unwrap(a);\\n        if (value > uint256(type(int256).max)) revert Fixed6OverflowError(value);\\n        return Fixed6.wrap(int256(value));\\n    }\\n\\n    /**\\n     * @notice Creates a signed fixed-decimal from a sign and an unsigned fixed-decimal\\n     * @param s Sign\\n     * @param m Unsigned fixed-decimal magnitude\\n     * @return New signed fixed-decimal\\n     */\\n    function from(int256 s, UFixed6 m) internal pure returns (Fixed6) {\\n        if (s > 0) return from(m);\\n        if (s < 0) {\\n            // Since from(m) multiplies m by BASE, from(m) cannot be type(int256).min\\n            // which is the only value that would overflow when negated. Therefore,\\n            // we can safely negate from(m) without checking for overflow.\\n            unchecked { return Fixed6.wrap(-1 * Fixed6.unwrap(from(m))); }\\n        }\\n        return ZERO;\\n    }\\n\\n    /**\\n     * @notice Creates a signed fixed-decimal from a signed integer\\n     * @param a Signed number\\n     * @return New signed fixed-decimal\\n     */\\n    function from(int256 a) internal pure returns (Fixed6) {\\n        return Fixed6.wrap(a * BASE);\\n    }\\n\\n    /**\\n     * @notice Creates a signed fixed-decimal from a base-18 signed fixed-decimal\\n     * @param a Base-18 signed fixed-decimal\\n     * @return New signed fixed-decimal\\n     */\\n    function from(Fixed18 a) internal pure returns (Fixed6) {\\n        return Fixed6.wrap(Fixed18.unwrap(a) / 1e12);\\n    }\\n\\n    /**\\n     * @notice Creates a signed fixed-decimal from a base-18 signed fixed-decimal\\n     * @param a Base-18 signed fixed-decimal\\n     * @param roundOut Whether to round the result away from zero if there is a remainder\\n     * @return New signed fixed-decimal\\n     */\\n    function from(Fixed18 a, bool roundOut) internal pure returns (Fixed6) {\\n        return roundOut ? Fixed6.wrap(NumberMath.divOut(Fixed18.unwrap(a), 1e12)): from(a);\\n    }\\n\\n    /**\\n     * @notice Returns whether the signed fixed-decimal is equal to zero.\\n     * @param a Signed fixed-decimal\\n     * @return Whether the signed fixed-decimal is zero.\\n     */\\n    function isZero(Fixed6 a) internal pure returns (bool) {\\n        return Fixed6.unwrap(a) == 0;\\n    }\\n\\n    /**\\n     * @notice Adds two signed fixed-decimals `a` and `b` together\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Resulting summed signed fixed-decimal\\n     */\\n    function add(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\\n        return Fixed6.wrap(Fixed6.unwrap(a) + Fixed6.unwrap(b));\\n    }\\n\\n    /**\\n     * @notice Subtracts signed fixed-decimal `b` from `a`\\n     * @param a Signed fixed-decimal to subtract from\\n     * @param b Signed fixed-decimal to subtract\\n     * @return Resulting subtracted signed fixed-decimal\\n     */\\n    function sub(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\\n        return Fixed6.wrap(Fixed6.unwrap(a) - Fixed6.unwrap(b));\\n    }\\n\\n    /**\\n     * @notice Multiplies two signed fixed-decimals `a` and `b` together\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Resulting multiplied signed fixed-decimal\\n     */\\n    function mul(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\\n        return Fixed6.wrap(Fixed6.unwrap(a) * Fixed6.unwrap(b) / BASE);\\n    }\\n\\n    /**\\n     * @notice Multiplies two signed fixed-decimals `a` and `b` together, rounding the result away from zero if there is a remainder\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Resulting multiplied signed fixed-decimal\\n     */\\n    function mulOut(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\\n        return Fixed6.wrap(NumberMath.divOut(Fixed6.unwrap(a) * Fixed6.unwrap(b), BASE));\\n    }\\n\\n    /**\\n     * @notice Divides signed fixed-decimal `a` by `b`\\n     * @param a Signed fixed-decimal to divide\\n     * @param b Signed fixed-decimal to divide by\\n     * @return Resulting divided signed fixed-decimal\\n     */\\n    function div(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\\n        return Fixed6.wrap(Fixed6.unwrap(a) * BASE / Fixed6.unwrap(b));\\n    }\\n\\n    /**\\n     * @notice Divides signed fixed-decimal `a` by `b`, rounding the result away from zero if there is a remainder\\n     * @param a Signed fixed-decimal to divide\\n     * @param b Signed fixed-decimal to divide by\\n     * @return Resulting divided signed fixed-decimal\\n     */\\n    function divOut(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\\n        return Fixed6Lib.from(sign(a) * sign(b), a.abs().divOut(b.abs()));\\n    }\\n\\n    /**\\n     * @notice Divides unsigned fixed-decimal `a` by `b`\\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0`, `MAX` for `n/0`, and `MIN` for `-n/0`.\\n     * @param a Unsigned fixed-decimal to divide\\n     * @param b Unsigned fixed-decimal to divide by\\n     * @return Resulting divided unsigned fixed-decimal\\n     */\\n    function unsafeDiv(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\\n        if (isZero(b)) {\\n            if (gt(a, ZERO)) return MAX;\\n            if (lt(a, ZERO)) return MIN;\\n            return ONE;\\n        } else {\\n            return div(a, b);\\n        }\\n    }\\n\\n    /**\\n     * @notice Divides unsigned fixed-decimal `a` by `b`, rounding the result away from zero if there is a remainder\\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0`, `MAX` for `n/0`, and `MIN` for `-n/0`.\\n     * @param a Unsigned fixed-decimal to divide\\n     * @param b Unsigned fixed-decimal to divide by\\n     * @return Resulting divided unsigned fixed-decimal\\n     */\\n    function unsafeDivOut(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\\n        if (isZero(b)) {\\n            if (gt(a, ZERO)) return MAX;\\n            if (lt(a, ZERO)) return MIN;\\n            return ONE;\\n        } else {\\n            return divOut(a, b);\\n        }\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\\n     * @param a First signed fixed-decimal\\n     * @param b Signed number to multiply by\\n     * @param c Signed number to divide by\\n     * @return Resulting computation\\n     */\\n    function muldiv(Fixed6 a, int256 b, int256 c) internal pure returns (Fixed6) {\\n        return muldiv(a, Fixed6.wrap(b), Fixed6.wrap(c));\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\\n     * @param a First signed fixed-decimal\\n     * @param b Signed number to multiply by\\n     * @param c Signed number to divide by\\n     * @return Resulting computation\\n     */\\n    function muldivOut(Fixed6 a, int256 b, int256 c) internal pure returns (Fixed6) {\\n        return muldivOut(a, Fixed6.wrap(b), Fixed6.wrap(c));\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\\n     * @param a First signed fixed-decimal\\n     * @param b Signed fixed-decimal to multiply by\\n     * @param c Signed fixed-decimal to divide by\\n     * @return Resulting computation\\n     */\\n    function muldiv(Fixed6 a, Fixed6 b, Fixed6 c) internal pure returns (Fixed6) {\\n        return Fixed6.wrap(Fixed6.unwrap(a) * Fixed6.unwrap(b) / Fixed6.unwrap(c));\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\\n     * @param a First signed fixed-decimal\\n     * @param b Signed fixed-decimal to multiply by\\n     * @param c Signed fixed-decimal to divide by\\n     * @return Resulting computation\\n     */\\n    function muldivOut(Fixed6 a, Fixed6 b, Fixed6 c) internal pure returns (Fixed6) {\\n        return Fixed6.wrap(NumberMath.divOut(Fixed6.unwrap(a) * Fixed6.unwrap(b), Fixed6.unwrap(c)));\\n    }\\n\\n    /**\\n     * @notice Returns whether signed fixed-decimal `a` is equal to `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Whether `a` is equal to `b`\\n     */\\n    function eq(Fixed6 a, Fixed6 b) internal pure returns (bool) {\\n        return compare(a, b) == 1;\\n    }\\n\\n    /**\\n     * @notice Returns whether signed fixed-decimal `a` is greater than `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Whether `a` is greater than `b`\\n     */\\n    function gt(Fixed6 a, Fixed6 b) internal pure returns (bool) {\\n        return compare(a, b) == 2;\\n    }\\n\\n    /**\\n     * @notice Returns whether signed fixed-decimal `a` is less than `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Whether `a` is less than `b`\\n     */\\n    function lt(Fixed6 a, Fixed6 b) internal pure returns (bool) {\\n        return compare(a, b) == 0;\\n    }\\n\\n    /**\\n     * @notice Returns whether signed fixed-decimal `a` is greater than or equal to `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Whether `a` is greater than or equal to `b`\\n     */\\n    function gte(Fixed6 a, Fixed6 b) internal pure returns (bool) {\\n        return gt(a, b) || eq(a, b);\\n    }\\n\\n    /**\\n     * @notice Returns whether signed fixed-decimal `a` is less than or equal to `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Whether `a` is less than or equal to `b`\\n     */\\n    function lte(Fixed6 a, Fixed6 b) internal pure returns (bool) {\\n        return lt(a, b) || eq(a, b);\\n    }\\n\\n    /**\\n     * @notice Compares the signed fixed-decimals `a` and `b`\\n     * @dev Returns: 2 for greater than\\n     *               1 for equal to\\n     *               0 for less than\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Compare result of `a` and `b`\\n     */\\n    function compare(Fixed6 a, Fixed6 b) internal pure returns (uint256) {\\n        (int256 au, int256 bu) = (Fixed6.unwrap(a), Fixed6.unwrap(b));\\n        if (au > bu) return 2;\\n        if (au < bu) return 0;\\n        return 1;\\n    }\\n\\n    /**\\n     * @notice Returns a signed fixed-decimal representing the ratio of `a` over `b`\\n     * @param a First signed number\\n     * @param b Second signed number\\n     * @return Ratio of `a` over `b`\\n     */\\n    function ratio(int256 a, int256 b) internal pure returns (Fixed6) {\\n        return Fixed6.wrap(a * BASE / b);\\n    }\\n\\n    /**\\n     * @notice Returns the minimum of signed fixed-decimals `a` and `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Minimum of `a` and `b`\\n     */\\n    function min(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\\n        return Fixed6.wrap(SignedMath.min(Fixed6.unwrap(a), Fixed6.unwrap(b)));\\n    }\\n\\n    /**\\n     * @notice Returns the maximum of signed fixed-decimals `a` and `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Maximum of `a` and `b`\\n     */\\n    function max(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\\n        return Fixed6.wrap(SignedMath.max(Fixed6.unwrap(a), Fixed6.unwrap(b)));\\n    }\\n\\n    /**\\n     * @notice Converts the signed fixed-decimal into an integer, truncating any decimal portion\\n     * @param a Signed fixed-decimal\\n     * @return Truncated signed number\\n     */\\n    function truncate(Fixed6 a) internal pure returns (int256) {\\n        return Fixed6.unwrap(a) / BASE;\\n    }\\n\\n    /**\\n     * @notice Returns the sign of the signed fixed-decimal\\n     * @dev Returns: -1 for negative\\n     *                0 for zero\\n     *                1 for positive\\n     * @param a Signed fixed-decimal\\n     * @return Sign of the signed fixed-decimal\\n     */\\n    function sign(Fixed6 a) internal pure returns (int256) {\\n        if (Fixed6.unwrap(a) > 0) return 1;\\n        if (Fixed6.unwrap(a) < 0) return -1;\\n        return 0;\\n    }\\n\\n    /**\\n     * @notice Returns the absolute value of the signed fixed-decimal\\n     * @param a Signed fixed-decimal\\n     * @return Absolute value of the signed fixed-decimal\\n     */\\n    function abs(Fixed6 a) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(SignedMath.abs(Fixed6.unwrap(a)));\\n    }\\n}\\n\\nlibrary Fixed6StorageLib {\\n    function read(Fixed6Storage self) internal view returns (Fixed6 value) {\\n        assembly (\\\"memory-safe\\\") {\\n            value := sload(self)\\n        }\\n    }\\n\\n    function store(Fixed6Storage self, Fixed6 value) internal {\\n        assembly (\\\"memory-safe\\\") {\\n            sstore(self, value)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xba2715da2fdf9393cc5e3ce7f9a38f7bfd3b271dcbf9a7fac5245f7c3ecc4522\",\"license\":\"Apache-2.0\"},\"@equilibria/root/number/types/UFixed18.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport \\\"../NumberMath.sol\\\";\\nimport \\\"./Fixed18.sol\\\";\\nimport \\\"./UFixed6.sol\\\";\\n\\n/// @dev UFixed18 type\\ntype UFixed18 is uint256;\\nusing UFixed18Lib for UFixed18 global;\\ntype UFixed18Storage is bytes32;\\nusing UFixed18StorageLib for UFixed18Storage global;\\n\\n/**\\n * @title UFixed18Lib\\n * @notice Library for the unsigned fixed-decimal type.\\n */\\nlibrary UFixed18Lib {\\n    error UFixed18UnderflowError(int256 value);\\n\\n    uint256 private constant BASE = 1e18;\\n    UFixed18 public constant ZERO = UFixed18.wrap(0);\\n    UFixed18 public constant ONE = UFixed18.wrap(BASE);\\n    UFixed18 public constant MAX = UFixed18.wrap(type(uint256).max);\\n\\n    /**\\n     * @notice Creates a unsigned fixed-decimal from a signed fixed-decimal\\n     * @param a Signed fixed-decimal\\n     * @return New unsigned fixed-decimal\\n     */\\n    function from(Fixed18 a) internal pure returns (UFixed18) {\\n        int256 value = Fixed18.unwrap(a);\\n        if (value < 0) revert UFixed18UnderflowError(value);\\n        return UFixed18.wrap(uint256(value));\\n    }\\n\\n    /**\\n     * @notice Creates a unsigned fixed-decimal from a signed fixed-decimal\\n     * @dev Does not revert on underflow, instead returns `ZERO`\\n     * @param a Signed fixed-decimal\\n     * @return New unsigned fixed-decimal\\n     */\\n    function unsafeFrom(Fixed18 a) internal pure returns (UFixed18) {\\n        return a.lt(Fixed18Lib.ZERO) ? ZERO : from(a);\\n    }\\n\\n    /**\\n     * @notice Creates a unsigned fixed-decimal from a unsigned integer\\n     * @param a Unsigned number\\n     * @return New unsigned fixed-decimal\\n     */\\n    function from(uint256 a) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(a * BASE);\\n    }\\n\\n    /**\\n     * @notice Creates a signed fixed-decimal from a base-6 signed fixed-decimal\\n     * @param a Base-6 signed fixed-decimal\\n     * @return New signed fixed-decimal\\n     */\\n    function from(UFixed6 a) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(UFixed6.unwrap(a) * 1e12);\\n    }\\n\\n    /**\\n     * @notice Returns whether the unsigned fixed-decimal is equal to zero.\\n     * @param a Unsigned fixed-decimal\\n     * @return Whether the unsigned fixed-decimal is zero.\\n     */\\n    function isZero(UFixed18 a) internal pure returns (bool) {\\n        return UFixed18.unwrap(a) == 0;\\n    }\\n\\n    /**\\n     * @notice Adds two unsigned fixed-decimals `a` and `b` together\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Resulting summed unsigned fixed-decimal\\n     */\\n    function add(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(UFixed18.unwrap(a) + UFixed18.unwrap(b));\\n    }\\n\\n    /**\\n     * @notice Subtracts unsigned fixed-decimal `b` from `a`\\n     * @param a Unsigned fixed-decimal to subtract from\\n     * @param b Unsigned fixed-decimal to subtract\\n     * @return Resulting subtracted unsigned fixed-decimal\\n     */\\n    function sub(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(UFixed18.unwrap(a) - UFixed18.unwrap(b));\\n    }\\n\\n    /**\\n     * @notice Subtracts unsigned fixed-decimal `a` by `b`\\n     * @dev Does not revert on underflow, instead returns `ZERO`\\n     * @param a Unsigned fixed-decimal to subtract from\\n     * @param b Unsigned fixed-decimal to subtract\\n     * @return Resulting subtracted unsigned fixed-decimal\\n     */\\n    function unsafeSub(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\\n        return gt(b, a) ? ZERO : sub(a, b);\\n    }\\n\\n    /**\\n     * @notice Multiplies two unsigned fixed-decimals `a` and `b` together\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Resulting multiplied unsigned fixed-decimal\\n     */\\n    function mul(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(UFixed18.unwrap(a) * UFixed18.unwrap(b) / BASE);\\n    }\\n\\n    /**\\n     * @notice Multiplies two unsigned fixed-decimals `a` and `b` together, rounding the result up to the next integer if there is a remainder\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Resulting multiplied unsigned fixed-decimal\\n     */\\n    function mulOut(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(NumberMath.divOut(UFixed18.unwrap(a) * UFixed18.unwrap(b), BASE));\\n    }\\n\\n    /**\\n     * @notice Divides unsigned fixed-decimal `a` by `b`\\n     * @param a Unsigned fixed-decimal to divide\\n     * @param b Unsigned fixed-decimal to divide by\\n     * @return Resulting divided unsigned fixed-decimal\\n     */\\n    function div(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(UFixed18.unwrap(a) * BASE / UFixed18.unwrap(b));\\n    }\\n\\n    /**\\n     * @notice Divides unsigned fixed-decimal `a` by `b`, rounding the result up to the next integer if there is a remainder\\n     * @param a Unsigned fixed-decimal to divide\\n     * @param b Unsigned fixed-decimal to divide by\\n     * @return Resulting divided unsigned fixed-decimal\\n     */\\n    function divOut(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(NumberMath.divOut(UFixed18.unwrap(a) * BASE, UFixed18.unwrap(b)));\\n    }\\n\\n    /**\\n     * @notice Divides unsigned fixed-decimal `a` by `b`\\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0` and `MAX` for `n/0`.\\n     * @param a Unsigned fixed-decimal to divide\\n     * @param b Unsigned fixed-decimal to divide by\\n     * @return Resulting divided unsigned fixed-decimal\\n     */\\n    function unsafeDiv(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\\n        if (isZero(b)) {\\n            return isZero(a) ? ONE : MAX;\\n        } else {\\n            return div(a, b);\\n        }\\n    }\\n\\n    /**\\n     * @notice Divides unsigned fixed-decimal `a` by `b`, rounding the result up to the next integer if there is a remainder\\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0` and `MAX` for `n/0`.\\n     * @param a Unsigned fixed-decimal to divide\\n     * @param b Unsigned fixed-decimal to divide by\\n     * @return Resulting divided unsigned fixed-decimal\\n     */\\n    function unsafeDivOut(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\\n        if (isZero(b)) {\\n            return isZero(a) ? ONE : MAX;\\n        } else {\\n            return divOut(a, b);\\n        }\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\\n     * @param a First unsigned fixed-decimal\\n     * @param b Unsigned number to multiply by\\n     * @param c Unsigned number to divide by\\n     * @return Resulting computation\\n     */\\n    function muldiv(UFixed18 a, uint256 b, uint256 c) internal pure returns (UFixed18) {\\n        return muldiv(a, UFixed18.wrap(b), UFixed18.wrap(c));\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\\n     * @param a First unsigned fixed-decimal\\n     * @param b Unsigned number to multiply by\\n     * @param c Unsigned number to divide by\\n     * @return Resulting computation\\n     */\\n    function muldivOut(UFixed18 a, uint256 b, uint256 c) internal pure returns (UFixed18) {\\n        return muldivOut(a, UFixed18.wrap(b), UFixed18.wrap(c));\\n    }\\n\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\\n     * @param a First unsigned fixed-decimal\\n     * @param b Unsigned fixed-decimal to multiply by\\n     * @param c Unsigned fixed-decimal to divide by\\n     * @return Resulting computation\\n     */\\n    function muldiv(UFixed18 a, UFixed18 b, UFixed18 c) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(UFixed18.unwrap(a) * UFixed18.unwrap(b) / UFixed18.unwrap(c));\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\\n     * @param a First unsigned fixed-decimal\\n     * @param b Unsigned fixed-decimal to multiply by\\n     * @param c Unsigned fixed-decimal to divide by\\n     * @return Resulting computation\\n     */\\n    function muldivOut(UFixed18 a, UFixed18 b, UFixed18 c) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(NumberMath.divOut(UFixed18.unwrap(a) * UFixed18.unwrap(b), UFixed18.unwrap(c)));\\n    }\\n\\n    /**\\n     * @notice Returns whether unsigned fixed-decimal `a` is equal to `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Whether `a` is equal to `b`\\n     */\\n    function eq(UFixed18 a, UFixed18 b) internal pure returns (bool) {\\n        return compare(a, b) == 1;\\n    }\\n\\n    /**\\n     * @notice Returns whether unsigned fixed-decimal `a` is greater than `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Whether `a` is greater than `b`\\n     */\\n    function gt(UFixed18 a, UFixed18 b) internal pure returns (bool) {\\n        return compare(a, b) == 2;\\n    }\\n\\n    /**\\n     * @notice Returns whether unsigned fixed-decimal `a` is less than `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Whether `a` is less than `b`\\n     */\\n    function lt(UFixed18 a, UFixed18 b) internal pure returns (bool) {\\n        return compare(a, b) == 0;\\n    }\\n\\n    /**\\n     * @notice Returns whether unsigned fixed-decimal `a` is greater than or equal to `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Whether `a` is greater than or equal to `b`\\n     */\\n    function gte(UFixed18 a, UFixed18 b) internal pure returns (bool) {\\n        return gt(a, b) || eq(a, b);\\n    }\\n\\n    /**\\n     * @notice Returns whether unsigned fixed-decimal `a` is less than or equal to `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Whether `a` is less than or equal to `b`\\n     */\\n    function lte(UFixed18 a, UFixed18 b) internal pure returns (bool) {\\n        return lt(a, b) || eq(a, b);\\n    }\\n\\n    /**\\n     * @notice Compares the unsigned fixed-decimals `a` and `b`\\n     * @dev Returns: 2 for greater than\\n     *               1 for equal to\\n     *               0 for less than\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Compare result of `a` and `b`\\n     */\\n    function compare(UFixed18 a, UFixed18 b) internal pure returns (uint256) {\\n        (uint256 au, uint256 bu) = (UFixed18.unwrap(a), UFixed18.unwrap(b));\\n        if (au > bu) return 2;\\n        if (au < bu) return 0;\\n        return 1;\\n    }\\n\\n    /**\\n     * @notice Returns a unsigned fixed-decimal representing the ratio of `a` over `b`\\n     * @param a First unsigned number\\n     * @param b Second unsigned number\\n     * @return Ratio of `a` over `b`\\n     */\\n    function ratio(uint256 a, uint256 b) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(a * BASE / b);\\n    }\\n\\n    /**\\n     * @notice Returns the minimum of unsigned fixed-decimals `a` and `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Minimum of `a` and `b`\\n     */\\n    function min(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(Math.min(UFixed18.unwrap(a), UFixed18.unwrap(b)));\\n    }\\n\\n    /**\\n     * @notice Returns the maximum of unsigned fixed-decimals `a` and `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Maximum of `a` and `b`\\n     */\\n    function max(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(Math.max(UFixed18.unwrap(a), UFixed18.unwrap(b)));\\n    }\\n\\n    /**\\n     * @notice Converts the unsigned fixed-decimal into an integer, truncating any decimal portion\\n     * @param a Unsigned fixed-decimal\\n     * @return Truncated unsigned number\\n     */\\n    function truncate(UFixed18 a) internal pure returns (uint256) {\\n        return UFixed18.unwrap(a) / BASE;\\n    }\\n}\\n\\nlibrary UFixed18StorageLib {\\n    function read(UFixed18Storage self) internal view returns (UFixed18 value) {\\n        assembly (\\\"memory-safe\\\") {\\n            value := sload(self)\\n        }\\n    }\\n\\n    function store(UFixed18Storage self, UFixed18 value) internal {\\n        assembly (\\\"memory-safe\\\") {\\n            sstore(self, value)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x42ce82e3622fdea0b8044a68a25f6df5102b3a25e1d26a2aaec1f928815c1d56\",\"license\":\"Apache-2.0\"},\"@equilibria/root/number/types/UFixed6.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport \\\"../NumberMath.sol\\\";\\nimport \\\"./Fixed6.sol\\\";\\nimport \\\"./UFixed18.sol\\\";\\n\\n/// @dev UFixed6 type\\ntype UFixed6 is uint256;\\nusing UFixed6Lib for UFixed6 global;\\ntype UFixed6Storage is bytes32;\\nusing UFixed6StorageLib for UFixed6Storage global;\\n\\n/**\\n * @title UFixed6Lib\\n * @notice Library for the unsigned fixed-decimal type.\\n */\\nlibrary UFixed6Lib {\\n    error UFixed6UnderflowError(int256 value);\\n\\n    uint256 private constant BASE = 1e6;\\n    UFixed6 public constant ZERO = UFixed6.wrap(0);\\n    UFixed6 public constant ONE = UFixed6.wrap(BASE);\\n    UFixed6 public constant MAX = UFixed6.wrap(type(uint256).max);\\n\\n    /**\\n     * @notice Creates a unsigned fixed-decimal from a signed fixed-decimal\\n     * @param a Signed fixed-decimal\\n     * @return New unsigned fixed-decimal\\n     */\\n    function from(Fixed6 a) internal pure returns (UFixed6) {\\n        int256 value = Fixed6.unwrap(a);\\n        if (value < 0) revert UFixed6UnderflowError(value);\\n        return UFixed6.wrap(uint256(value));\\n    }\\n\\n    /**\\n     * @notice Creates a unsigned fixed-decimal from a signed fixed-decimal\\n     * @dev Does not revert on underflow, instead returns `ZERO`\\n     * @param a Signed fixed-decimal\\n     * @return New unsigned fixed-decimal\\n     */\\n    function unsafeFrom(Fixed6 a) internal pure returns (UFixed6) {\\n        return a.lt(Fixed6Lib.ZERO) ? ZERO : from(a);\\n    }\\n\\n    /**\\n     * @notice Creates a unsigned fixed-decimal from a unsigned integer\\n     * @param a Unsigned number\\n     * @return New unsigned fixed-decimal\\n     */\\n    function from(uint256 a) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(a * BASE);\\n    }\\n\\n    /**\\n     * @notice Creates an unsigned fixed-decimal from a base-18 unsigned fixed-decimal\\n     * @param a Base-18 unsigned fixed-decimal\\n     * @return New unsigned fixed-decimal\\n     */\\n    function from(UFixed18 a) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(UFixed18.unwrap(a) / 1e12);\\n    }\\n\\n    /**\\n     * @notice Creates an unsigned fixed-decimal from a base-18 unsigned fixed-decimal\\n     * @param a Base-18 unsigned fixed-decimal\\n     * @param roundOut Whether to round the result away from zero if there is a remainder\\n     * @return New unsigned fixed-decimal\\n     */\\n    function from(UFixed18 a, bool roundOut) internal pure returns (UFixed6) {\\n        return roundOut ? UFixed6.wrap(NumberMath.divOut(UFixed18.unwrap(a), 1e12)): from(a);\\n    }\\n\\n    /**\\n     * @notice Returns whether the unsigned fixed-decimal is equal to zero.\\n     * @param a Unsigned fixed-decimal\\n     * @return Whether the unsigned fixed-decimal is zero.\\n     */\\n    function isZero(UFixed6 a) internal pure returns (bool) {\\n        return UFixed6.unwrap(a) == 0;\\n    }\\n\\n    /**\\n     * @notice Adds two unsigned fixed-decimals `a` and `b` together\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Resulting summed unsigned fixed-decimal\\n     */\\n    function add(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(UFixed6.unwrap(a) + UFixed6.unwrap(b));\\n    }\\n\\n    /**\\n     * @notice Subtracts unsigned fixed-decimal `b` from `a`\\n     * @param a Unsigned fixed-decimal to subtract from\\n     * @param b Unsigned fixed-decimal to subtract\\n     * @return Resulting subtracted unsigned fixed-decimal\\n     */\\n    function sub(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(UFixed6.unwrap(a) - UFixed6.unwrap(b));\\n    }\\n\\n    /**\\n     * @notice Subtracts unsigned fixed-decimal `a` by `b`\\n     * @dev Does not revert on underflow, instead returns `ZERO`\\n     * @param a Unsigned fixed-decimal to subtract from\\n     * @param b Unsigned fixed-decimal to subtract\\n     * @return Resulting subtracted unsigned fixed-decimal\\n     */\\n    function unsafeSub(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\\n        return gt(b, a) ? ZERO : sub(a, b);\\n    }\\n\\n    /**\\n     * @notice Multiplies two unsigned fixed-decimals `a` and `b` together\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Resulting multiplied unsigned fixed-decimal\\n     */\\n    function mul(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(UFixed6.unwrap(a) * UFixed6.unwrap(b) / BASE);\\n    }\\n\\n    /**\\n     * @notice Multiplies two unsigned fixed-decimals `a` and `b` together, rounding the result up to the next integer if there is a remainder\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Resulting multiplied unsigned fixed-decimal\\n     */\\n    function mulOut(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(NumberMath.divOut(UFixed6.unwrap(a) * UFixed6.unwrap(b), BASE));\\n    }\\n\\n    /**\\n     * @notice Divides unsigned fixed-decimal `a` by `b`\\n     * @param a Unsigned fixed-decimal to divide\\n     * @param b Unsigned fixed-decimal to divide by\\n     * @return Resulting divided unsigned fixed-decimal\\n     */\\n    function div(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(UFixed6.unwrap(a) * BASE / UFixed6.unwrap(b));\\n    }\\n\\n    /**\\n     * @notice Divides unsigned fixed-decimal `a` by `b`, rounding the result up to the next integer if there is a remainder\\n     * @param a Unsigned fixed-decimal to divide\\n     * @param b Unsigned fixed-decimal to divide by\\n     * @return Resulting divided unsigned fixed-decimal\\n     */\\n    function divOut(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(NumberMath.divOut(UFixed6.unwrap(a) * BASE, UFixed6.unwrap(b)));\\n    }\\n\\n    /**\\n     * @notice Divides unsigned fixed-decimal `a` by `b`\\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0` and `MAX` for `n/0`.\\n     * @param a Unsigned fixed-decimal to divide\\n     * @param b Unsigned fixed-decimal to divide by\\n     * @return Resulting divided unsigned fixed-decimal\\n     */\\n    function unsafeDiv(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\\n        if (isZero(b)) {\\n            return isZero(a) ? ONE : MAX;\\n        } else {\\n            return div(a, b);\\n        }\\n    }\\n\\n    /**\\n     * @notice Divides unsigned fixed-decimal `a` by `b`, rounding the result up to the next integer if there is a remainder\\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0` and `MAX` for `n/0`.\\n     * @param a Unsigned fixed-decimal to divide\\n     * @param b Unsigned fixed-decimal to divide by\\n     * @return Resulting divided unsigned fixed-decimal\\n     */\\n    function unsafeDivOut(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\\n        if (isZero(b)) {\\n            return isZero(a) ? ONE : MAX;\\n        } else {\\n            return divOut(a, b);\\n        }\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\\n     * @param a First unsigned fixed-decimal\\n     * @param b Unsigned number to multiply by\\n     * @param c Unsigned number to divide by\\n     * @return Resulting computation\\n     */\\n    function muldiv(UFixed6 a, uint256 b, uint256 c) internal pure returns (UFixed6) {\\n        return muldiv(a, UFixed6.wrap(b), UFixed6.wrap(c));\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\\n     * @param a First unsigned fixed-decimal\\n     * @param b Unsigned number to multiply by\\n     * @param c Unsigned number to divide by\\n     * @return Resulting computation\\n     */\\n    function muldivOut(UFixed6 a, uint256 b, uint256 c) internal pure returns (UFixed6) {\\n        return muldivOut(a, UFixed6.wrap(b), UFixed6.wrap(c));\\n    }\\n\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\\n     * @param a First unsigned fixed-decimal\\n     * @param b Unsigned fixed-decimal to multiply by\\n     * @param c Unsigned fixed-decimal to divide by\\n     * @return Resulting computation\\n     */\\n    function muldiv(UFixed6 a, UFixed6 b, UFixed6 c) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(UFixed6.unwrap(a) * UFixed6.unwrap(b) / UFixed6.unwrap(c));\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\\n     * @param a First unsigned fixed-decimal\\n     * @param b Unsigned fixed-decimal to multiply by\\n     * @param c Unsigned fixed-decimal to divide by\\n     * @return Resulting computation\\n     */\\n    function muldivOut(UFixed6 a, UFixed6 b, UFixed6 c) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(NumberMath.divOut(UFixed6.unwrap(a) * UFixed6.unwrap(b), UFixed6.unwrap(c)));\\n    }\\n\\n    /**\\n     * @notice Returns whether unsigned fixed-decimal `a` is equal to `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Whether `a` is equal to `b`\\n     */\\n    function eq(UFixed6 a, UFixed6 b) internal pure returns (bool) {\\n        return compare(a, b) == 1;\\n    }\\n\\n    /**\\n     * @notice Returns whether unsigned fixed-decimal `a` is greater than `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Whether `a` is greater than `b`\\n     */\\n    function gt(UFixed6 a, UFixed6 b) internal pure returns (bool) {\\n        return compare(a, b) == 2;\\n    }\\n\\n    /**\\n     * @notice Returns whether unsigned fixed-decimal `a` is less than `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Whether `a` is less than `b`\\n     */\\n    function lt(UFixed6 a, UFixed6 b) internal pure returns (bool) {\\n        return compare(a, b) == 0;\\n    }\\n\\n    /**\\n     * @notice Returns whether unsigned fixed-decimal `a` is greater than or equal to `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Whether `a` is greater than or equal to `b`\\n     */\\n    function gte(UFixed6 a, UFixed6 b) internal pure returns (bool) {\\n        return gt(a, b) || eq(a, b);\\n    }\\n\\n    /**\\n     * @notice Returns whether unsigned fixed-decimal `a` is less than or equal to `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Whether `a` is less than or equal to `b`\\n     */\\n    function lte(UFixed6 a, UFixed6 b) internal pure returns (bool) {\\n        return lt(a, b) || eq(a, b);\\n    }\\n\\n    /**\\n     * @notice Compares the unsigned fixed-decimals `a` and `b`\\n     * @dev Returns: 2 for greater than\\n     *               1 for equal to\\n     *               0 for less than\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Compare result of `a` and `b`\\n     */\\n    function compare(UFixed6 a, UFixed6 b) internal pure returns (uint256) {\\n        (uint256 au, uint256 bu) = (UFixed6.unwrap(a), UFixed6.unwrap(b));\\n        if (au > bu) return 2;\\n        if (au < bu) return 0;\\n        return 1;\\n    }\\n\\n    /**\\n     * @notice Returns a unsigned fixed-decimal representing the ratio of `a` over `b`\\n     * @param a First unsigned number\\n     * @param b Second unsigned number\\n     * @return Ratio of `a` over `b`\\n     */\\n    function ratio(uint256 a, uint256 b) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(a * BASE / b);\\n    }\\n\\n    /**\\n     * @notice Returns the minimum of unsigned fixed-decimals `a` and `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Minimum of `a` and `b`\\n     */\\n    function min(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(Math.min(UFixed6.unwrap(a), UFixed6.unwrap(b)));\\n    }\\n\\n    /**\\n     * @notice Returns the maximum of unsigned fixed-decimals `a` and `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Maximum of `a` and `b`\\n     */\\n    function max(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(Math.max(UFixed6.unwrap(a), UFixed6.unwrap(b)));\\n    }\\n\\n    /**\\n     * @notice Converts the unsigned fixed-decimal into an integer, truncating any decimal portion\\n     * @param a Unsigned fixed-decimal\\n     * @return Truncated unsigned number\\n     */\\n    function truncate(UFixed6 a) internal pure returns (uint256) {\\n        return UFixed6.unwrap(a) / BASE;\\n    }\\n}\\n\\nlibrary UFixed6StorageLib {\\n    function read(UFixed6Storage self) internal view returns (UFixed6 value) {\\n        assembly (\\\"memory-safe\\\") {\\n            value := sload(self)\\n        }\\n    }\\n\\n    function store(UFixed6Storage self, UFixed6 value) internal {\\n        assembly (\\\"memory-safe\\\") {\\n            sstore(self, value)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x378f6c0e6a0e8b534c019d99ddaecada9816e4c8ae66deba59bee92ac13ddc7f\",\"license\":\"Apache-2.0\"},\"@equilibria/root/pid/types/PAccumulator6.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"../../number/types/Fixed6.sol\\\";\\nimport \\\"./PController6.sol\\\";\\n\\n/// @dev PAccumulator6 type\\nstruct PAccumulator6 {\\n    Fixed6 _value;\\n    Fixed6 _skew;\\n}\\nusing PAccumulator6Lib for PAccumulator6 global;\\n\\n/// @title PAccumulator6Lib\\n/// @notice Accumulator for a the fixed 6-decimal PID controller. This holds the \\\"last seen state\\\" of the PID controller\\n///         and works in conjunction with the PController6 to compute the current rate.\\n/// @dev This implementation is specifically a P controller, with I_k and D_k both set to 0. In between updates, it\\n///      continues to accumulate at a linear rate based on the previous skew, but the rate is capped at the max value.\\n///      Once the rate hits the max value, it will continue to accumulate at the max value until the next update.\\nlibrary PAccumulator6Lib {\\n    /// @notice Accumulates the rate against notional given the prior and current state\\n    /// @param self The controller accumulator\\n    /// @param controller The controller configuration\\n    /// @param skew The current skew\\n    /// @param fromTimestamp The timestamp of the prior accumulation\\n    /// @param toTimestamp The current timestamp\\n    /// @param notional The notional to accumulate against\\n    /// @return accumulated The total accumulated amount\\n    function accumulate(\\n        PAccumulator6 memory self,\\n        PController6 memory controller,\\n        Fixed6 skew,\\n        uint256 fromTimestamp,\\n        uint256 toTimestamp,\\n        UFixed6 notional\\n    ) internal pure returns (Fixed6 accumulated) {\\n        // compute new value and intercept\\n        (Fixed6 newValue, UFixed6 interceptTimestamp) =\\n            controller.compute(self._value, self._skew, fromTimestamp, toTimestamp);\\n\\n        // accumulate rate within max\\n        accumulated = _accumulate(\\n            self._value.add(newValue),\\n            UFixed6Lib.from(fromTimestamp),\\n            interceptTimestamp,\\n            notional\\n        ).div(Fixed6Lib.from(2)); // rate = self._value + newValue / 2 -> divide here for added precision\\n\\n        // accumulate rate outside of max\\n        accumulated = _accumulate(\\n            newValue,\\n            interceptTimestamp,\\n            UFixed6Lib.from(toTimestamp),\\n            notional\\n        ).add(accumulated);\\n\\n        // update values\\n        self._value = newValue;\\n        self._skew = skew;\\n    }\\n\\n    /// @notice Helper function to accumulate a singular rate against notional\\n    /// @param rate The rate to accumulate\\n    /// @param fromTimestamp The timestamp to accumulate from\\n    /// @param toTimestamp The timestamp to accumulate to\\n    /// @param notional The notional to accumulate against\\n    /// @return The accumulated amount\\n    function _accumulate(\\n        Fixed6 rate,\\n        UFixed6 fromTimestamp,\\n        UFixed6 toTimestamp,\\n        UFixed6 notional\\n    ) private pure returns (Fixed6) {\\n        return rate\\n            .mul(Fixed6Lib.from(toTimestamp.sub(fromTimestamp)))\\n            .mul(Fixed6Lib.from(notional))\\n            .div(Fixed6Lib.from(365 days));\\n    }\\n}\\n\",\"keccak256\":\"0xf374a9997426cc90141334cdc8f8d3d62758be7eaefd21c5885742cc18d79a3a\",\"license\":\"Apache-2.0\"},\"@equilibria/root/pid/types/PController6.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"../../number/types/Fixed6.sol\\\";\\n\\n/// @dev PController6 type\\nstruct PController6 {\\n    UFixed6 k;\\n    Fixed6 min;\\n    Fixed6 max;\\n}\\nusing PController6Lib for PController6 global;\\n\\n/// @title PController6Lib\\n/// @notice Configuration for a the fixed 6-decimal PID controller.\\n/// @dev Each second, the PID controller's value is incremented by `skew / k`, with `max` as the maximum value.\\nlibrary PController6Lib {\\n    /// @notice compute the new value and intercept timestamp based on the prior controller state\\n    /// @dev `interceptTimestamp` will never exceed `toTimestamp`\\n    /// @param self the controller configuration\\n    /// @param value the prior value\\n    /// @param skew The prior skew\\n    /// @param fromTimestamp The prior timestamp\\n    /// @param toTimestamp The current timestamp\\n    /// @return newValue the new value\\n    /// @return interceptTimestamp the timestamp at which the value will be at the max\\n    function compute(\\n        PController6 memory self,\\n        Fixed6 value,\\n        Fixed6 skew,\\n        uint256 fromTimestamp,\\n        uint256 toTimestamp\\n    ) internal pure returns (Fixed6 newValue, UFixed6 interceptTimestamp) {\\n        // compute the new value without considering the max\\n        Fixed6 newValueUncapped = value.add(\\n            Fixed6Lib.from(int256(toTimestamp - fromTimestamp))\\n                .mul(skew)\\n                .div(Fixed6Lib.from(self.k))\\n        );\\n\\n        // cap the new value between min and max\\n        newValue = newValueUncapped.min(self.max).max(self.min);\\n\\n        // compute distance and range to the resultant value\\n        (UFixed6 distance, Fixed6 range) = (UFixed6Lib.from(toTimestamp - fromTimestamp), newValueUncapped.sub(value));\\n\\n        // compute the amount of buffer until the value is outside the max\\n        UFixed6 buffer = value.gt(self.max) || value.lt(self.min) ?\\n            UFixed6Lib.ZERO :\\n            (range.sign() > 0 ? self.max : self.min).sub(value).abs();\\n\\n        // compute the timestamp at which the value will be at the max\\n        interceptTimestamp = range.isZero() ?\\n            UFixed6Lib.from(toTimestamp) :\\n            UFixed6Lib.from(fromTimestamp).add(distance.muldiv(buffer, range.abs())).min(UFixed6Lib.from(toTimestamp));\\n    }\\n}\\n\",\"keccak256\":\"0xd1248bd4e011e66105f6da85d63e767f2ca4a26365a177ee9322d5a4007aed0c\",\"license\":\"Apache-2.0\"},\"@equilibria/root/storage/Storage.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"../number/types/UFixed18.sol\\\";\\n\\n/// @dev Stored boolean slot\\ntype BoolStorage is bytes32;\\nusing BoolStorageLib for BoolStorage global;\\n\\n/// @dev Stored uint256 slot\\ntype Uint256Storage is bytes32;\\nusing Uint256StorageLib for Uint256Storage global;\\n\\n/// @dev Stored int256 slot\\ntype Int256Storage is bytes32;\\nusing Int256StorageLib for Int256Storage global;\\n\\n/// @dev Stored address slot\\ntype AddressStorage is bytes32;\\nusing AddressStorageLib for AddressStorage global;\\n\\n/// @dev Stored bytes32 slot\\ntype Bytes32Storage is bytes32;\\nusing Bytes32StorageLib for Bytes32Storage global;\\n\\n/**\\n * @title BoolStorageLib\\n * @notice Library to manage storage and retrieval of a boolean at a fixed storage slot\\n */\\nlibrary BoolStorageLib {\\n    /**\\n     * @notice Retrieves the stored value\\n     * @param self Storage slot\\n     * @return value Stored bool value\\n     */\\n    function read(BoolStorage self) internal view returns (bool value) {\\n        assembly (\\\"memory-safe\\\") {\\n            value := sload(self)\\n        }\\n    }\\n\\n    /**\\n     * @notice Stores the value at the specific slot\\n     * @param self Storage slot\\n     * @param value boolean value to store\\n     */\\n    function store(BoolStorage self, bool value) internal {\\n        assembly (\\\"memory-safe\\\") {\\n            sstore(self, value)\\n        }\\n    }\\n}\\n\\n/**\\n * @title Uint256StorageLib\\n * @notice Library to manage storage and retrieval of an uint256 at a fixed storage slot\\n */\\nlibrary Uint256StorageLib {\\n    /**\\n     * @notice Retrieves the stored value\\n     * @param self Storage slot\\n     * @return value Stored uint256 value\\n     */\\n    function read(Uint256Storage self) internal view returns (uint256 value) {\\n        assembly (\\\"memory-safe\\\") {\\n            value := sload(self)\\n        }\\n    }\\n\\n    /**\\n     * @notice Stores the value at the specific slot\\n     * @param self Storage slot\\n     * @param value uint256 value to store\\n     */\\n    function store(Uint256Storage self, uint256 value) internal {\\n        assembly (\\\"memory-safe\\\") {\\n            sstore(self, value)\\n        }\\n    }\\n}\\n\\n/**\\n * @title Int256StorageLib\\n * @notice Library to manage storage and retrieval of an int256 at a fixed storage slot\\n */\\nlibrary Int256StorageLib {\\n    /**\\n     * @notice Retrieves the stored value\\n     * @param self Storage slot\\n     * @return value Stored int256 value\\n     */\\n    function read(Int256Storage self) internal view returns (int256 value) {\\n        assembly (\\\"memory-safe\\\") {\\n            value := sload(self)\\n        }\\n    }\\n\\n    /**\\n     * @notice Stores the value at the specific slot\\n     * @param self Storage slot\\n     * @param value int256 value to store\\n     */\\n    function store(Int256Storage self, int256 value) internal {\\n        assembly (\\\"memory-safe\\\") {\\n            sstore(self, value)\\n        }\\n    }\\n}\\n\\n/**\\n * @title AddressStorageLib\\n * @notice Library to manage storage and retrieval of an address at a fixed storage slot\\n */\\nlibrary AddressStorageLib {\\n    /**\\n     * @notice Retrieves the stored value\\n     * @param self Storage slot\\n     * @return value Stored address value\\n     */\\n    function read(AddressStorage self) internal view returns (address value) {\\n        assembly (\\\"memory-safe\\\") {\\n            value := sload(self)\\n        }\\n    }\\n\\n    /**\\n     * @notice Stores the value at the specific slot\\n     * @param self Storage slot\\n     * @param value address value to store\\n     */\\n    function store(AddressStorage self, address value) internal {\\n        assembly (\\\"memory-safe\\\") {\\n            sstore(self, value)\\n        }\\n    }\\n}\\n\\n/**\\n * @title Bytes32StorageLib\\n * @notice Library to manage storage and retrieval of a bytes32 at a fixed storage slot\\n */\\nlibrary Bytes32StorageLib {\\n    /**\\n     * @notice Retrieves the stored value\\n     * @param self Storage slot\\n     * @return value Stored bytes32 value\\n     */\\n    function read(Bytes32Storage self) internal view returns (bytes32 value) {\\n        assembly (\\\"memory-safe\\\") {\\n            value := sload(self)\\n        }\\n    }\\n\\n    /**\\n     * @notice Stores the value at the specific slot\\n     * @param self Storage slot\\n     * @param value bytes32 value to store\\n     */\\n    function store(Bytes32Storage self, bytes32 value) internal {\\n        assembly (\\\"memory-safe\\\") {\\n            sstore(self, value)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf904e2f3ded161530d179eca7f405de56db377f4770e236589940b943ef0dee9\",\"license\":\"Apache-2.0\"},\"@equilibria/root/token/types/Token18.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"../../number/types/UFixed18.sol\\\";\\n\\n/// @dev Token18\\ntype Token18 is address;\\nusing Token18Lib for Token18 global;\\ntype Token18Storage is bytes32;\\nusing Token18StorageLib for Token18Storage global;\\n\\n/**\\n * @title Token18Lib\\n * @notice Library to manage 18-decimal ERC20s that is compliant with the fixed-decimal types.\\n * @dev Maintains significant gas savings over other Token implementations since no conversion take place\\n */\\nlibrary Token18Lib {\\n    using SafeERC20 for IERC20;\\n\\n    Token18 public constant ZERO = Token18.wrap(address(0));\\n\\n    /**\\n     * @notice Returns whether a token is the zero address\\n     * @param self Token to check for\\n     * @return Whether the token is the zero address\\n     */\\n    function isZero(Token18 self) internal pure returns (bool) {\\n        return Token18.unwrap(self) == Token18.unwrap(ZERO);\\n    }\\n\\n    /**\\n     * @notice Returns whether the two tokens are equal\\n     * @param a First token to compare\\n     * @param b Second token to compare\\n     * @return Whether the two tokens are equal\\n     */\\n    function eq(Token18 a, Token18 b) internal pure returns (bool) {\\n        return Token18.unwrap(a) ==  Token18.unwrap(b);\\n    }\\n\\n    /**\\n     * @notice Approves `grantee` to spend infinite tokens from the caller\\n     * @dev Uses `approve` rather than `safeApprove` since the race condition\\n     *      in safeApprove does not apply when going to an infinite approval\\n     * @param self Token to grant approval\\n     * @param grantee Address to allow spending\\n     */\\n    function approve(Token18 self, address grantee) internal {\\n        IERC20(Token18.unwrap(self)).approve(grantee, type(uint256).max);\\n    }\\n\\n    /**\\n     * @notice Approves `grantee` to spend `amount` tokens from the caller\\n     * @dev There are important race conditions to be aware of when using this function\\n            with values other than 0. This will revert if moving from non-zero to non-zero amounts\\n            See https://github.com/OpenZeppelin/openzeppelin-contracts/blob/a55b7d13722e7ce850b626da2313f3e66ca1d101/contracts/token/ERC20/IERC20.sol#L57\\n     * @param self Token to grant approval\\n     * @param grantee Address to allow spending\\n     * @param amount Amount of tokens to approve to spend\\n     */\\n    function approve(Token18 self, address grantee, UFixed18 amount) internal {\\n        IERC20(Token18.unwrap(self)).safeApprove(grantee, UFixed18.unwrap(amount));\\n    }\\n\\n    /**\\n     * @notice Transfers all held tokens from the caller to the `recipient`\\n     * @param self Token to transfer\\n     * @param recipient Address to receive the tokens\\n     */\\n    function push(Token18 self, address recipient) internal {\\n        push(self, recipient, balanceOf(self, address(this)));\\n    }\\n\\n    /**\\n     * @notice Transfers `amount` tokens from the caller to the `recipient`\\n     * @param self Token to transfer\\n     * @param recipient Address to transfer tokens to\\n     * @param amount Amount of tokens to transfer\\n     */\\n    function push(Token18 self, address recipient, UFixed18 amount) internal {\\n        IERC20(Token18.unwrap(self)).safeTransfer(recipient, UFixed18.unwrap(amount));\\n    }\\n\\n    /**\\n     * @notice Transfers `amount` tokens from the `benefactor` to the caller\\n     * @dev Reverts if trying to pull Ether\\n     * @param self Token to transfer\\n     * @param benefactor Address to transfer tokens from\\n     * @param amount Amount of tokens to transfer\\n     */\\n    function pull(Token18 self, address benefactor, UFixed18 amount) internal {\\n        IERC20(Token18.unwrap(self)).safeTransferFrom(benefactor, address(this), UFixed18.unwrap(amount));\\n    }\\n\\n    /**\\n     * @notice Transfers `amount` tokens from the `benefactor` to `recipient`\\n     * @dev Reverts if trying to pull Ether\\n     * @param self Token to transfer\\n     * @param benefactor Address to transfer tokens from\\n     * @param recipient Address to transfer tokens to\\n     * @param amount Amount of tokens to transfer\\n     */\\n    function pullTo(Token18 self, address benefactor, address recipient, UFixed18 amount) internal {\\n        IERC20(Token18.unwrap(self)).safeTransferFrom(benefactor, recipient, UFixed18.unwrap(amount));\\n    }\\n\\n    /**\\n     * @notice Returns the name of the token\\n     * @param self Token to check for\\n     * @return Token name\\n     */\\n    function name(Token18 self) internal view returns (string memory) {\\n        return IERC20Metadata(Token18.unwrap(self)).name();\\n    }\\n\\n    /**\\n     * @notice Returns the symbol of the token\\n     * @param self Token to check for\\n     * @return Token symbol\\n     */\\n    function symbol(Token18 self) internal view returns (string memory) {\\n        return IERC20Metadata(Token18.unwrap(self)).symbol();\\n    }\\n\\n    /**\\n     * @notice Returns the `self` token balance of the caller\\n     * @param self Token to check for\\n     * @return Token balance of the caller\\n     */\\n    function balanceOf(Token18 self) internal view returns (UFixed18) {\\n        return balanceOf(self, address(this));\\n    }\\n\\n    /**\\n     * @notice Returns the `self` token balance of `account`\\n     * @param self Token to check for\\n     * @param account Account to check\\n     * @return Token balance of the account\\n     */\\n    function balanceOf(Token18 self, address account) internal view returns (UFixed18) {\\n        return UFixed18.wrap(IERC20(Token18.unwrap(self)).balanceOf(account));\\n    }\\n\\n    /**\\n     * @notice Returns the `self` total supply\\n     * @param self Token to check for\\n     * @return The total supply of the token\\n     */\\n    function totalSupply(Token18 self) internal view returns (UFixed18) {\\n        return UFixed18.wrap(IERC20(Token18.unwrap(self)).totalSupply());\\n    }\\n}\\n\\nlibrary Token18StorageLib {\\n    function read(Token18Storage self) internal view returns (Token18 value) {\\n        assembly (\\\"memory-safe\\\") {\\n            value := sload(self)\\n        }\\n    }\\n\\n    function store(Token18Storage self, Token18 value) internal {\\n        assembly (\\\"memory-safe\\\") {\\n            sstore(self, value)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf8598d9147d6bbf219d30a8bc3ea0a272170761e2a5368cd09df28e9c478c637\",\"license\":\"Apache-2.0\"},\"@equilibria/root/token/types/Token6.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport \\\"../../number/types/UFixed6.sol\\\";\\n\\n/// @dev Token6\\ntype Token6 is address;\\nusing Token6Lib for Token6 global;\\ntype Token6Storage is bytes32;\\nusing Token6StorageLib for Token6Storage global;\\n\\n/**\\n * @title Token6Lib\\n * @notice Library to manage 6-decimal ERC20s that is compliant with the fixed-decimal types.\\n */\\nlibrary Token6Lib {\\n    using SafeERC20 for IERC20;\\n\\n    Token6 public constant ZERO = Token6.wrap(address(0));\\n\\n    /**\\n     * @notice Returns whether a token is the zero address\\n     * @param self Token to check for\\n     * @return Whether the token is the zero address\\n     */\\n    function isZero(Token6 self) internal pure returns (bool) {\\n        return Token6.unwrap(self) == Token6.unwrap(ZERO);\\n    }\\n\\n    /**\\n     * @notice Returns whether the two tokens are equal\\n     * @param a First token to compare\\n     * @param b Second token to compare\\n     * @return Whether the two tokens are equal\\n     */\\n    function eq(Token6 a, Token6 b) internal pure returns (bool) {\\n        return Token6.unwrap(a) ==  Token6.unwrap(b);\\n    }\\n\\n    /**\\n     * @notice Approves `grantee` to spend infinite tokens from the caller\\n     * @dev Uses `approve` rather than `safeApprove` since the race condition\\n     *      in safeApprove does not apply when going to an infinite approval\\n     * @param self Token to grant approval\\n     * @param self Token to grant approval\\n     * @param grantee Address to allow spending\\n     */\\n    function approve(Token6 self, address grantee) internal {\\n        IERC20(Token6.unwrap(self)).approve(grantee, type(uint256).max);\\n    }\\n\\n    /**\\n     * @notice Approves `grantee` to spend `amount` tokens from the caller\\n     * @dev There are important race conditions to be aware of when using this function\\n            with values other than 0. This will revert if moving from non-zero to non-zero amounts\\n            See https://github.com/OpenZeppelin/openzeppelin-contracts/blob/a55b7d13722e7ce850b626da2313f3e66ca1d101/contracts/token/ERC20/IERC20.sol#L57\\n     * @param self Token to grant approval\\n     * @param self Token to grant approval\\n     * @param grantee Address to allow spending\\n     * @param amount Amount of tokens to approve to spend\\n     */\\n    function approve(Token6 self, address grantee, UFixed6 amount) internal {\\n        IERC20(Token6.unwrap(self)).safeApprove(grantee, UFixed6.unwrap(amount));\\n    }\\n\\n    /**\\n     * @notice Transfers all held tokens from the caller to the `recipient`\\n     * @param self Token to transfer\\n     * @param recipient Address to receive the tokens\\n     */\\n    function push(Token6 self, address recipient) internal {\\n        push(self, recipient, balanceOf(self, address(this)));\\n    }\\n\\n    /**\\n     * @notice Transfers `amount` tokens from the caller to the `recipient`\\n     * @param self Token to transfer\\n     * @param recipient Address to transfer tokens to\\n     * @param amount Amount of tokens to transfer\\n     */\\n    function push(Token6 self, address recipient, UFixed6 amount) internal {\\n        IERC20(Token6.unwrap(self)).safeTransfer(recipient, UFixed6.unwrap(amount));\\n    }\\n\\n    /**\\n     * @notice Transfers `amount` tokens from the `benefactor` to the caller\\n     * @dev Reverts if trying to pull Ether\\n     * @param self Token to transfer\\n     * @param benefactor Address to transfer tokens from\\n     * @param amount Amount of tokens to transfer\\n     */\\n    function pull(Token6 self, address benefactor, UFixed6 amount) internal {\\n        IERC20(Token6.unwrap(self)).safeTransferFrom(benefactor, address(this), UFixed6.unwrap(amount));\\n    }\\n\\n    /**\\n     * @notice Transfers `amount` tokens from the `benefactor` to `recipient`\\n     * @dev Reverts if trying to pull Ether\\n     * @param self Token to transfer\\n     * @param benefactor Address to transfer tokens from\\n     * @param recipient Address to transfer tokens to\\n     * @param amount Amount of tokens to transfer\\n     */\\n    function pullTo(Token6 self, address benefactor, address recipient, UFixed6 amount) internal {\\n        IERC20(Token6.unwrap(self)).safeTransferFrom(benefactor, recipient, UFixed6.unwrap(amount));\\n    }\\n\\n    /**\\n     * @notice Returns the name of the token\\n     * @param self Token to check for\\n     * @return Token name\\n     */\\n    function name(Token6 self) internal view returns (string memory) {\\n        return IERC20Metadata(Token6.unwrap(self)).name();\\n    }\\n\\n    /**\\n     * @notice Returns the symbol of the token\\n     * @param self Token to check for\\n     * @return Token symbol\\n     */\\n    function symbol(Token6 self) internal view returns (string memory) {\\n        return IERC20Metadata(Token6.unwrap(self)).symbol();\\n    }\\n\\n    /**\\n     * @notice Returns the `self` token balance of the caller\\n     * @param self Token to check for\\n     * @return Token balance of the caller\\n     */\\n    function balanceOf(Token6 self) internal view returns (UFixed6) {\\n        return balanceOf(self, address(this));\\n    }\\n\\n    /**\\n     * @notice Returns the `self` token balance of `account`\\n     * @param self Token to check for\\n     * @param account Account to check\\n     * @return Token balance of the account\\n     */\\n    function balanceOf(Token6 self, address account) internal view returns (UFixed6) {\\n        return UFixed6.wrap(IERC20(Token6.unwrap(self)).balanceOf(account));\\n    }\\n\\n    /**\\n     * @notice Returns the `self` total supply\\n     * @param self Token to check for\\n     * @return The total supply of the token\\n     */\\n    function totalSupply(Token6 self) internal view returns (UFixed6) {\\n        return UFixed6.wrap(IERC20(Token6.unwrap(self)).totalSupply());\\n    }\\n}\\n\\nlibrary Token6StorageLib {\\n    function read(Token6Storage self) internal view returns (Token6 value) {\\n        assembly (\\\"memory-safe\\\") {\\n            value := sload(self)\\n        }\\n    }\\n\\n    function store(Token6Storage self, Token6 value) internal {\\n        assembly (\\\"memory-safe\\\") {\\n            sstore(self, value)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x630056608dea38c12df30e36a9db4ed8b572c543c3c59df31ce57c120ff04479\",\"license\":\"Apache-2.0\"},\"@equilibria/root/utilization/CurveMath6.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"../number/types/UFixed6.sol\\\";\\nimport \\\"../number/types/Fixed6.sol\\\";\\n\\n/**\\n * @title CurveMath6\\n * @notice Library for managing math operations for utilization curves.\\n */\\nlibrary CurveMath6 {\\n    error CurveMath6OutOfBoundsError();\\n\\n    /**\\n     * @notice Computes a linear interpolation between two points\\n     * @param startX First point's x-coordinate\\n     * @param startY First point's y-coordinate\\n     * @param endX Second point's x-coordinate\\n     * @param endY Second point's y-coordinate\\n     * @param targetX x-coordinate to interpolate\\n     * @return y-coordinate for `targetX` along the line from (`startX`, `startY`) -> (`endX`, `endY`)\\n     */\\n    function linearInterpolation(\\n        UFixed6 startX,\\n        Fixed6 startY,\\n        UFixed6 endX,\\n        Fixed6 endY,\\n        UFixed6 targetX\\n    ) internal pure returns (Fixed6) {\\n        if (targetX.lt(startX) || targetX.gt(endX)) revert CurveMath6OutOfBoundsError();\\n\\n        UFixed6 xRange = endX.sub(startX);\\n        Fixed6 yRange = endY.sub(startY);\\n        UFixed6 xRatio = targetX.sub(startX).div(xRange);\\n        return yRange.mul(Fixed6Lib.from(xRatio)).add(startY);\\n    }\\n\\n    /**\\n     * @notice Computes a linear interpolation between two points\\n     * @param startX First point's x-coordinate\\n     * @param startY First point's y-coordinate\\n     * @param endX Second point's x-coordinate\\n     * @param endY Second point's y-coordinate\\n     * @param targetX x-coordinate to interpolate\\n     * @return y-coordinate for `targetX` along the line from (`startX`, `startY`) -> (`endX`, `endY`)\\n     */\\n    function linearInterpolation(\\n        UFixed6 startX,\\n        UFixed6 startY,\\n        UFixed6 endX,\\n        UFixed6 endY,\\n        UFixed6 targetX\\n    ) internal pure returns (UFixed6) {\\n        return UFixed6Lib.from(linearInterpolation(startX, Fixed6Lib.from(startY), endX, Fixed6Lib.from(endY), targetX));\\n    }\\n}\\n\",\"keccak256\":\"0xb2fc0e4473772b0a48f7282ac06bf1e86cea7cf0c788e406692e2d723633d549\",\"license\":\"Apache-2.0\"},\"@equilibria/root/utilization/types/UJumpRateUtilizationCurve6.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"../CurveMath6.sol\\\";\\nimport \\\"../../number/types/UFixed6.sol\\\";\\n\\n/// @dev UJumpRateUtilizationCurve6 type\\nstruct UJumpRateUtilizationCurve6 {\\n    UFixed6 minRate;\\n    UFixed6 maxRate;\\n    UFixed6 targetRate;\\n    UFixed6 targetUtilization;\\n}\\nusing UJumpRateUtilizationCurve6Lib for UJumpRateUtilizationCurve6 global;\\n\\n/**\\n * @title UJumpRateUtilizationCurve6Lib\\n * @notice Library for the unsigned base-6 Jump Rate utilization curve type\\n */\\nlibrary UJumpRateUtilizationCurve6Lib {\\n    /**\\n     * @notice Computes the corresponding rate for a utilization ratio\\n     * @param utilization The utilization ratio\\n     * @return The corresponding rate\\n     */\\n    function compute(UJumpRateUtilizationCurve6 memory self, UFixed6 utilization) internal pure returns (UFixed6) {\\n        if (utilization.lt(self.targetUtilization)) {\\n            return CurveMath6.linearInterpolation(\\n                UFixed6Lib.ZERO,\\n                self.minRate,\\n                self.targetUtilization,\\n                self.targetRate,\\n                utilization\\n            );\\n        }\\n        if (utilization.lt(UFixed6Lib.ONE)) {\\n            return CurveMath6.linearInterpolation(\\n                self.targetUtilization,\\n                self.targetRate,\\n                UFixed6Lib.ONE,\\n                self.maxRate,\\n                utilization\\n            );\\n        }\\n        return self.maxRate;\\n    }\\n\\n    function accumulate(\\n        UJumpRateUtilizationCurve6 memory self,\\n        UFixed6 utilization,\\n        uint256 fromTimestamp,\\n        uint256 toTimestamp,\\n        UFixed6 notional\\n    ) internal pure returns (UFixed6) {\\n        return compute(self, utilization)\\n            .mul(UFixed6Lib.from(toTimestamp - fromTimestamp))\\n            .mul(notional)\\n            .div(UFixed6Lib.from(365 days));\\n    }\\n}\\n\",\"keccak256\":\"0xfc568a2f1a98e3659a2f4142f916e057fe6bf1ac70feb04ced81072d742c22e7\",\"license\":\"Apache-2.0\"},\"@equilibria/root/verifier/interfaces/IVerifierBase.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport { Common } from \\\"../types/Common.sol\\\";\\nimport { GroupCancellation } from \\\"../types/GroupCancellation.sol\\\";\\n\\ninterface IVerifierBase {\\n    // sig: 0xfec563a0\\n    /// @custom:error Signer is trying to cancel a nonce for another user\\n    error VerifierInvalidSignerError();\\n    // sig: 0xa568ee00\\n    /// @custom:error Message was meant for another protocol, version, or chain\\n    error VerifierInvalidDomainError();\\n    // sig: 0xb09262f6\\n    /// @custom:error Signature length was unexpected\\n    error VerifierInvalidSignatureError();\\n    // sig: 0xe6784f14\\n    /// @custom:error Nonce has already been used\\n    error VerifierInvalidNonceError();\\n    // sig: 0x79998279\\n    /// @custom:error Group nonce has already been used\\n    error VerifierInvalidGroupError();\\n    // sig: 0x27661908\\n    /// @custom:error Block timestamp has exceeded user-assigned expiration\\n    error VerifierInvalidExpiryError();\\n\\n    /// @notice Emitted when a nonce is cancelled\\n    event NonceCancelled(address indexed account, uint256 nonce);\\n    /// @notice Emitted when a group nonce is cancelled\\n    event GroupCancelled(address indexed account, uint256 group);\\n\\n    /// @notice Returns whether the nonce has been cancelled\\n    /// @param account The account to check the nonce for\\n    /// @param nonce The nonce to check\\n    /// @return True if the nonce has been cancelled\\n    function nonces(address account, uint256 nonce) external view returns (bool);\\n\\n    /// @notice Returns whether the group nonce has been cancelled\\n    /// @param account The account to check the group nonce for\\n    /// @param nonce The group nonce to check\\n    /// @return True if the group nonce has been cancelled\\n    function groups(address account, uint256 nonce) external view returns (bool);\\n\\n    /// @notice Verifies the signature of no-op common message\\n    /// @dev Cancels the nonce after verifying the signature\\n    ///      Reverts if the signature does not match the signer\\n    /// @param common The common data of the message\\n    /// @param signature The signature of the account for the message\\n    function verifyCommon(Common calldata common, bytes calldata signature) external;\\n\\n    /// @notice Verifies the signature of a group cancellation type\\n    /// @dev Cancels the nonce after verifying the signature\\n    ///      Reverts if the signature does not match the signer\\n    /// @param groupCancellation The group cancellation to verify\\n    /// @param signature The signature of the account for the group cancellation\\n    function verifyGroupCancellation(GroupCancellation calldata groupCancellation, bytes calldata signature) external;\\n\\n    /// @notice Cancels a nonce\\n    /// @param nonce The nonce to cancel\\n    function cancelNonce(uint256 nonce) external;\\n\\n    /// @notice Cancels a nonce for an account via a signed message\\n    /// @dev Process a no-op message that will invalidate the specified nonce\\n    /// @param common The common data of the message\\n    /// @param signature The signature of the account for the message\\n    function cancelNonceWithSignature(Common calldata common, bytes calldata signature) external;\\n\\n    /// @notice Cancels a group nonce\\n    /// @param group The group nonce to cancel\\n    function cancelGroup(uint256 group) external;\\n\\n    /// @notice Cancels a group for an account via a signed message\\n    /// @param groupCancellation The group cancellation message\\n    /// @param signature The signature of the account for the group cancellation\\n    function cancelGroupWithSignature(GroupCancellation calldata groupCancellation, bytes calldata signature) external;\\n}\\n\",\"keccak256\":\"0xaf26a1f192b04226b2a95bfd59b72a0278328506ab24838e039017ba7134abc3\",\"license\":\"Apache-2.0\"},\"@equilibria/root/verifier/types/Common.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\n/// @notice Fields which need to be hashed in any EIP712 action\\nstruct Common {\\n    /// @dev The target account of the message (usually the account on behalf of which the action is being performed)\\n    address account;\\n    /// @dev EOA signing the message (usually either the account or a delegate of the account)\\n    address signer;\\n    /// @dev ensures the message is unique to a particular protocol version, chain, and verifier\\n    address domain;\\n    /// @dev per-sender nonce which is automatically cancelled upon validation\\n    uint256 nonce;\\n    /// @dev per-sender nonce which must be manually cancelled with a GroupCancellation message\\n    uint256 group;\\n    /// @dev prevents this message from having the intended effect after a specified timestamp\\n    uint256 expiry;\\n}\\nusing CommonLib for Common global;\\n\\n/// @title CommonLib\\n/// @notice Library collecting fields which need to be hashed in any EIP712 message\\nlibrary CommonLib {\\n    /// @dev used to verify a signed message\\n    bytes32 constant public STRUCT_HASH =\\n        keccak256(\\\"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\\\");\\n\\n    /// @dev used to create a signed message\\n    function hash(Common memory self) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(STRUCT_HASH, self.account, self.signer, self.domain, self.nonce, self.group, self.expiry));\\n    }\\n}\\n\",\"keccak256\":\"0x0f5a75ca2064a624dae4e7f6c6b494dcc8ec560e5775ec8055dd91471f6cb93b\",\"license\":\"Apache-2.0\"},\"@equilibria/root/verifier/types/GroupCancellation.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport { Common, CommonLib } from \\\"./Common.sol\\\";\\n\\nstruct GroupCancellation {\\n    /// @dev The group to cancel\\n    uint256 group;\\n\\n    /// @dev The common information for EIP712 actions\\n    Common common;\\n}\\nusing GroupCancellationLib for GroupCancellation global;\\n\\n/// @title GroupCancellationLib\\n/// @notice Library used to hash and verify action to cancel a group nonce.\\nlibrary GroupCancellationLib {\\n    bytes32 constant public STRUCT_HASH = keccak256(\\n        \\\"GroupCancellation(uint256 group,Common common)\\\"\\n        \\\"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\\\"\\n    );\\n\\n    function hash(GroupCancellation memory self) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(STRUCT_HASH, self.group, CommonLib.hash(self.common)));\\n    }\\n}\\n\",\"keccak256\":\"0x7060c6af6bf8aba391c7b30e3bd164aa529ba6f193a3fd8a45140541f975f398\",\"license\":\"Apache-2.0\"},\"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\\n * proxy whose upgrades are fully controlled by the current implementation.\\n */\\ninterface IERC1822Proxiable {\\n    /**\\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\\n     * address.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy.\\n     */\\n    function proxiableUUID() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0x1d4afe6cb24200cc4545eed814ecf5847277dfe5d613a1707aad5fceecebcfff\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../beacon/IBeacon.sol\\\";\\nimport \\\"../../interfaces/draft-IERC1822.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/StorageSlot.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n *\\n * _Available since v4.1._\\n *\\n * @custom:oz-upgrades-unsafe-allow delegatecall\\n */\\nabstract contract ERC1967Upgrade {\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCall(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _upgradeTo(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(newImplementation, data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCallUUPS(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\\n            _setImplementation(newImplementation);\\n        } else {\\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\\n                require(slot == _IMPLEMENTATION_SLOT, \\\"ERC1967Upgrade: unsupported proxiableUUID\\\");\\n            } catch {\\n                revert(\\\"ERC1967Upgrade: new implementation is not UUPS\\\");\\n            }\\n            _upgradeToAndCall(newImplementation, data, forceCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        require(newAdmin != address(0), \\\"ERC1967: new admin is the zero address\\\");\\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     */\\n    function _changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(_getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Emitted when the beacon is upgraded.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function _getBeacon() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        require(Address.isContract(newBeacon), \\\"ERC1967: new beacon is not a contract\\\");\\n        require(\\n            Address.isContract(IBeacon(newBeacon).implementation()),\\n            \\\"ERC1967: beacon implementation is not a contract\\\"\\n        );\\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\n    }\\n\\n    /**\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\n     *\\n     * Emits a {BeaconUpgraded} event.\\n     */\\n    function _upgradeBeaconToAndCall(\\n        address newBeacon,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xabf3f59bc0e5423eae45e459dbe92e7052c6983628d39008590edc852a62f94a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/Proxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\\n     * and {_fallback} should delegate.\\n     */\\n    function _implementation() internal view virtual returns (address);\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _beforeFallback();\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\\n     * is empty.\\n     */\\n    receive() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\\n     * call, or as part of the Solidity `fallback` or `receive` functions.\\n     *\\n     * If overridden should call `super._beforeFallback()`.\\n     */\\n    function _beforeFallback() internal virtual {}\\n}\\n\",\"keccak256\":\"0xc130fe33f1b2132158531a87734153293f6d07bc263ff4ac90e85da9c82c0e27\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/beacon/BeaconProxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IBeacon.sol\\\";\\nimport \\\"../Proxy.sol\\\";\\nimport \\\"../ERC1967/ERC1967Upgrade.sol\\\";\\n\\n/**\\n * @dev This contract implements a proxy that gets the implementation address for each call from an {UpgradeableBeacon}.\\n *\\n * The beacon address is stored in storage slot `uint256(keccak256('eip1967.proxy.beacon')) - 1`, so that it doesn't\\n * conflict with the storage layout of the implementation behind the proxy.\\n *\\n * _Available since v3.4._\\n */\\ncontract BeaconProxy is Proxy, ERC1967Upgrade {\\n    /**\\n     * @dev Initializes the proxy with `beacon`.\\n     *\\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This\\n     * will typically be an encoded function call, and allows initializing the storage of the proxy like a Solidity\\n     * constructor.\\n     *\\n     * Requirements:\\n     *\\n     * - `beacon` must be a contract with the interface {IBeacon}.\\n     */\\n    constructor(address beacon, bytes memory data) payable {\\n        _upgradeBeaconToAndCall(beacon, data, false);\\n    }\\n\\n    /**\\n     * @dev Returns the current beacon address.\\n     */\\n    function _beacon() internal view virtual returns (address) {\\n        return _getBeacon();\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation address of the associated beacon.\\n     */\\n    function _implementation() internal view virtual override returns (address) {\\n        return IBeacon(_getBeacon()).implementation();\\n    }\\n\\n    /**\\n     * @dev Changes the proxy to use a new beacon. Deprecated: see {_upgradeBeaconToAndCall}.\\n     *\\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon.\\n     *\\n     * Requirements:\\n     *\\n     * - `beacon` must be a contract.\\n     * - The implementation returned by `beacon` must be a contract.\\n     */\\n    function _setBeacon(address beacon, bytes memory data) internal virtual {\\n        _upgradeBeaconToAndCall(beacon, data, false);\\n    }\\n}\\n\",\"keccak256\":\"0x85439e74ab467b6a23d45d32bdc9506cbc3760320289afd605f11638c4138e95\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeacon {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\",\"keccak256\":\"0xd50a3421ac379ccb1be435fa646d66a65c986b4924f0849839f08692f39dde61\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x9750c6b834f7b43000631af5cc30001c5f547b3ceb3635488f140f60e897ea6b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x8de418a5503946cabe331f35fe242d3201a73f67f77aaeb7110acb1f30423aca\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xf41ca991f30855bf80ffd11e9347856a517b977f0a6c2d52e6421a99b7840329\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9b72f93be69ca894d8492c244259615c4a742afc8d63720dbc8bb81087d9b238\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf96f969e24029d43d0df89e59d365f277021dac62b48e1c1e3ebe0acdd7f1ca1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Create2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Create2.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\\n * `CREATE2` can be used to compute in advance the address where a smart\\n * contract will be deployed, which allows for interesting new mechanisms known\\n * as 'counterfactual interactions'.\\n *\\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\\n * information.\\n */\\nlibrary Create2 {\\n    /**\\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\\n     * will be deployed can be known in advance via {computeAddress}.\\n     *\\n     * The bytecode for a contract can be obtained from Solidity with\\n     * `type(contractName).creationCode`.\\n     *\\n     * Requirements:\\n     *\\n     * - `bytecode` must not be empty.\\n     * - `salt` must have not been used for `bytecode` already.\\n     * - the factory must have a balance of at least `amount`.\\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\\n     */\\n    function deploy(\\n        uint256 amount,\\n        bytes32 salt,\\n        bytes memory bytecode\\n    ) internal returns (address addr) {\\n        require(address(this).balance >= amount, \\\"Create2: insufficient balance\\\");\\n        require(bytecode.length != 0, \\\"Create2: bytecode length is zero\\\");\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\\n        }\\n        require(addr != address(0), \\\"Create2: Failed on deploy\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\\n     * `bytecodeHash` or `salt` will result in a new destination address.\\n     */\\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\\n        return computeAddress(salt, bytecodeHash, address(this));\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\\n     */\\n    function computeAddress(\\n        bytes32 salt,\\n        bytes32 bytecodeHash,\\n        address deployer\\n    ) internal pure returns (address addr) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40) // Get free memory pointer\\n\\n            // |                   | \\u2193 ptr ...  \\u2193 ptr + 0x0B (start) ...  \\u2193 ptr + 0x20 ...  \\u2193 ptr + 0x40 ...   |\\n            // |-------------------|---------------------------------------------------------------------------|\\n            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |\\n            // | salt              |                                      BBBBBBBBBBBBB...BB                   |\\n            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\\n            // | 0xFF              |            FF                                                             |\\n            // |-------------------|---------------------------------------------------------------------------|\\n            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\\n            // | keccak(start, 85) |            \\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191 |\\n\\n            mstore(add(ptr, 0x40), bytecodeHash)\\n            mstore(add(ptr, 0x20), salt)\\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\\n            mstore8(start, 0xff)\\n            addr := keccak256(start, 85)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xafc07f37809f74d9c66d6461cc0f85fb5147ab855acd0acc30af4b2272130c61\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/StorageSlot.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xd5c50c54bf02740ebd122ff06832546cb5fa84486d52695a9ccfd11666e0c81d\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa1e8e83cd0087785df04ac79fb395d9f3684caeaf973d9e2c71caef723a3a5d6\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SignedMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf92515413956f529d95977adc9b0567d583c6203fc31ab1c23824c35187e3ddc\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60e0604090808252346200019b57806200556b803803809162000023828562000211565b83398101039060c082126200019b576200003d8162000235565b916080602091601f1901126200019b578351608081016001600160401b03811182821017620001fd578552818301518152848301519082810191825260608401519286820193845260a06080860151956060840196875201519560018060a01b03908188168098036200019b57806080521687516389a3027160e01b81528281600481855afa8015620001f35783915f91620001b1575b5060a052885163a2060bcf60e01b815291829060049082905afa918215620001a7575f9262000165575b505060c05251600655516007555160085551600955600a80546001600160a01b0319169190911790555161532090816200024b8239608051816124e6015260a05181612112015260c051818181611a4801528181611f2201528181613fd301526143600152f35b90809250813d83116200019f575b6200017f818362000211565b810103126200019b57620001939062000235565b5f80620000fe565b5f80fd5b503d62000173565b88513d5f823e3d90fd5b82819392503d8311620001eb575b620001cb818362000211565b810103126200019b57600491620001e3849262000235565b9092620000d4565b503d620001bf565b89513d5f823e3d90fd5b634e487b7160e01b5f52604160045260245ffd5b601f909101601f19168101906001600160401b03821190821017620001fd57604052565b51906001600160a01b03821682036200019b5756fe608080604052600436101562000013575f80fd5b5f905f3560e01c908163032bb44314620031695750806303b1faf31462002fe257806306ae70951462002f8f578063132d4eb11462002ed55780631af3a6e61462002e155780632b7ac3f31462002dc157806332878cc91462002d4e57806332cd1a9a1462002b075780633f4ba83a1462002a13578063485cc955146200281f57806351b4c18d14620027ae578063554bab3c14620026e4578063583dec3214620025cb5780635872fe45146200258957806358c81fcb146200250a5780635c60da1b14620024995780635c975abb146200243a5780635d33db3c146200234a57806378fab5c7146200230e5780637fefe80914620022b25780638456cb59146200218d578063872053a6146200213657806389a3027114620020c55780638c29933e146200202c5780638da5cb5b1462001fb95780639fd0506d1462001f46578063a2060bcf1462001ed5578063aba30dfa1462001e99578063b20caf451462001e26578063b3684e131462001cde578063b51cf0a91462001c3c578063b5ee69551462001b72578063c0c53b8b1462001979578063c402f86014620016a1578063d55cde1f1462001440578063db06b6ae1462000a4f578063e30c397814620009dc578063ebbc4965146200088f578063f2842ace14620006b0578063f72e323c14620002615763fddc205f146200020b575f80fd5b346200025e57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e57602073ffffffffffffffffffffffffffffffffffffffff600a5416604051908152f35b80fd5b50346200025e5760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e576200029d62003285565b8173ffffffffffffffffffffffffffffffffffffffff828116906024908135845b848652602060048152604087208388528152604087205482101562000389578587526004815260408720908388525282620002fd82604089206200336c565b90549060031b1c16803b15620003855786809186604051809481937f6a256b290000000000000000000000000000000000000000000000000000000083528b60048401525af19081156200037a5787916200035e575b5050600101620002be565b6200036990620033af565b6200037657855f62000353565b8580fd5b6040513d89823e3d90fd5b8680fd5b5050915084926200039b8385620039d6565b94915015620006865782620003b08662003838565b1691865b8551811015620004b4578188526020600481526040892090848a525287620003e082604083206200336c565b905482620003ef858b620039b3565b511262000403575b505050600101620003b4565b6200040f848a620039b3565b5190873b15620004b0576040517fe1638ba300000000000000000000000000000000000000000000000000000000815260039390931b1c881673ffffffffffffffffffffffffffffffffffffffff1660048301526024820152818180604481010381838a5af18015620004a55762000489575b80620003f7565b6200049490620033af565b620004a157878962000482565b8780fd5b6040513d84823e3d90fd5b8380fd5b50865b8551811015620005a4578188526020600481526040892090848a525287620004e382604083206200336c565b905482620004f2858b620039b3565b511362000506575b505050600101620004b7565b62000512848a620039b3565b5190873b15620004b0576040517fe1638ba300000000000000000000000000000000000000000000000000000000815260039390931b1c881673ffffffffffffffffffffffffffffffffffffffff1660048301526024820152818180604481010381838a5af18015620004a5576200058c575b80620004fa565b6200059790620033af565b620004a157878962000585565b87620006838385620005dc8b82847fd58ec24dc80af351d45ae5fa8586232e0013343355190b0ef9b77bd8dbb68d718880a362003838565b9184526005602052604084209084526020526200065b6040842054916200062e604051938492602084016020909392919373ffffffffffffffffffffffffffffffffffffffff60408201951681520152565b037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0810183528262003465565b62000665620034a7565b60405190620006748262003448565b5f82525f602083015262003d03565b80f35b60046040517fdc72f280000000000000000000000000000000000000000000000000000000008152fd5b50346200025e5780620006c33662003224565b9060608301620006dd620006d782620034fa565b62003838565b93604081013593620007226040516200065b816200062e898b602084016020909392919373ffffffffffffffffffffffffffffffffffffffff60408201951681520152565b73ffffffffffffffffffffffffffffffffffffffff809616956001541690813b15620004a1576200079694620007c6928992836040518096819582947fcb5cd5090000000000000000000000000000000000000000000000000000000084528a359d8e600486015260208c019d8e62003572565b151560248601526044850152620007b1606485018d620036c1565b61014061012485015261014484019162003785565b03925af19081156200037a57879162000877575b5050620007f96080620007f16200080094620034fa565b9201620034fa565b90620044c3565b358015158091036200087257823b156200087257604484928360405195869485937f38d07436000000000000000000000000000000000000000000000000000000008552600485015260248401525af18015620004a5576200085f5750f35b6200086a90620033af565b6200025e5780f35b505050fd5b6200088290620033af565b6200037657855f620007da565b50346200025e57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e577f675c83682abbc3e7dd47e40515a778fbbde4393395c3dd3588244203c3e47883805473ffffffffffffffffffffffffffffffffffffffff811690813303620009ac577fe7742ddf0fecd2926e7ef4d6d6e91a7b2f0b1f8805b78953dac8454e86273ed255807f4ffd725fc4a22075e9ec71c59edf9c38cdeb588a91b24fc5b61388c5be41282b5f80a233036200097c57819055807f69f201bc2089b9be6195d876d97a0136b4cf56bbf8986a52dcb50697f7d1cac58180a280f35b60246040517f99bf6359000000000000000000000000000000000000000000000000000000008152336004820152fd5b60246040517fd0d5e1b0000000000000000000000000000000000000000000000000000000008152336004820152fd5b50346200025e57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e5760207f675c83682abbc3e7dd47e40515a778fbbde4393395c3dd3588244203c3e478835473ffffffffffffffffffffffffffffffffffffffff60405191168152f35b50346200025e5760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e5767ffffffffffffffff9081600435116200025e5760043536036101607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc8201126200143c57602435838111620014385762000ae1903690600401620031f3565b73ffffffffffffffffffffffffffffffffffffffff6001541691823b156200143457604051937fbbcb5741000000000000000000000000000000000000000000000000000000008552604060048601526004356004013560448601527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdd602460043501359101811215620003765760043501956004870135116200143457600486013560051b360360248701136200143457610160606485015260048601356101a48501526101c48401956024810190865b60048201358110620013f857505050602062000bda6044600435016004356004016200351c565b8689037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffbc0160848801528089529790910196865b818110620013d7575050509183858162000c838299829684986064600435013560a48601526084600435013560c486015262000c5360e4860160a460043501620036c1565b7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc85840301602486015262003785565b03925af18015620004a557620013bf575b505062000cba62000caa60a460043501620034fa565b620007f960c460043501620034fa565b62000cca60a460043501620034fa565b60043560040135158015620013ae575b6200138457600462000cf460248235018235830162004859565b9050116200135a57815b73ffffffffffffffffffffffffffffffffffffffff82168352600460205260408320600435600401358452602052604083205481101562000e0f5760019073ffffffffffffffffffffffffffffffffffffffff8316845260046020526040842060043560040135855260205273ffffffffffffffffffffffffffffffffffffffff62000d8e82604087206200336c565b919054600392831b1c169073ffffffffffffffffffffffffffffffffffffffff8516865260026020526040862060043560040135875260205260408620825f526020525f8460408220828155015573ffffffffffffffffffffffffffffffffffffffff8516865260205260408520905f526020525f60408120550162000cfe565b5073ffffffffffffffffffffffffffffffffffffffff81168252600460205260408220600435600401358352602052604082208054908381558162001334575b5050819082915b62000e6c60246004350160043560040162004859565b9050831015620012565773ffffffffffffffffffffffffffffffffffffffff8216845260036020526040842073ffffffffffffffffffffffffffffffffffffffff62000ed962000ed38662000ecc60246004350160043560040162004859565b90620048b0565b620034fa565b165f5260205260405f205480620011ea575073ffffffffffffffffffffffffffffffffffffffff8216845260036020526040842073ffffffffffffffffffffffffffffffffffffffff62000f4162000ed38662000ecc60246004350160043560040162004859565b165f526020526004356004013560405f205562000f758362000f6e604460043501600435600401620048c1565b9062004918565b73ffffffffffffffffffffffffffffffffffffffff831685526002602052604085206004356004013586526020526040852073ffffffffffffffffffffffffffffffffffffffff62000fdb62000ed38762000ecc60246004350160043560040162004859565b165f526020526001602060405f209280358455013591015573ffffffffffffffffffffffffffffffffffffffff821684526004602052604084206004356004013585526020526040842073ffffffffffffffffffffffffffffffffffffffff6200105962000ed38662000ecc60246004350160043560040162004859565b169080549068010000000000000000821015620011bd579162001089826200110d9460018097950181556200336c565b73ffffffffffffffffffffffffffffffffffffffff829392549160031b92831b921b191617905573ffffffffffffffffffffffffffffffffffffffff84168652600560205260408620600435600401358752602052606460043501356040872055620011058562000f6e604460043501600435600401620048c1565b359062004801565b926200112d62000ed38262000ecc60246004350160043560040162004859565b73ffffffffffffffffffffffffffffffffffffffff6200115d8362000f6e604460043501600435600401620048c1565b916020604051938035855201356020840152169060043560040135907f499f2d584337dd47a4e71a8a4c57b77ad0058bb1a360335a855979a5ca3061d4604073ffffffffffffffffffffffffffffffffffffffff881692a4019162000e56565b6024877f4e487b710000000000000000000000000000000000000000000000000000000081526041600452fd5b60449073ffffffffffffffffffffffffffffffffffffffff6200122162000ed38762000ecc60246004350160043560040162004859565b1690604051917fe21464ba00000000000000000000000000000000000000000000000000000000835260048301526024820152fd5b9091506200126f60246004350160043560040162004859565b9050151590816200131c575b50620012f2576200129760246004350160043560040162004859565b90506040519081527f18fea070ebed40821f9c45ae1f8c875c49b031e4ff3b701b4772ade527f51088602073ffffffffffffffffffffffffffffffffffffffff60043560040135941692a362000683608460043501620045bf565b60046040517f64580a1c000000000000000000000000000000000000000000000000000000008152fd5b600191506200132b9062004ac6565b14155f6200127b565b83526020832090815b81830181106200134e575062000e4f565b5f81556001016200133d565b60046040517fecce9fda000000000000000000000000000000000000000000000000000000008152fd5b60046040517fa16ba7f2000000000000000000000000000000000000000000000000000000008152fd5b506008600435600401351162000cda565b620013ca90620033af565b6200025e57805f62000c94565b82358952602080840135908a01526040988901989092019160010162000c0e565b909197600160208060049373ffffffffffffffffffffffffffffffffffffffff620014238e620032cd565b168152019a01939201905062000bb3565b8480fd5b8280fd5b5080fd5b50346200025e577ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36016101e081126200143c576101a0136200025e576101a467ffffffffffffffff8135818111620004b057620014a3903690600401620031f3565b6101c49291929182359081116200037657620014c4903690600401620031f3565b92909373ffffffffffffffffffffffffffffffffffffffff92836001541691823b156200169d57604051917ff5ba0b1d0000000000000000000000000000000000000000000000000000000083526200152060048401620035f5565b60c435938460c485015260e43595878716808803620016995760e4860152610104803590898216809203620016995786015261012480359b898d16809d036200169957620015a38e9d9688968f98956101c089979588968c9888015261014480359088015261016480359088015261018480359088015286015284019162003785565b03925af19081156200037a57879162001681575b50506200065b620015db6200160d93620006d7620015d4620034d5565b82620044c3565b6040805173ffffffffffffffffffffffffffffffffffffffff909216602083015281019290925281606081016200062e565b600a541691823b1562000872576200166e928492836040518096819582947f3a1505ca0000000000000000000000000000000000000000000000000000000084526200165c60048501620035f5565b60e060c485015260e484019162003785565b03925af18015620004a5576200085f5750f35b6200168c90620033af565b6200037657855f620015b7565b5f80fd5b8880fd5b50346200025e577ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360161020081126200143c576101c0136200025e5767ffffffffffffffff6101c435818111620014385762001703903690600401620031f3565b916101e435908111620004b05762001720903690600401620031f3565b909173ffffffffffffffffffffffffffffffffffffffff6001541690813b156200037657604051907f834a0d48000000000000000000000000000000000000000000000000000000008252600435600483015262001781602483016200365b565b60e43560e483015273ffffffffffffffffffffffffffffffffffffffff61010435166101043503620016995773ffffffffffffffffffffffffffffffffffffffff61010435166101048301526101249283359373ffffffffffffffffffffffffffffffffffffffff85169081860362001699578401526101449081359273ffffffffffffffffffffffffffffffffffffffff8416809403620016995789856200185f819593839c849884968501526101648035908501526101848035908501526101a48035908501526101e06101c48501526101e484019162003785565b03925af19081156200196e57859162001956575b50506200188a9062001884620034d5565b620044c3565b620018d66200062e6200065b620018a46101043562003838565b6040805173ffffffffffffffffffffffffffffffffffffffff909216602083015260e435908201529182906060820190565b73ffffffffffffffffffffffffffffffffffffffff600a541691823b1562000872576200166e928492836040518096819582947f715a86c5000000000000000000000000000000000000000000000000000000008452600435600485015262001942602485016200365b565b61010060e485015261010484019162003785565b6200196190620033af565b6200087257835f62001873565b6040513d87823e3d90fd5b50346200025e5760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e57620019b562003285565b620019bf620032a9565b6044359073ffffffffffffffffffffffffffffffffffffffff9182811680910362001434577f6fee9688c285c5c5c97d6a1a29adced674e6b2ad0888b8ad2116b58a8b3ea24860028154101562001b415760029055303b15158062001b39575b62001b0f577f2b50211693ec91bcfe327771928b74a8f475c508d53e86fca4153bcf0f0e8776557f00000000000000000000000000000000000000000000000000000000000000007f5b5cbfa852c5bd03e540eba853f8faf28a604a4d82bee1091096bfaea14d08c355817fffffffffffffffffffffffff000000000000000000000000000000000000000093168385541617845516906001541617600155807f2801b00eb06461cf9fcb9758b5fafd884ff06a86177386f73b6c49f0bf5a5af0557fbe9b076dc5b65990cca9dd9d7366682482e7817a6f6bc7f4faf4dc32af497f32602060405160028152a180f35b60046040517fb9a621e1000000000000000000000000000000000000000000000000000000008152fd5b508462001a1f565b60246040517f3db738da00000000000000000000000000000000000000000000000000000000815260026004820152fd5b50346200025e5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e5762001bae62003285565b7fe7742ddf0fecd2926e7ef4d6d6e91a7b2f0b1f8805b78953dac8454e86273ed2549073ffffffffffffffffffffffffffffffffffffffff9182339116036200097c57807f675c83682abbc3e7dd47e40515a778fbbde4393395c3dd3588244203c3e4788355167f69f201bc2089b9be6195d876d97a0136b4cf56bbf8986a52dcb50697f7d1cac58280a280f35b50346200025e5760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e5762001c8662001c7c62003285565b60243590620039d6565b90919260405193849360608501918552602090151560208601526060604086015283518092526020608086019401925b82811062001cc657505050500390f35b83518552869550938101939281019260010162001cb6565b50346200025e578062001cf136620032ef565b9190939273ffffffffffffffffffffffffffffffffffffffff91826001541691823b15620004a15762001d72928892836040518096819582947fde4030ed00000000000000000000000000000000000000000000000000000000845262001d5d8d6004860190620037c3565b6102006101e485015261020484019162003785565b03925af190811562001e1b57869162001e03575b505062001daa62001d9b6101208501620034fa565b620007f96101408601620034fa565b62001db96101008401620045bf565b845416803b1562001434576200166e93858094604051968795869485937fc655a23d0000000000000000000000000000000000000000000000000000000085526004850162003801565b62001e0e90620033af565b6200143457845f62001d86565b6040513d88823e3d90fd5b50346200025e57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e57602073ffffffffffffffffffffffffffffffffffffffff7f2b50211693ec91bcfe327771928b74a8f475c508d53e86fca4153bcf0f0e87765416604051908152f35b50346200025e57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e576020604051608c8152f35b50346200025e57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e57602060405173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b50346200025e57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e5760207f18e50ee9696440d335192aeeeffc26f47782eaa914f1700d8ad36d6d7f7261b35473ffffffffffffffffffffffffffffffffffffffff60405191168152f35b50346200025e57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e5760207fe7742ddf0fecd2926e7ef4d6d6e91a7b2f0b1f8805b78953dac8454e86273ed25473ffffffffffffffffffffffffffffffffffffffff60405191168152f35b50346200025e5760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e576200206862003285565b6044359173ffffffffffffffffffffffffffffffffffffffff80921681526004602052604081206024358252602052604081209081548410156200025e5750602092620020b5916200336c565b9190546040519260031b1c168152f35b50346200025e57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e57602060405173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b50346200025e57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e57608060065460075460085460095491604051938452602084015260408301526060820152f35b50346200025e57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e5773ffffffffffffffffffffffffffffffffffffffff807f18e50ee9696440d335192aeeeffc26f47782eaa914f1700d8ad36d6d7f7261b35416331415908162002283575b50620022535760017f3d13b7e57307bea7f94c474c597247d2da93d7de9136f8e123ed6525f50bbcec557f9e87fac88ff661f02d44f95383c817fece4bce600a3dab7a54406878b965e7528180a180f35b60246040517ff7987a92000000000000000000000000000000000000000000000000000000008152336004820152fd5b90507fe7742ddf0fecd2926e7ef4d6d6e91a7b2f0b1f8805b78953dac8454e86273ed254163314155f62002202565b50346200025e57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e576020620022f033620046a6565b73ffffffffffffffffffffffffffffffffffffffff60405191168152f35b50346200025e57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e57602060405160108152f35b50346200025e5760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e576200238662003285565b9073ffffffffffffffffffffffffffffffffffffffff80921681526020906004825260408120602435825282526040812090604051808484549182815201908194845285842090845b818110620024235750505081620023e891038262003465565b6040519380850191818652518092526040850193925b8281106200240c5785850386f35b8351871685529381019392810192600101620023fe565b8254891684529287019260019283019201620023cf565b50346200025e57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e5760207f3d13b7e57307bea7f94c474c597247d2da93d7de9136f8e123ed6525f50bbcec546040519015158152f35b50346200025e57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e57602060405173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b50346200025e5760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e576200254662003285565b604062002552620032a9565b9273ffffffffffffffffffffffffffffffffffffffff809316815260036020522091165f52602052602060405f2054604051908152f35b50346200025e5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e576020620022f0620006d762003285565b50346200025e5780620025de36620032ef565b9190939273ffffffffffffffffffffffffffffffffffffffff91826001541691823b15620004a1576200264a928892836040518096819582947ff50c862800000000000000000000000000000000000000000000000000000000845262001d5d8d6004860190620037c3565b03925af190811562001e1b578691620026cc575b50506200267362001d9b6101208501620034fa565b620026826101008401620045bf565b845416803b1562001434576200166e93858094604051968795869485937faac3454b0000000000000000000000000000000000000000000000000000000085526004850162003801565b620026d790620033af565b6200143457845f6200265e565b50346200025e5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e576200272062003285565b7fe7742ddf0fecd2926e7ef4d6d6e91a7b2f0b1f8805b78953dac8454e86273ed2549073ffffffffffffffffffffffffffffffffffffffff9182339116036200097c57807f18e50ee9696440d335192aeeeffc26f47782eaa914f1700d8ad36d6d7f7261b355167fa4336c0cb1e245b95ad204faed7e940d6dc999684fd8b5e1ff597a0c4efca8ab8280a280f35b50346200025e5760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e57604060209173ffffffffffffffffffffffffffffffffffffffff6200280462003285565b16815260058352818120602435825283522054604051908152f35b50346200025e5760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e576200285b62003285565b62002865620032a9565b60017f6fee9688c285c5c5c97d6a1a29adced674e6b2ad0888b8ad2116b58a8b3ea2488181541015620029e2578190557f2801b00eb06461cf9fcb9758b5fafd884ff06a86177386f73b6c49f0bf5a5af092818455303b151580620029da575b62001b0f57303b151580620029d2575b62001b0f5773ffffffffffffffffffffffffffffffffffffffff937fe7742ddf0fecd2926e7ef4d6d6e91a7b2f0b1f8805b78953dac8454e86273ed29185835416620029a8577fbe9b076dc5b65990cca9dd9d7366682482e7817a6f6bc7f4faf4dc32af497f32956020958894339055337f4ffd725fc4a22075e9ec71c59edf9c38cdeb588a91b24fc5b61388c5be41282b5f80a2817fffffffffffffffffffffffff0000000000000000000000000000000000000000931683865416178555169084541617835555604051908152a180f35b60046040517fe43bdd4e000000000000000000000000000000000000000000000000000000008152fd5b5084620028d5565b5084620028c5565b602482604051907f3db738da0000000000000000000000000000000000000000000000000000000082526004820152fd5b50346200025e57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e5773ffffffffffffffffffffffffffffffffffffffff807f18e50ee9696440d335192aeeeffc26f47782eaa914f1700d8ad36d6d7f7261b35416331415908162002ad8575b506200225357807f3d13b7e57307bea7f94c474c597247d2da93d7de9136f8e123ed6525f50bbcec557fa45f47fdea8a1efdd9029a5691c7f759c32b7c698632b563573e155625d169338180a180f35b90507fe7742ddf0fecd2926e7ef4d6d6e91a7b2f0b1f8805b78953dac8454e86273ed254163314155f62002a88565b50346200025e57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc60608136011262002d4b5767ffffffffffffffff6004358181116200087257803603926101009081818601126200037657602435848111620003855762002b7c903690600401620031f3565b94604435908111620004a15762002b98903690600401620031f3565b93909573ffffffffffffffffffffffffffffffffffffffff92836001541692833b1562002d4757604051917f191190bc000000000000000000000000000000000000000000000000000000008352604060048401527ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffefd89600401359b018b121562002d435762002c6794838d8162002c768f8e9983978e6044602462002c508f968a9e848b01526004886101448c019201016200372d565b9501803560648901529d019d608487018f620036c1565b85840301602486015262003785565b03925af190811562002d38578a9162002d20575b505062002cad62002c9f62002cb393620034fa565b620007f960648901620034fa565b620045bf565b86541691823b15620003855762002d10956200166e60049389979388946040519a8b998a9889977fb557198f0000000000000000000000000000000000000000000000000000000089526040828a0152604489019201016200372d565b9285840301602486015262003785565b62002d2b90620033af565b6200169d57885f62002c8a565b6040513d8c823e3d90fd5b8b80fd5b8a80fd5b50fd5b50346200025e57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e5760207f5b5cbfa852c5bd03e540eba853f8faf28a604a4d82bee1091096bfaea14d08c35473ffffffffffffffffffffffffffffffffffffffff60405191168152f35b50346200025e57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e57602073ffffffffffffffffffffffffffffffffffffffff60015416604051908152f35b50346200025e5760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e5762002e5162003285565b60443573ffffffffffffffffffffffffffffffffffffffff8082168092036200169957604093849182519462002e8786620033f1565b82865282602080970152168152600284528181206024358252845220905f528152815f2090825162002eb981620033f1565b8160018454948584520154910190815283519283525190820152f35b50346200025e5762002ee73662003224565b9073ffffffffffffffffffffffffffffffffffffffff62002f0f620006d760608601620034fa565b169260405193806020860152604082013560408601526040855262002f34856200342b565b62002f43602083013562004929565b6002811490811562002f83575b501562002f705762002f6a620006839562000665620034a7565b6200424e565b91620006839493916200065b936200424e565b60019150145f62002f50565b50346200025e57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e5773ffffffffffffffffffffffffffffffffffffffff6020915416604051908152f35b50346200169957610100367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc01818112620016995760e013620016995760e43567ffffffffffffffff8111620016995762003042903690600401620031f3565b73ffffffffffffffffffffffffffffffffffffffff92916024359184831683036200169957846001541691823b156200169957620030d2925f92836040518096819582947f8008e3490000000000000000000000000000000000000000000000000000000084526004359b8c6004860152620030c1602486016200365b565b60e485015261010484019162003785565b03925af180156200315e5762003148575b50604435928084168403620016995762003111826200310b62000683966200065b95620044c3565b620046a6565b166200062e604051938492602084016020909392919373ffffffffffffffffffffffffffffffffffffffff60408201951681520152565b62003155919450620033af565b5f925f620030e3565b6040513d5f823e3d90fd5b34620016995760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011262001699576004359073ffffffffffffffffffffffffffffffffffffffff821680920362001699576020915f527f81796b4965de195665289d95668a8a9e7020858e15f5341c42bcf9951c1768ad825260ff60405f20541615158152f35b9181601f84011215620016995782359167ffffffffffffffff83116200169957602083818601950101116200169957565b907ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc820161014081126200169957610120136200169957600491610124359067ffffffffffffffff821162001699576200328191600401620031f3565b9091565b6004359073ffffffffffffffffffffffffffffffffffffffff821682036200169957565b6024359073ffffffffffffffffffffffffffffffffffffffff821682036200169957565b359073ffffffffffffffffffffffffffffffffffffffff821682036200169957565b907ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc8201610220811262001699576101e013620016995760049167ffffffffffffffff916101e4358381116200169957826200334e91600401620031f3565b939093926102043591821162001699576200328191600401620031f3565b805482101562003382575f5260205f2001905f90565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b67ffffffffffffffff8111620033c457604052565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b6040810190811067ffffffffffffffff821117620033c457604052565b6080810190811067ffffffffffffffff821117620033c457604052565b6060810190811067ffffffffffffffff821117620033c457604052565b6020810190811067ffffffffffffffff821117620033c457604052565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff821117620033c457604052565b60405190620034b6826200340e565b6006548252600754602083015260085460408301526009546060830152565b6101043573ffffffffffffffffffffffffffffffffffffffff81168103620016995790565b3573ffffffffffffffffffffffffffffffffffffffff81168103620016995790565b90357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1823603018112156200169957016020813591019167ffffffffffffffff821162001699578160061b360383136200169957565b359081151582036200169957565b620035b26020809273ffffffffffffffffffffffffffffffffffffffff620035a882620032cd565b1685520162003572565b1515910152565b916020908281520191905f5b818110620035d35750505090565b90919280620035e56001928662003580565b60409081019401929101620035c5565b60043573ffffffffffffffffffffffffffffffffffffffff908181168091036200169957825260243581811680910362001699576020830152604435908116809103620016995760408201526064356060820152608435608082015260a060a435910152565b60243573ffffffffffffffffffffffffffffffffffffffff90818116809103620016995782526044358181168091036200169957602083015260643590811680910362001699576040820152608435606082015260a435608082015260a060c435910152565b60a0809173ffffffffffffffffffffffffffffffffffffffff80620036e683620032cd565b16855280620036f860208401620032cd565b1660208601526200370c60408301620032cd565b16604085015260608101356060850152608081013560808501520135910152565b6200378290604080620037786200375a6101006200374c86806200351c565b9091808a52890191620035b9565b6200376960208601866200351c565b9088830360208a0152620035b9565b94019101620036c1565b90565b601f82602094937fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe093818652868601375f8582860101520116010190565b620037ff91620037d4818362003580565b620037e66040820160408401620036c1565b61010080830135908201526101208091019101620036c1565b565b9062003782939162003829610120926200381c838262003580565b60408084019101620036c1565b81610100820152019162003785565b600b6055917fa7061a14e3ecf6b6005ae012e8d4e1b45b16518ae5b5553dad6dcd441776ee67604091825173ffffffffffffffffffffffffffffffffffffffff6020927fc4d66de8000000000000000000000000000000000000000000000000000000008484015216602482015260248152620038b5816200342b565b620039206200392d8361072f93875190620038d38387018362003465565b8582528282019562004bbc87398851620038f7816200062e86820194308662004677565b895195869362003910868601998a92519283916200460f565b840191518093868401906200460f565b0103808452018262003465565b5190208351938401528201523081520160ff81532090565b67ffffffffffffffff8111620033c45760051b60200190565b906200396a8262003945565b62003979604051918262003465565b8281527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0620039a9829462003945565b0190602036910137565b8051821015620033825760209160051b010190565b519081151582036200169957565b90915f925f73ffffffffffffffffffffffffffffffffffffffff80941694855f52600492602096848852604091825f20815f52895262003a19835f20546200395e565b935f955b855187101562003b6857835f52878b52845f20835f528b5262003a4387865f206200336c565b905490858c8b895193849384927f5b4b96950000000000000000000000000000000000000000000000000000000084528301526080948593602497889360031b1c165afa91821562003b5e57908892915f9262003afc575b50500151918262003aad8a8a620039b3565b525f838201938412911290801582169115161762003ad2575060019096019562003a1d565b6011897f4e487b71000000000000000000000000000000000000000000000000000000005f52525ffd5b8193508092503d831162003b56575b62003b17818362003465565b810103126200169957865187918e62003b30836200340e565b8151835280820151908301528281015183830152606080910151908201525f8062003a9b565b503d62003b0b565b88513d5f823e3d90fd5b92955090989398979697959295829762003b838b516200395e565b965f9973C10C99d010e8C7422f5fF0EBD2604A872Da64307945b8d518c101562003cf3578a8e62003c128e865f528b8d52835f20895f528d528c8862003bcc83875f206200336c565b929054908a5f5260028152875f20908d5f5252865f209260031b1c165f528d526001845f2094519462003bff86620033f1565b805486520154928d8501938452620039b3565b51908d51927fffc39dba000000000000000000000000000000000000000000000000000000008452518b84015251602483015288604483015260648201528b816084818a5af4801562003ce957908d92918c5f925f9262003c99575b5060019462003c7d91620039b3565b52811562003c90575b509b019a62003b9d565b90505f62003c86565b94505050508b82813d831162003ce1575b62003cb6818362003465565b810103126200169957818b62003c7d8f8d62003cd4600197620039c8565b9401519291509462003c6e565b503d62003caa565b8c513d5f823e3d90fd5b9b99509b50505050505050509150565b92915f9380519460209384830151961560011715620042215762003d3f96670de0b6b3a764000097889162003d39489162004827565b62004845565b04906040906060828601519501519051608c810180911162004221576004957f0fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82168203620041f5578351917ff5d6ded700000000000000000000000000000000000000000000000000000000835289838981606c5afa928315620040c35790888d9493925f94620041b8575b508462003dee62003d399462003d3962003dfd98999562003df6951b62004827565b049162004827565b9062004801565b049262003e0b848462004801565b9573ffffffffffffffffffffffffffffffffffffffff998a7f2b50211693ec91bcfe327771928b74a8f475c508d53e86fca4153bcf0f0e8776541697845180997ffeaf968c000000000000000000000000000000000000000000000000000000008252818a60a09c8d935afa908115620041ae575f916200415d575b508281029080820584149015171562004131576305f5e1009005905f821262004102579062003eb69162004845565b048382805181010312620016995788820151918b8316809303620016995784015164e8d4a5100090818102918183041490151715620040d65780821015620040cd5750955b813b15620016995783517f0b220c3900000000000000000000000000000000000000000000000000000000815287828201525f60248201525f8160448183875af18015620040c357620040ad575b508351917f23b872dd000000000000000000000000000000000000000000000000000000008a8401526024830152306044830152866064830152606482528782019082821067ffffffffffffffff8311176200408157509962003ff962004066927ffa0333956d06e335c550bd5fc4ac9c003c6545e371331b1071fa4d5d8519d6c19a9b9c8652827f00000000000000000000000000000000000000000000000000000000000000001662004947565b7f5b5cbfa852c5bd03e540eba853f8faf28a604a4d82bee1091096bfaea14d08c354908451917fa9059cbb000000000000000000000000000000000000000000000000000000008c840152336024840152886044840152604483526200405f836200340e565b1662004947565b815197818952880152860152606085015260808401523392a2565b6041907f4e487b71000000000000000000000000000000000000000000000000000000005f525260245ffd5b620040ba919350620033af565b5f915f62003f49565b85513d5f823e3d90fd5b90509562003efb565b6011887f4e487b71000000000000000000000000000000000000000000000000000000005f525260245ffd5b602489838851917f501f289e000000000000000000000000000000000000000000000000000000008352820152fd5b6011897f4e487b71000000000000000000000000000000000000000000000000000000005f525260245ffd5b90508981813d8311620041a6575b62004177818362003465565b8101031262001699576200418b816200480f565b506200419e60808c83015192016200480f565b505f62003e87565b503d6200416b565b86513d5f823e3d90fd5b9350509092508982813d8311620041ed575b620041d6818362003465565b81010312620016995790518b929091888462003dcc565b503d620041ca565b6011877f4e487b71000000000000000000000000000000000000000000000000000000005f525260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b6001545f9473ffffffffffffffffffffffffffffffffffffffff918216949390853b1562001699575f80620042e6604098899889519485809481937fc4786d9b0000000000000000000000000000000000000000000000000000000083528b620042b88c620032cd565b16600484015260208b01359d8e60248501528b0135604484015260608b0199620007b1606485018c620036c1565b03925af18015620044b95762004498575b50829162000ed36200430d6200431b93620034fa565b620007f960808401620034fa565b169184517ffc0c546a000000000000000000000000000000000000000000000000000000008152602081600481875afa9081156200448e5787916200444c575b5082807f0000000000000000000000000000000000000000000000000000000000000000169116036200441c571690813b15620014345783517fe1638ba300000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff919091166004820152602481019290925290919083908390604490829084905af1908115620044135750620043ff575050565b6200440b8291620033af565b6200025e5750565b513d84823e3d90fd5b6024838651907f950cd0710000000000000000000000000000000000000000000000000000000082526004820152fd5b90506020813d60201162004485575b816200446a6020938362003465565b81010312620003855751828116810362000385575f6200435b565b3d91506200445b565b86513d89823e3d90fd5b6200431b91975091620044ac8493620033af565b5f979092909150620042f7565b87513d5f823e3d90fd5b9073ffffffffffffffffffffffffffffffffffffffff8080931691168181141592836200451f575b505050620044f557565b60046040517f43e749f8000000000000000000000000000000000000000000000000000000008152fd5b60209293506044905f54169360405194859384927fbd9ee66b000000000000000000000000000000000000000000000000000000008452600484015260248301525afa9081156200315e575f916200457d575b50155f8080620044eb565b90506020813d602011620045b6575b816200459b6020938362003465565b810103126200169957620045af90620039c8565b5f62004572565b3d91506200458c565b620037ff906200065b620045da620006d760208401620034fa565b6040805173ffffffffffffffffffffffffffffffffffffffff909216602083015292359281019290925281606081016200062e565b5f5b838110620046215750505f910152565b818101518382015260200162004611565b907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f60209362004670815180928187528780880191016200460f565b0116010190565b60409073ffffffffffffffffffffffffffffffffffffffff620037829493168152816020820152019062004632565b90604051917fc4d66de800000000000000000000000000000000000000000000000000000000602084015273ffffffffffffffffffffffffffffffffffffffff8091169283602482015260248152620046ff816200342b565b60405161072f8082019082821067ffffffffffffffff831117620033c4577fa7061a14e3ecf6b6005ae012e8d4e1b45b16518ae5b5553dad6dcd441776ee67938392620047549262004bbc8539309062004677565b03905ff580156200315e5716805f527f81796b4965de195665289d95668a8a9e7020858e15f5341c42bcf9951c1768ad60205260405f2060017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00825416179055807f4fe45192317a7d3ad19c3eaa395c0c3a1b7a0f53c3536fb96764c3561a8e9dad5f80a280927f2682a218602b9036c9869f006c5405ee4a1a65267653eb7e286123e5e1afde4c5f80a3565b919082018092116200422157565b519069ffffffffffffffffffff821682036200169957565b90670de0b6b3a7640000918281029281840414901517156200422157565b818102929181159184041417156200422157565b9035907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe18136030182121562001699570180359067ffffffffffffffff82116200169957602001918160051b360383136200169957565b9190811015620033825760051b0190565b9035907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe18136030182121562001699570180359067ffffffffffffffff82116200169957602001918160061b360383136200169957565b9190811015620033825760061b0190565b5f811362004941575f136200493d57600190565b5f90565b50600290565b73ffffffffffffffffffffffffffffffffffffffff166040516200496b81620033f1565b5f806020948584527f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c656486850152858151910182865af13d1562004ab7573d9067ffffffffffffffff8211620033c45762004a049360405192620049f6877fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f840116018562003465565b83523d5f8785013e62004ae5565b80518062004a1157505050565b8183918101031262001699578162004a2a9101620039c8565b1562004a335750565b608490604051907f08c379a00000000000000000000000000000000000000000000000000000000082526004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e60448201527f6f742073756363656564000000000000000000000000000000000000000000006064820152fd5b9162004a049260609162004ae5565b620f42409081811162004ade57106200493d57600190565b5050600290565b9192901562004b63575081511562004afb575090565b3b1562004b055790565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152fd5b82519091501562004b775750805190602001fd5b62004bb7906040519182917f08c379a000000000000000000000000000000000000000000000000000000000835260206004840152602483019062004632565b0390fdfe608060409080825261072f80380380916100198285610342565b833981019082818303126102385761003081610365565b6020828101516001600160401b039391929184821161023857019084601f830112156102385781519161006283610379565b9261006f88519485610342565b8084528484019685828401011161023857868561008c9301610394565b803b156102f0578551635c60da1b60e01b80825292916001600160a01b0316908481600481855afa9081156102e6575f916102b1575b503b15610254577fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d5080546001600160a01b03191682179055865192817f1cf3b03a6cf19fa2baba4df148e9dcabedea7f8a5c07840e207e5c089be95d3e5f80a282511580159061024d575b610140575b87516102c690816104698239f35b6004848693819382525afa918215610243575f92610208575b5085519360608501908111858210176101f4578652602784527f416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c83850152660819985a5b195960ca1b84870152516101de945f918291845af4903d156101eb573d6101c381610379565b906101d088519283610342565b81525f81943d92013e6103b5565b505f808080808080610132565b606092506103b5565b634e487b7160e01b5f52604160045260245ffd5b9091508281813d831161023c575b6102208183610342565b810103126102385761023190610365565b905f610159565b5f80fd5b503d610216565b86513d5f823e3d90fd5b505f61012d565b865162461bcd60e51b815260048101859052603060248201527f455243313936373a20626561636f6e20696d706c656d656e746174696f6e206960448201526f1cc81b9bdd08184818dbdb9d1c9858dd60821b6064820152608490fd5b90508481813d83116102df575b6102c88183610342565b81010312610238576102d990610365565b5f6100c2565b503d6102be565b88513d5f823e3d90fd5b855162461bcd60e51b815260048101849052602560248201527f455243313936373a206e657720626561636f6e206973206e6f74206120636f6e6044820152641d1c9858dd60da1b6064820152608490fd5b601f909101601f19168101906001600160401b038211908210176101f457604052565b51906001600160a01b038216820361023857565b6001600160401b0381116101f457601f01601f191660200190565b5f5b8381106103a55750505f910152565b8181015183820152602001610396565b9192901561041757508151156103c9575090565b3b156103d25790565b60405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606490fd5b82519091501561042a5750805190602001fd5b6044604051809262461bcd60e51b82526020600483015261045a8151809281602486015260208686019101610394565b601f01601f19168101030190fdfe6080806040523661011c5760208160048173ffffffffffffffffffffffffffffffffffffffff7fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d5054167f5c60da1b0000000000000000000000000000000000000000000000000000000082525afa908115610111575f91610081575b50610273565b905060203d60201161010a575b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f82011682019180831067ffffffffffffffff8411176100dd576100d792604052016101f6565b5f61007b565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b503d61008e565b6040513d5f823e3d90fd5b6004602073ffffffffffffffffffffffffffffffffffffffff7fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d505416604051928380927f5c60da1b0000000000000000000000000000000000000000000000000000000082525afa908115610111575f916101975750610273565b602091503d82116101ee575b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f83011681019181831067ffffffffffffffff8411176100dd576100d792604052810190610247565b3d91506101a3565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8060209101126102435760805173ffffffffffffffffffffffffffffffffffffffff811681036102435790565b5f80fd5b90816020910312610243575173ffffffffffffffffffffffffffffffffffffffff811681036102435790565b5f8091368280378136915af43d5f803e1561028c573d5ff35b3d5ffdfea2646970667358221220ec432b4747e143afd3ca9be003efbb7d4ac773fd8dbbac59b6729d6be9a1e1a164736f6c63430008180033a264697066735822122092ac32ec49066ecc1d2732cd373a723def46bfe1fc882018374bbcf00363fef164736f6c63430008180033",
  "deployedBytecode": "0x608080604052600436101562000013575f80fd5b5f905f3560e01c908163032bb44314620031695750806303b1faf31462002fe257806306ae70951462002f8f578063132d4eb11462002ed55780631af3a6e61462002e155780632b7ac3f31462002dc157806332878cc91462002d4e57806332cd1a9a1462002b075780633f4ba83a1462002a13578063485cc955146200281f57806351b4c18d14620027ae578063554bab3c14620026e4578063583dec3214620025cb5780635872fe45146200258957806358c81fcb146200250a5780635c60da1b14620024995780635c975abb146200243a5780635d33db3c146200234a57806378fab5c7146200230e5780637fefe80914620022b25780638456cb59146200218d578063872053a6146200213657806389a3027114620020c55780638c29933e146200202c5780638da5cb5b1462001fb95780639fd0506d1462001f46578063a2060bcf1462001ed5578063aba30dfa1462001e99578063b20caf451462001e26578063b3684e131462001cde578063b51cf0a91462001c3c578063b5ee69551462001b72578063c0c53b8b1462001979578063c402f86014620016a1578063d55cde1f1462001440578063db06b6ae1462000a4f578063e30c397814620009dc578063ebbc4965146200088f578063f2842ace14620006b0578063f72e323c14620002615763fddc205f146200020b575f80fd5b346200025e57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e57602073ffffffffffffffffffffffffffffffffffffffff600a5416604051908152f35b80fd5b50346200025e5760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e576200029d62003285565b8173ffffffffffffffffffffffffffffffffffffffff828116906024908135845b848652602060048152604087208388528152604087205482101562000389578587526004815260408720908388525282620002fd82604089206200336c565b90549060031b1c16803b15620003855786809186604051809481937f6a256b290000000000000000000000000000000000000000000000000000000083528b60048401525af19081156200037a5787916200035e575b5050600101620002be565b6200036990620033af565b6200037657855f62000353565b8580fd5b6040513d89823e3d90fd5b8680fd5b5050915084926200039b8385620039d6565b94915015620006865782620003b08662003838565b1691865b8551811015620004b4578188526020600481526040892090848a525287620003e082604083206200336c565b905482620003ef858b620039b3565b511262000403575b505050600101620003b4565b6200040f848a620039b3565b5190873b15620004b0576040517fe1638ba300000000000000000000000000000000000000000000000000000000815260039390931b1c881673ffffffffffffffffffffffffffffffffffffffff1660048301526024820152818180604481010381838a5af18015620004a55762000489575b80620003f7565b6200049490620033af565b620004a157878962000482565b8780fd5b6040513d84823e3d90fd5b8380fd5b50865b8551811015620005a4578188526020600481526040892090848a525287620004e382604083206200336c565b905482620004f2858b620039b3565b511362000506575b505050600101620004b7565b62000512848a620039b3565b5190873b15620004b0576040517fe1638ba300000000000000000000000000000000000000000000000000000000815260039390931b1c881673ffffffffffffffffffffffffffffffffffffffff1660048301526024820152818180604481010381838a5af18015620004a5576200058c575b80620004fa565b6200059790620033af565b620004a157878962000585565b87620006838385620005dc8b82847fd58ec24dc80af351d45ae5fa8586232e0013343355190b0ef9b77bd8dbb68d718880a362003838565b9184526005602052604084209084526020526200065b6040842054916200062e604051938492602084016020909392919373ffffffffffffffffffffffffffffffffffffffff60408201951681520152565b037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0810183528262003465565b62000665620034a7565b60405190620006748262003448565b5f82525f602083015262003d03565b80f35b60046040517fdc72f280000000000000000000000000000000000000000000000000000000008152fd5b50346200025e5780620006c33662003224565b9060608301620006dd620006d782620034fa565b62003838565b93604081013593620007226040516200065b816200062e898b602084016020909392919373ffffffffffffffffffffffffffffffffffffffff60408201951681520152565b73ffffffffffffffffffffffffffffffffffffffff809616956001541690813b15620004a1576200079694620007c6928992836040518096819582947fcb5cd5090000000000000000000000000000000000000000000000000000000084528a359d8e600486015260208c019d8e62003572565b151560248601526044850152620007b1606485018d620036c1565b61014061012485015261014484019162003785565b03925af19081156200037a57879162000877575b5050620007f96080620007f16200080094620034fa565b9201620034fa565b90620044c3565b358015158091036200087257823b156200087257604484928360405195869485937f38d07436000000000000000000000000000000000000000000000000000000008552600485015260248401525af18015620004a5576200085f5750f35b6200086a90620033af565b6200025e5780f35b505050fd5b6200088290620033af565b6200037657855f620007da565b50346200025e57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e577f675c83682abbc3e7dd47e40515a778fbbde4393395c3dd3588244203c3e47883805473ffffffffffffffffffffffffffffffffffffffff811690813303620009ac577fe7742ddf0fecd2926e7ef4d6d6e91a7b2f0b1f8805b78953dac8454e86273ed255807f4ffd725fc4a22075e9ec71c59edf9c38cdeb588a91b24fc5b61388c5be41282b5f80a233036200097c57819055807f69f201bc2089b9be6195d876d97a0136b4cf56bbf8986a52dcb50697f7d1cac58180a280f35b60246040517f99bf6359000000000000000000000000000000000000000000000000000000008152336004820152fd5b60246040517fd0d5e1b0000000000000000000000000000000000000000000000000000000008152336004820152fd5b50346200025e57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e5760207f675c83682abbc3e7dd47e40515a778fbbde4393395c3dd3588244203c3e478835473ffffffffffffffffffffffffffffffffffffffff60405191168152f35b50346200025e5760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e5767ffffffffffffffff9081600435116200025e5760043536036101607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc8201126200143c57602435838111620014385762000ae1903690600401620031f3565b73ffffffffffffffffffffffffffffffffffffffff6001541691823b156200143457604051937fbbcb5741000000000000000000000000000000000000000000000000000000008552604060048601526004356004013560448601527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdd602460043501359101811215620003765760043501956004870135116200143457600486013560051b360360248701136200143457610160606485015260048601356101a48501526101c48401956024810190865b60048201358110620013f857505050602062000bda6044600435016004356004016200351c565b8689037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffbc0160848801528089529790910196865b818110620013d7575050509183858162000c838299829684986064600435013560a48601526084600435013560c486015262000c5360e4860160a460043501620036c1565b7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc85840301602486015262003785565b03925af18015620004a557620013bf575b505062000cba62000caa60a460043501620034fa565b620007f960c460043501620034fa565b62000cca60a460043501620034fa565b60043560040135158015620013ae575b6200138457600462000cf460248235018235830162004859565b9050116200135a57815b73ffffffffffffffffffffffffffffffffffffffff82168352600460205260408320600435600401358452602052604083205481101562000e0f5760019073ffffffffffffffffffffffffffffffffffffffff8316845260046020526040842060043560040135855260205273ffffffffffffffffffffffffffffffffffffffff62000d8e82604087206200336c565b919054600392831b1c169073ffffffffffffffffffffffffffffffffffffffff8516865260026020526040862060043560040135875260205260408620825f526020525f8460408220828155015573ffffffffffffffffffffffffffffffffffffffff8516865260205260408520905f526020525f60408120550162000cfe565b5073ffffffffffffffffffffffffffffffffffffffff81168252600460205260408220600435600401358352602052604082208054908381558162001334575b5050819082915b62000e6c60246004350160043560040162004859565b9050831015620012565773ffffffffffffffffffffffffffffffffffffffff8216845260036020526040842073ffffffffffffffffffffffffffffffffffffffff62000ed962000ed38662000ecc60246004350160043560040162004859565b90620048b0565b620034fa565b165f5260205260405f205480620011ea575073ffffffffffffffffffffffffffffffffffffffff8216845260036020526040842073ffffffffffffffffffffffffffffffffffffffff62000f4162000ed38662000ecc60246004350160043560040162004859565b165f526020526004356004013560405f205562000f758362000f6e604460043501600435600401620048c1565b9062004918565b73ffffffffffffffffffffffffffffffffffffffff831685526002602052604085206004356004013586526020526040852073ffffffffffffffffffffffffffffffffffffffff62000fdb62000ed38762000ecc60246004350160043560040162004859565b165f526020526001602060405f209280358455013591015573ffffffffffffffffffffffffffffffffffffffff821684526004602052604084206004356004013585526020526040842073ffffffffffffffffffffffffffffffffffffffff6200105962000ed38662000ecc60246004350160043560040162004859565b169080549068010000000000000000821015620011bd579162001089826200110d9460018097950181556200336c565b73ffffffffffffffffffffffffffffffffffffffff829392549160031b92831b921b191617905573ffffffffffffffffffffffffffffffffffffffff84168652600560205260408620600435600401358752602052606460043501356040872055620011058562000f6e604460043501600435600401620048c1565b359062004801565b926200112d62000ed38262000ecc60246004350160043560040162004859565b73ffffffffffffffffffffffffffffffffffffffff6200115d8362000f6e604460043501600435600401620048c1565b916020604051938035855201356020840152169060043560040135907f499f2d584337dd47a4e71a8a4c57b77ad0058bb1a360335a855979a5ca3061d4604073ffffffffffffffffffffffffffffffffffffffff881692a4019162000e56565b6024877f4e487b710000000000000000000000000000000000000000000000000000000081526041600452fd5b60449073ffffffffffffffffffffffffffffffffffffffff6200122162000ed38762000ecc60246004350160043560040162004859565b1690604051917fe21464ba00000000000000000000000000000000000000000000000000000000835260048301526024820152fd5b9091506200126f60246004350160043560040162004859565b9050151590816200131c575b50620012f2576200129760246004350160043560040162004859565b90506040519081527f18fea070ebed40821f9c45ae1f8c875c49b031e4ff3b701b4772ade527f51088602073ffffffffffffffffffffffffffffffffffffffff60043560040135941692a362000683608460043501620045bf565b60046040517f64580a1c000000000000000000000000000000000000000000000000000000008152fd5b600191506200132b9062004ac6565b14155f6200127b565b83526020832090815b81830181106200134e575062000e4f565b5f81556001016200133d565b60046040517fecce9fda000000000000000000000000000000000000000000000000000000008152fd5b60046040517fa16ba7f2000000000000000000000000000000000000000000000000000000008152fd5b506008600435600401351162000cda565b620013ca90620033af565b6200025e57805f62000c94565b82358952602080840135908a01526040988901989092019160010162000c0e565b909197600160208060049373ffffffffffffffffffffffffffffffffffffffff620014238e620032cd565b168152019a01939201905062000bb3565b8480fd5b8280fd5b5080fd5b50346200025e577ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36016101e081126200143c576101a0136200025e576101a467ffffffffffffffff8135818111620004b057620014a3903690600401620031f3565b6101c49291929182359081116200037657620014c4903690600401620031f3565b92909373ffffffffffffffffffffffffffffffffffffffff92836001541691823b156200169d57604051917ff5ba0b1d0000000000000000000000000000000000000000000000000000000083526200152060048401620035f5565b60c435938460c485015260e43595878716808803620016995760e4860152610104803590898216809203620016995786015261012480359b898d16809d036200169957620015a38e9d9688968f98956101c089979588968c9888015261014480359088015261016480359088015261018480359088015286015284019162003785565b03925af19081156200037a57879162001681575b50506200065b620015db6200160d93620006d7620015d4620034d5565b82620044c3565b6040805173ffffffffffffffffffffffffffffffffffffffff909216602083015281019290925281606081016200062e565b600a541691823b1562000872576200166e928492836040518096819582947f3a1505ca0000000000000000000000000000000000000000000000000000000084526200165c60048501620035f5565b60e060c485015260e484019162003785565b03925af18015620004a5576200085f5750f35b6200168c90620033af565b6200037657855f620015b7565b5f80fd5b8880fd5b50346200025e577ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360161020081126200143c576101c0136200025e5767ffffffffffffffff6101c435818111620014385762001703903690600401620031f3565b916101e435908111620004b05762001720903690600401620031f3565b909173ffffffffffffffffffffffffffffffffffffffff6001541690813b156200037657604051907f834a0d48000000000000000000000000000000000000000000000000000000008252600435600483015262001781602483016200365b565b60e43560e483015273ffffffffffffffffffffffffffffffffffffffff61010435166101043503620016995773ffffffffffffffffffffffffffffffffffffffff61010435166101048301526101249283359373ffffffffffffffffffffffffffffffffffffffff85169081860362001699578401526101449081359273ffffffffffffffffffffffffffffffffffffffff8416809403620016995789856200185f819593839c849884968501526101648035908501526101848035908501526101a48035908501526101e06101c48501526101e484019162003785565b03925af19081156200196e57859162001956575b50506200188a9062001884620034d5565b620044c3565b620018d66200062e6200065b620018a46101043562003838565b6040805173ffffffffffffffffffffffffffffffffffffffff909216602083015260e435908201529182906060820190565b73ffffffffffffffffffffffffffffffffffffffff600a541691823b1562000872576200166e928492836040518096819582947f715a86c5000000000000000000000000000000000000000000000000000000008452600435600485015262001942602485016200365b565b61010060e485015261010484019162003785565b6200196190620033af565b6200087257835f62001873565b6040513d87823e3d90fd5b50346200025e5760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e57620019b562003285565b620019bf620032a9565b6044359073ffffffffffffffffffffffffffffffffffffffff9182811680910362001434577f6fee9688c285c5c5c97d6a1a29adced674e6b2ad0888b8ad2116b58a8b3ea24860028154101562001b415760029055303b15158062001b39575b62001b0f577f2b50211693ec91bcfe327771928b74a8f475c508d53e86fca4153bcf0f0e8776557f00000000000000000000000000000000000000000000000000000000000000007f5b5cbfa852c5bd03e540eba853f8faf28a604a4d82bee1091096bfaea14d08c355817fffffffffffffffffffffffff000000000000000000000000000000000000000093168385541617845516906001541617600155807f2801b00eb06461cf9fcb9758b5fafd884ff06a86177386f73b6c49f0bf5a5af0557fbe9b076dc5b65990cca9dd9d7366682482e7817a6f6bc7f4faf4dc32af497f32602060405160028152a180f35b60046040517fb9a621e1000000000000000000000000000000000000000000000000000000008152fd5b508462001a1f565b60246040517f3db738da00000000000000000000000000000000000000000000000000000000815260026004820152fd5b50346200025e5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e5762001bae62003285565b7fe7742ddf0fecd2926e7ef4d6d6e91a7b2f0b1f8805b78953dac8454e86273ed2549073ffffffffffffffffffffffffffffffffffffffff9182339116036200097c57807f675c83682abbc3e7dd47e40515a778fbbde4393395c3dd3588244203c3e4788355167f69f201bc2089b9be6195d876d97a0136b4cf56bbf8986a52dcb50697f7d1cac58280a280f35b50346200025e5760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e5762001c8662001c7c62003285565b60243590620039d6565b90919260405193849360608501918552602090151560208601526060604086015283518092526020608086019401925b82811062001cc657505050500390f35b83518552869550938101939281019260010162001cb6565b50346200025e578062001cf136620032ef565b9190939273ffffffffffffffffffffffffffffffffffffffff91826001541691823b15620004a15762001d72928892836040518096819582947fde4030ed00000000000000000000000000000000000000000000000000000000845262001d5d8d6004860190620037c3565b6102006101e485015261020484019162003785565b03925af190811562001e1b57869162001e03575b505062001daa62001d9b6101208501620034fa565b620007f96101408601620034fa565b62001db96101008401620045bf565b845416803b1562001434576200166e93858094604051968795869485937fc655a23d0000000000000000000000000000000000000000000000000000000085526004850162003801565b62001e0e90620033af565b6200143457845f62001d86565b6040513d88823e3d90fd5b50346200025e57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e57602073ffffffffffffffffffffffffffffffffffffffff7f2b50211693ec91bcfe327771928b74a8f475c508d53e86fca4153bcf0f0e87765416604051908152f35b50346200025e57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e576020604051608c8152f35b50346200025e57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e57602060405173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b50346200025e57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e5760207f18e50ee9696440d335192aeeeffc26f47782eaa914f1700d8ad36d6d7f7261b35473ffffffffffffffffffffffffffffffffffffffff60405191168152f35b50346200025e57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e5760207fe7742ddf0fecd2926e7ef4d6d6e91a7b2f0b1f8805b78953dac8454e86273ed25473ffffffffffffffffffffffffffffffffffffffff60405191168152f35b50346200025e5760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e576200206862003285565b6044359173ffffffffffffffffffffffffffffffffffffffff80921681526004602052604081206024358252602052604081209081548410156200025e5750602092620020b5916200336c565b9190546040519260031b1c168152f35b50346200025e57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e57602060405173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b50346200025e57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e57608060065460075460085460095491604051938452602084015260408301526060820152f35b50346200025e57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e5773ffffffffffffffffffffffffffffffffffffffff807f18e50ee9696440d335192aeeeffc26f47782eaa914f1700d8ad36d6d7f7261b35416331415908162002283575b50620022535760017f3d13b7e57307bea7f94c474c597247d2da93d7de9136f8e123ed6525f50bbcec557f9e87fac88ff661f02d44f95383c817fece4bce600a3dab7a54406878b965e7528180a180f35b60246040517ff7987a92000000000000000000000000000000000000000000000000000000008152336004820152fd5b90507fe7742ddf0fecd2926e7ef4d6d6e91a7b2f0b1f8805b78953dac8454e86273ed254163314155f62002202565b50346200025e57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e576020620022f033620046a6565b73ffffffffffffffffffffffffffffffffffffffff60405191168152f35b50346200025e57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e57602060405160108152f35b50346200025e5760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e576200238662003285565b9073ffffffffffffffffffffffffffffffffffffffff80921681526020906004825260408120602435825282526040812090604051808484549182815201908194845285842090845b818110620024235750505081620023e891038262003465565b6040519380850191818652518092526040850193925b8281106200240c5785850386f35b8351871685529381019392810192600101620023fe565b8254891684529287019260019283019201620023cf565b50346200025e57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e5760207f3d13b7e57307bea7f94c474c597247d2da93d7de9136f8e123ed6525f50bbcec546040519015158152f35b50346200025e57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e57602060405173ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b50346200025e5760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e576200254662003285565b604062002552620032a9565b9273ffffffffffffffffffffffffffffffffffffffff809316815260036020522091165f52602052602060405f2054604051908152f35b50346200025e5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e576020620022f0620006d762003285565b50346200025e5780620025de36620032ef565b9190939273ffffffffffffffffffffffffffffffffffffffff91826001541691823b15620004a1576200264a928892836040518096819582947ff50c862800000000000000000000000000000000000000000000000000000000845262001d5d8d6004860190620037c3565b03925af190811562001e1b578691620026cc575b50506200267362001d9b6101208501620034fa565b620026826101008401620045bf565b845416803b1562001434576200166e93858094604051968795869485937faac3454b0000000000000000000000000000000000000000000000000000000085526004850162003801565b620026d790620033af565b6200143457845f6200265e565b50346200025e5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e576200272062003285565b7fe7742ddf0fecd2926e7ef4d6d6e91a7b2f0b1f8805b78953dac8454e86273ed2549073ffffffffffffffffffffffffffffffffffffffff9182339116036200097c57807f18e50ee9696440d335192aeeeffc26f47782eaa914f1700d8ad36d6d7f7261b355167fa4336c0cb1e245b95ad204faed7e940d6dc999684fd8b5e1ff597a0c4efca8ab8280a280f35b50346200025e5760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e57604060209173ffffffffffffffffffffffffffffffffffffffff6200280462003285565b16815260058352818120602435825283522054604051908152f35b50346200025e5760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e576200285b62003285565b62002865620032a9565b60017f6fee9688c285c5c5c97d6a1a29adced674e6b2ad0888b8ad2116b58a8b3ea2488181541015620029e2578190557f2801b00eb06461cf9fcb9758b5fafd884ff06a86177386f73b6c49f0bf5a5af092818455303b151580620029da575b62001b0f57303b151580620029d2575b62001b0f5773ffffffffffffffffffffffffffffffffffffffff937fe7742ddf0fecd2926e7ef4d6d6e91a7b2f0b1f8805b78953dac8454e86273ed29185835416620029a8577fbe9b076dc5b65990cca9dd9d7366682482e7817a6f6bc7f4faf4dc32af497f32956020958894339055337f4ffd725fc4a22075e9ec71c59edf9c38cdeb588a91b24fc5b61388c5be41282b5f80a2817fffffffffffffffffffffffff0000000000000000000000000000000000000000931683865416178555169084541617835555604051908152a180f35b60046040517fe43bdd4e000000000000000000000000000000000000000000000000000000008152fd5b5084620028d5565b5084620028c5565b602482604051907f3db738da0000000000000000000000000000000000000000000000000000000082526004820152fd5b50346200025e57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e5773ffffffffffffffffffffffffffffffffffffffff807f18e50ee9696440d335192aeeeffc26f47782eaa914f1700d8ad36d6d7f7261b35416331415908162002ad8575b506200225357807f3d13b7e57307bea7f94c474c597247d2da93d7de9136f8e123ed6525f50bbcec557fa45f47fdea8a1efdd9029a5691c7f759c32b7c698632b563573e155625d169338180a180f35b90507fe7742ddf0fecd2926e7ef4d6d6e91a7b2f0b1f8805b78953dac8454e86273ed254163314155f62002a88565b50346200025e57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc60608136011262002d4b5767ffffffffffffffff6004358181116200087257803603926101009081818601126200037657602435848111620003855762002b7c903690600401620031f3565b94604435908111620004a15762002b98903690600401620031f3565b93909573ffffffffffffffffffffffffffffffffffffffff92836001541692833b1562002d4757604051917f191190bc000000000000000000000000000000000000000000000000000000008352604060048401527ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffefd89600401359b018b121562002d435762002c6794838d8162002c768f8e9983978e6044602462002c508f968a9e848b01526004886101448c019201016200372d565b9501803560648901529d019d608487018f620036c1565b85840301602486015262003785565b03925af190811562002d38578a9162002d20575b505062002cad62002c9f62002cb393620034fa565b620007f960648901620034fa565b620045bf565b86541691823b15620003855762002d10956200166e60049389979388946040519a8b998a9889977fb557198f0000000000000000000000000000000000000000000000000000000089526040828a0152604489019201016200372d565b9285840301602486015262003785565b62002d2b90620033af565b6200169d57885f62002c8a565b6040513d8c823e3d90fd5b8b80fd5b8a80fd5b50fd5b50346200025e57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e5760207f5b5cbfa852c5bd03e540eba853f8faf28a604a4d82bee1091096bfaea14d08c35473ffffffffffffffffffffffffffffffffffffffff60405191168152f35b50346200025e57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e57602073ffffffffffffffffffffffffffffffffffffffff60015416604051908152f35b50346200025e5760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e5762002e5162003285565b60443573ffffffffffffffffffffffffffffffffffffffff8082168092036200169957604093849182519462002e8786620033f1565b82865282602080970152168152600284528181206024358252845220905f528152815f2090825162002eb981620033f1565b8160018454948584520154910190815283519283525190820152f35b50346200025e5762002ee73662003224565b9073ffffffffffffffffffffffffffffffffffffffff62002f0f620006d760608601620034fa565b169260405193806020860152604082013560408601526040855262002f34856200342b565b62002f43602083013562004929565b6002811490811562002f83575b501562002f705762002f6a620006839562000665620034a7565b6200424e565b91620006839493916200065b936200424e565b60019150145f62002f50565b50346200025e57807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126200025e5773ffffffffffffffffffffffffffffffffffffffff6020915416604051908152f35b50346200169957610100367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc01818112620016995760e013620016995760e43567ffffffffffffffff8111620016995762003042903690600401620031f3565b73ffffffffffffffffffffffffffffffffffffffff92916024359184831683036200169957846001541691823b156200169957620030d2925f92836040518096819582947f8008e3490000000000000000000000000000000000000000000000000000000084526004359b8c6004860152620030c1602486016200365b565b60e485015261010484019162003785565b03925af180156200315e5762003148575b50604435928084168403620016995762003111826200310b62000683966200065b95620044c3565b620046a6565b166200062e604051938492602084016020909392919373ffffffffffffffffffffffffffffffffffffffff60408201951681520152565b62003155919450620033af565b5f925f620030e3565b6040513d5f823e3d90fd5b34620016995760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011262001699576004359073ffffffffffffffffffffffffffffffffffffffff821680920362001699576020915f527f81796b4965de195665289d95668a8a9e7020858e15f5341c42bcf9951c1768ad825260ff60405f20541615158152f35b9181601f84011215620016995782359167ffffffffffffffff83116200169957602083818601950101116200169957565b907ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc820161014081126200169957610120136200169957600491610124359067ffffffffffffffff821162001699576200328191600401620031f3565b9091565b6004359073ffffffffffffffffffffffffffffffffffffffff821682036200169957565b6024359073ffffffffffffffffffffffffffffffffffffffff821682036200169957565b359073ffffffffffffffffffffffffffffffffffffffff821682036200169957565b907ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc8201610220811262001699576101e013620016995760049167ffffffffffffffff916101e4358381116200169957826200334e91600401620031f3565b939093926102043591821162001699576200328191600401620031f3565b805482101562003382575f5260205f2001905f90565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b67ffffffffffffffff8111620033c457604052565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b6040810190811067ffffffffffffffff821117620033c457604052565b6080810190811067ffffffffffffffff821117620033c457604052565b6060810190811067ffffffffffffffff821117620033c457604052565b6020810190811067ffffffffffffffff821117620033c457604052565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff821117620033c457604052565b60405190620034b6826200340e565b6006548252600754602083015260085460408301526009546060830152565b6101043573ffffffffffffffffffffffffffffffffffffffff81168103620016995790565b3573ffffffffffffffffffffffffffffffffffffffff81168103620016995790565b90357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1823603018112156200169957016020813591019167ffffffffffffffff821162001699578160061b360383136200169957565b359081151582036200169957565b620035b26020809273ffffffffffffffffffffffffffffffffffffffff620035a882620032cd565b1685520162003572565b1515910152565b916020908281520191905f5b818110620035d35750505090565b90919280620035e56001928662003580565b60409081019401929101620035c5565b60043573ffffffffffffffffffffffffffffffffffffffff908181168091036200169957825260243581811680910362001699576020830152604435908116809103620016995760408201526064356060820152608435608082015260a060a435910152565b60243573ffffffffffffffffffffffffffffffffffffffff90818116809103620016995782526044358181168091036200169957602083015260643590811680910362001699576040820152608435606082015260a435608082015260a060c435910152565b60a0809173ffffffffffffffffffffffffffffffffffffffff80620036e683620032cd565b16855280620036f860208401620032cd565b1660208601526200370c60408301620032cd565b16604085015260608101356060850152608081013560808501520135910152565b6200378290604080620037786200375a6101006200374c86806200351c565b9091808a52890191620035b9565b6200376960208601866200351c565b9088830360208a0152620035b9565b94019101620036c1565b90565b601f82602094937fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe093818652868601375f8582860101520116010190565b620037ff91620037d4818362003580565b620037e66040820160408401620036c1565b61010080830135908201526101208091019101620036c1565b565b9062003782939162003829610120926200381c838262003580565b60408084019101620036c1565b81610100820152019162003785565b600b6055917fa7061a14e3ecf6b6005ae012e8d4e1b45b16518ae5b5553dad6dcd441776ee67604091825173ffffffffffffffffffffffffffffffffffffffff6020927fc4d66de8000000000000000000000000000000000000000000000000000000008484015216602482015260248152620038b5816200342b565b620039206200392d8361072f93875190620038d38387018362003465565b8582528282019562004bbc87398851620038f7816200062e86820194308662004677565b895195869362003910868601998a92519283916200460f565b840191518093868401906200460f565b0103808452018262003465565b5190208351938401528201523081520160ff81532090565b67ffffffffffffffff8111620033c45760051b60200190565b906200396a8262003945565b62003979604051918262003465565b8281527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0620039a9829462003945565b0190602036910137565b8051821015620033825760209160051b010190565b519081151582036200169957565b90915f925f73ffffffffffffffffffffffffffffffffffffffff80941694855f52600492602096848852604091825f20815f52895262003a19835f20546200395e565b935f955b855187101562003b6857835f52878b52845f20835f528b5262003a4387865f206200336c565b905490858c8b895193849384927f5b4b96950000000000000000000000000000000000000000000000000000000084528301526080948593602497889360031b1c165afa91821562003b5e57908892915f9262003afc575b50500151918262003aad8a8a620039b3565b525f838201938412911290801582169115161762003ad2575060019096019562003a1d565b6011897f4e487b71000000000000000000000000000000000000000000000000000000005f52525ffd5b8193508092503d831162003b56575b62003b17818362003465565b810103126200169957865187918e62003b30836200340e565b8151835280820151908301528281015183830152606080910151908201525f8062003a9b565b503d62003b0b565b88513d5f823e3d90fd5b92955090989398979697959295829762003b838b516200395e565b965f9973__$48c01f32ffc70665c84e0e05fd3a471bff$__945b8d518c101562003cf3578a8e62003c128e865f528b8d52835f20895f528d528c8862003bcc83875f206200336c565b929054908a5f5260028152875f20908d5f5252865f209260031b1c165f528d526001845f2094519462003bff86620033f1565b805486520154928d8501938452620039b3565b51908d51927fffc39dba000000000000000000000000000000000000000000000000000000008452518b84015251602483015288604483015260648201528b816084818a5af4801562003ce957908d92918c5f925f9262003c99575b5060019462003c7d91620039b3565b52811562003c90575b509b019a62003b9d565b90505f62003c86565b94505050508b82813d831162003ce1575b62003cb6818362003465565b810103126200169957818b62003c7d8f8d62003cd4600197620039c8565b9401519291509462003c6e565b503d62003caa565b8c513d5f823e3d90fd5b9b99509b50505050505050509150565b92915f9380519460209384830151961560011715620042215762003d3f96670de0b6b3a764000097889162003d39489162004827565b62004845565b04906040906060828601519501519051608c810180911162004221576004957f0fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82168203620041f5578351917ff5d6ded700000000000000000000000000000000000000000000000000000000835289838981606c5afa928315620040c35790888d9493925f94620041b8575b508462003dee62003d399462003d3962003dfd98999562003df6951b62004827565b049162004827565b9062004801565b049262003e0b848462004801565b9573ffffffffffffffffffffffffffffffffffffffff998a7f2b50211693ec91bcfe327771928b74a8f475c508d53e86fca4153bcf0f0e8776541697845180997ffeaf968c000000000000000000000000000000000000000000000000000000008252818a60a09c8d935afa908115620041ae575f916200415d575b508281029080820584149015171562004131576305f5e1009005905f821262004102579062003eb69162004845565b048382805181010312620016995788820151918b8316809303620016995784015164e8d4a5100090818102918183041490151715620040d65780821015620040cd5750955b813b15620016995783517f0b220c3900000000000000000000000000000000000000000000000000000000815287828201525f60248201525f8160448183875af18015620040c357620040ad575b508351917f23b872dd000000000000000000000000000000000000000000000000000000008a8401526024830152306044830152866064830152606482528782019082821067ffffffffffffffff8311176200408157509962003ff962004066927ffa0333956d06e335c550bd5fc4ac9c003c6545e371331b1071fa4d5d8519d6c19a9b9c8652827f00000000000000000000000000000000000000000000000000000000000000001662004947565b7f5b5cbfa852c5bd03e540eba853f8faf28a604a4d82bee1091096bfaea14d08c354908451917fa9059cbb000000000000000000000000000000000000000000000000000000008c840152336024840152886044840152604483526200405f836200340e565b1662004947565b815197818952880152860152606085015260808401523392a2565b6041907f4e487b71000000000000000000000000000000000000000000000000000000005f525260245ffd5b620040ba919350620033af565b5f915f62003f49565b85513d5f823e3d90fd5b90509562003efb565b6011887f4e487b71000000000000000000000000000000000000000000000000000000005f525260245ffd5b602489838851917f501f289e000000000000000000000000000000000000000000000000000000008352820152fd5b6011897f4e487b71000000000000000000000000000000000000000000000000000000005f525260245ffd5b90508981813d8311620041a6575b62004177818362003465565b8101031262001699576200418b816200480f565b506200419e60808c83015192016200480f565b505f62003e87565b503d6200416b565b86513d5f823e3d90fd5b9350509092508982813d8311620041ed575b620041d6818362003465565b81010312620016995790518b929091888462003dcc565b503d620041ca565b6011877f4e487b71000000000000000000000000000000000000000000000000000000005f525260245ffd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b6001545f9473ffffffffffffffffffffffffffffffffffffffff918216949390853b1562001699575f80620042e6604098899889519485809481937fc4786d9b0000000000000000000000000000000000000000000000000000000083528b620042b88c620032cd565b16600484015260208b01359d8e60248501528b0135604484015260608b0199620007b1606485018c620036c1565b03925af18015620044b95762004498575b50829162000ed36200430d6200431b93620034fa565b620007f960808401620034fa565b169184517ffc0c546a000000000000000000000000000000000000000000000000000000008152602081600481875afa9081156200448e5787916200444c575b5082807f0000000000000000000000000000000000000000000000000000000000000000169116036200441c571690813b15620014345783517fe1638ba300000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff919091166004820152602481019290925290919083908390604490829084905af1908115620044135750620043ff575050565b6200440b8291620033af565b6200025e5750565b513d84823e3d90fd5b6024838651907f950cd0710000000000000000000000000000000000000000000000000000000082526004820152fd5b90506020813d60201162004485575b816200446a6020938362003465565b81010312620003855751828116810362000385575f6200435b565b3d91506200445b565b86513d89823e3d90fd5b6200431b91975091620044ac8493620033af565b5f979092909150620042f7565b87513d5f823e3d90fd5b9073ffffffffffffffffffffffffffffffffffffffff8080931691168181141592836200451f575b505050620044f557565b60046040517f43e749f8000000000000000000000000000000000000000000000000000000008152fd5b60209293506044905f54169360405194859384927fbd9ee66b000000000000000000000000000000000000000000000000000000008452600484015260248301525afa9081156200315e575f916200457d575b50155f8080620044eb565b90506020813d602011620045b6575b816200459b6020938362003465565b810103126200169957620045af90620039c8565b5f62004572565b3d91506200458c565b620037ff906200065b620045da620006d760208401620034fa565b6040805173ffffffffffffffffffffffffffffffffffffffff909216602083015292359281019290925281606081016200062e565b5f5b838110620046215750505f910152565b818101518382015260200162004611565b907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f60209362004670815180928187528780880191016200460f565b0116010190565b60409073ffffffffffffffffffffffffffffffffffffffff620037829493168152816020820152019062004632565b90604051917fc4d66de800000000000000000000000000000000000000000000000000000000602084015273ffffffffffffffffffffffffffffffffffffffff8091169283602482015260248152620046ff816200342b565b60405161072f8082019082821067ffffffffffffffff831117620033c4577fa7061a14e3ecf6b6005ae012e8d4e1b45b16518ae5b5553dad6dcd441776ee67938392620047549262004bbc8539309062004677565b03905ff580156200315e5716805f527f81796b4965de195665289d95668a8a9e7020858e15f5341c42bcf9951c1768ad60205260405f2060017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00825416179055807f4fe45192317a7d3ad19c3eaa395c0c3a1b7a0f53c3536fb96764c3561a8e9dad5f80a280927f2682a218602b9036c9869f006c5405ee4a1a65267653eb7e286123e5e1afde4c5f80a3565b919082018092116200422157565b519069ffffffffffffffffffff821682036200169957565b90670de0b6b3a7640000918281029281840414901517156200422157565b818102929181159184041417156200422157565b9035907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe18136030182121562001699570180359067ffffffffffffffff82116200169957602001918160051b360383136200169957565b9190811015620033825760051b0190565b9035907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe18136030182121562001699570180359067ffffffffffffffff82116200169957602001918160061b360383136200169957565b9190811015620033825760061b0190565b5f811362004941575f136200493d57600190565b5f90565b50600290565b73ffffffffffffffffffffffffffffffffffffffff166040516200496b81620033f1565b5f806020948584527f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c656486850152858151910182865af13d1562004ab7573d9067ffffffffffffffff8211620033c45762004a049360405192620049f6877fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f840116018562003465565b83523d5f8785013e62004ae5565b80518062004a1157505050565b8183918101031262001699578162004a2a9101620039c8565b1562004a335750565b608490604051907f08c379a00000000000000000000000000000000000000000000000000000000082526004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e60448201527f6f742073756363656564000000000000000000000000000000000000000000006064820152fd5b9162004a049260609162004ae5565b620f42409081811162004ade57106200493d57600190565b5050600290565b9192901562004b63575081511562004afb575090565b3b1562004b055790565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152fd5b82519091501562004b775750805190602001fd5b62004bb7906040519182917f08c379a000000000000000000000000000000000000000000000000000000000835260206004840152602483019062004632565b0390fdfe608060409080825261072f80380380916100198285610342565b833981019082818303126102385761003081610365565b6020828101516001600160401b039391929184821161023857019084601f830112156102385781519161006283610379565b9261006f88519485610342565b8084528484019685828401011161023857868561008c9301610394565b803b156102f0578551635c60da1b60e01b80825292916001600160a01b0316908481600481855afa9081156102e6575f916102b1575b503b15610254577fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d5080546001600160a01b03191682179055865192817f1cf3b03a6cf19fa2baba4df148e9dcabedea7f8a5c07840e207e5c089be95d3e5f80a282511580159061024d575b610140575b87516102c690816104698239f35b6004848693819382525afa918215610243575f92610208575b5085519360608501908111858210176101f4578652602784527f416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c83850152660819985a5b195960ca1b84870152516101de945f918291845af4903d156101eb573d6101c381610379565b906101d088519283610342565b81525f81943d92013e6103b5565b505f808080808080610132565b606092506103b5565b634e487b7160e01b5f52604160045260245ffd5b9091508281813d831161023c575b6102208183610342565b810103126102385761023190610365565b905f610159565b5f80fd5b503d610216565b86513d5f823e3d90fd5b505f61012d565b865162461bcd60e51b815260048101859052603060248201527f455243313936373a20626561636f6e20696d706c656d656e746174696f6e206960448201526f1cc81b9bdd08184818dbdb9d1c9858dd60821b6064820152608490fd5b90508481813d83116102df575b6102c88183610342565b81010312610238576102d990610365565b5f6100c2565b503d6102be565b88513d5f823e3d90fd5b855162461bcd60e51b815260048101849052602560248201527f455243313936373a206e657720626561636f6e206973206e6f74206120636f6e6044820152641d1c9858dd60da1b6064820152608490fd5b601f909101601f19168101906001600160401b038211908210176101f457604052565b51906001600160a01b038216820361023857565b6001600160401b0381116101f457601f01601f191660200190565b5f5b8381106103a55750505f910152565b8181015183820152602001610396565b9192901561041757508151156103c9575090565b3b156103d25790565b60405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606490fd5b82519091501561042a5750805190602001fd5b6044604051809262461bcd60e51b82526020600483015261045a8151809281602486015260208686019101610394565b601f01601f19168101030190fdfe6080806040523661011c5760208160048173ffffffffffffffffffffffffffffffffffffffff7fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d5054167f5c60da1b0000000000000000000000000000000000000000000000000000000082525afa908115610111575f91610081575b50610273565b905060203d60201161010a575b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f82011682019180831067ffffffffffffffff8411176100dd576100d792604052016101f6565b5f61007b565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b503d61008e565b6040513d5f823e3d90fd5b6004602073ffffffffffffffffffffffffffffffffffffffff7fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d505416604051928380927f5c60da1b0000000000000000000000000000000000000000000000000000000082525afa908115610111575f916101975750610273565b602091503d82116101ee575b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f83011681019181831067ffffffffffffffff8411176100dd576100d792604052810190610247565b3d91506101a3565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8060209101126102435760805173ffffffffffffffffffffffffffffffffffffffff811681036102435790565b5f80fd5b90816020910312610243575173ffffffffffffffffffffffffffffffffffffffff811681036102435790565b5f8091368280378136915af43d5f803e1561028c573d5ff35b3d5ffdfea2646970667358221220ec432b4747e143afd3ca9be003efbb7d4ac773fd8dbbac59b6729d6be9a1e1a164736f6c63430008180033a264697066735822122092ac32ec49066ecc1d2732cd373a723def46bfe1fc882018374bbcf00363fef164736f6c63430008180033",
  "libraries": {
    "RebalanceLib": "0xC10C99d010e8C7422f5fF0EBD2604A872Da64307"
  },
  "devdoc": {
    "errors": {
      "ControllerGroupBalancedError()": [
        {
          "custom:error": "Group is balanced and ineligible for rebalance"
        }
      ],
      "ControllerInvalidRebalanceConfigError()": [
        {
          "custom:error": "A RebalanceConfigChange message had a mismatch in number of markets and configs"
        }
      ],
      "ControllerInvalidRebalanceGroupError()": [
        {
          "custom:error": "Group number was out-of-range; each collateral account may have up to 8 groups, indexed 1-8"
        }
      ],
      "ControllerInvalidRebalanceMarketsError()": [
        {
          "custom:error": "Group has too many markets; each group may have 1-4 markets"
        }
      ],
      "ControllerInvalidRebalanceTargetsError()": [
        {
          "custom:error": "The sum of `target` collateral allocations for each market in a group does not total 100%. This could also indicate a duplicate market was in the list."
        }
      ],
      "ControllerInvalidSignerError()": [
        {
          "custom:error": "Signer is not authorized to interact with the specified collateral account"
        }
      ],
      "ControllerMarketAlreadyInGroupError(address,uint256)": [
        {
          "custom:error": "A market in this rebalancing configuration is already a member of a different group",
          "params": {
            "group": "Identifies the group in which the aforementioned market is a member",
            "market": "Identifies which market in the message which is causing the problem"
          }
        }
      ],
      "ControllerUnsupportedMarketError(address)": [
        {
          "custom:error": "Attempt to interact with a Market which does not use DSU as collateral",
          "params": {
            "market": "Market with non-DSU collateral"
          }
        }
      ]
    },
    "events": {
      "AccountDeployed(address,address)": {
        "params": {
          "account": "contract address of the collateral account",
          "owner": "EOA for whom the collateral account was created"
        }
      },
      "GroupRebalanced(address,uint256)": {
        "params": {
          "group": "Identifies the rebalance group within context of owner",
          "owner": "Owner of the collateral account for which the rebalance group was created or modified"
        }
      },
      "RebalanceGroupConfigured(address,uint256,uint256)": {
        "params": {
          "group": "Identifies the rebalance group within context of owner",
          "markets": "Number of markets in the group (0 if group was deleted)",
          "owner": "Owner of the collateral account for which the rebalance group was created or modified"
        }
      },
      "RebalanceMarketConfigured(address,uint256,address,(uint256,uint256))": {
        "params": {
          "group": "Identifies the rebalance group within context of owner",
          "market": "The Perennial market for which this configuration applies",
          "newConfig": "Rebalance configuration for the market, which may or may not have changed",
          "owner": "Owner of the collateral account for which the rebalance group was created or modified"
        }
      }
    },
    "kind": "dev",
    "methods": {
      "acceptOwner()": {
        "details": "Can only be called by the pending owner to ensure correctness. Calls to the `_beforeAcceptOwner` hook      to perform logic before updating ownership."
      },
      "changeRebalanceConfigWithSignature((uint256,address[],(uint256,uint256)[],uint256,(uint256,(address,address,address,uint256,uint256,uint256))),bytes)": {
        "params": {
          "configChange": "Message with new rebalance group configuration",
          "signature": "ERC712 message signature"
        }
      },
      "checkGroup(address,uint256)": {
        "params": {
          "group": "Identifies the group within the context of the owner",
          "owner": "User whose collateral account may be rebalanced using this group"
        },
        "returns": {
          "canRebalance": "True if one or more markets in the group are eligible for rebalancing",
          "groupCollateral": "Sum of ower's collateral across each market in the group",
          "imbalances": "The difference between target and actual collateral for each market"
        }
      },
      "constructor": {
        "details": "Creates instance of Controller which compensates keepers",
        "params": {
          "implementation": "Pristine collateral account contract",
          "keepConfig": "Configuration used to compensate keepers"
        }
      },
      "deployAccountWithSignature(((uint256,(address,address,address,uint256,uint256,uint256))),bytes)": {
        "params": {
          "deployAccountAction": "Message requesting creation of a collateral account",
          "signature": "ERC712 message signature"
        }
      },
      "getAccountAddress(address)": {
        "params": {
          "owner": "Identifies the user whose collateral account address is desired"
        }
      },
      "initialize(address,address)": {
        "params": {
          "marketFactory": "Contract used to validate delegated signers",
          "verifier": "Contract used to validate collateral account message signatures"
        }
      },
      "initialize(address,address,address)": {
        "params": {
          "chainlinkFeed_": "ETH-USD price feed used for calculating keeper compensation",
          "marketFactory_": "Contract used to validate delegated signers",
          "verifier_": "Contract used to validate collateral account message signatures"
        }
      },
      "instances(address)": {
        "params": {
          "instance": "The instance to check"
        },
        "returns": {
          "_0": "Whether the instance is valid"
        }
      },
      "marketTransferWithSignature((address,int256,(uint256,(address,address,address,uint256,uint256,uint256))),bytes)": {
        "params": {
          "marketTransfer": "Message requesting a deposit to or withdrawal from the Market",
          "signature": "ERC712 message signature"
        }
      },
      "pause()": {
        "details": "Can only be called by the pauser"
      },
      "rebalanceConfigs(address,uint256,address)": {
        "params": {
          "group": "Identifies a collection of markets, each with their own configuration",
          "market": "Identifies which Perennial market for which the configuration is desired",
          "owner": "User for whom the collateral account was created"
        }
      },
      "rebalanceGroup(address,uint256)": {
        "params": {
          "group": "Identifies the group within the context of the owner",
          "owner": "User whose collateral account may be rebalanced using this group"
        }
      },
      "rebalanceGroupMarkets(address,uint256)": {
        "params": {
          "group": "Identifies which collection of markets is desired for the owner",
          "owner": "User for whom the collateral account was created"
        },
        "returns": {
          "markets": "Array containing each market in the rebalance group"
        }
      },
      "relayAccessUpdateBatch((((address,bool)[],(address,bool)[],(address,address,address,uint256,uint256,uint256)),(uint256,(address,address,address,uint256,uint256,uint256))),bytes,bytes)": {
        "params": {
          "innerSignature": "Signature of the embedded AccessUpdateBatch message",
          "message": "Request with details needed for keeper compensation",
          "outerSignature": "Signature of the RelayedAccessUpdateBatch message"
        }
      },
      "relayGroupCancellation(((uint256,(address,address,address,uint256,uint256,uint256)),(uint256,(address,address,address,uint256,uint256,uint256))),bytes,bytes)": {
        "params": {
          "innerSignature": "Signature of the embedded GroupCancellation message",
          "message": "Request with details needed for keeper compensation",
          "outerSignature": "Signature of the RelayedGroupCancellation message"
        }
      },
      "relayNonceCancellation(((address,address,address,uint256,uint256,uint256),(uint256,(address,address,address,uint256,uint256,uint256))),bytes,bytes)": {
        "params": {
          "innerSignature": "Signature of the embedded Common message",
          "message": "Request with details needed for keeper compensation",
          "outerSignature": "Signature of the RelayedNonceCancellation message"
        }
      },
      "relayOperatorUpdate((((address,bool),(address,address,address,uint256,uint256,uint256)),(uint256,(address,address,address,uint256,uint256,uint256))),bytes,bytes)": {
        "params": {
          "innerSignature": "Signature of the embedded OperatorUpdate message",
          "message": "Request with details needed for keeper compensation",
          "outerSignature": "Signature of the RelayedOperatorUpdate message"
        }
      },
      "relaySignerUpdate((((address,bool),(address,address,address,uint256,uint256,uint256)),(uint256,(address,address,address,uint256,uint256,uint256))),bytes,bytes)": {
        "params": {
          "innerSignature": "Signature of the embedded SignerUpdate message",
          "message": "Request with details needed for keeper compensation",
          "outerSignature": "Signature of the RelayedSignerUpdate message"
        }
      },
      "unpause()": {
        "details": "Can only be called by the pauser"
      },
      "updatePauser(address)": {
        "details": "Can only be called by the current owner",
        "params": {
          "newPauser": "New pauser address"
        }
      },
      "updatePendingOwner(address)": {
        "details": "Can only be called by the current owner      New owner does not take affect until that address calls `acceptOwner()`",
        "params": {
          "newPendingOwner": "New pending owner address"
        }
      },
      "withdrawWithSignature((uint256,bool,(uint256,(address,address,address,uint256,uint256,uint256))),bytes)": {
        "params": {
          "signature": "ERC712 message signature",
          "withdrawal": "Message requesting a withdrawal"
        }
      }
    },
    "title": "Controller_Arbitrum",
    "version": 1
  },
  "userdoc": {
    "events": {
      "AccountDeployed(address,address)": {
        "notice": "Emitted when a collateral account is deployed"
      },
      "GroupRebalanced(address,uint256)": {
        "notice": "Emitted when a group has been rebalanced"
      },
      "RebalanceGroupConfigured(address,uint256,uint256)": {
        "notice": "Emitted when a rebalance group is created or updated"
      },
      "RebalanceMarketConfigured(address,uint256,address,(uint256,uint256))": {
        "notice": "Emitted for each market in a rebalance group upon creation of the group or when any changes are made to the group"
      }
    },
    "kind": "user",
    "methods": {
      "acceptOwner()": {
        "notice": "Accepts and transfers the ownership of the contract to the pending owner"
      },
      "changeRebalanceConfigWithSignature((uint256,address[],(uint256,uint256)[],uint256,(uint256,(address,address,address,uint256,uint256,uint256))),bytes)": {
        "notice": "Adjusts the rebalancing configuration of one or more markets"
      },
      "checkGroup(address,uint256)": {
        "notice": "Checks all markets in a rebalance group to see if anything may be rebalanced"
      },
      "deployAccount()": {
        "notice": "Deploys the collateral account for msg.sender and returns the address of the account"
      },
      "deployAccountWithSignature(((uint256,(address,address,address,uint256,uint256,uint256))),bytes)": {
        "notice": "Deploys a collateral account via a signed message"
      },
      "getAccountAddress(address)": {
        "notice": "Returns the deterministic address of the collateral account for a user, regardless of whether or not it exists."
      },
      "implementation()": {
        "notice": "The instance implementation address"
      },
      "initialize(address,address)": {
        "notice": "Sets contract addresses used for message verification and token management"
      },
      "initialize(address,address,address)": {
        "notice": "Configures message verification and keeper compensation"
      },
      "instances(address)": {
        "notice": "Returns whether the instance is valid"
      },
      "marketTransferWithSignature((address,int256,(uint256,(address,address,address,uint256,uint256,uint256))),bytes)": {
        "notice": "Transfers tokens between a collateral account and a specified Perennial Market"
      },
      "pause()": {
        "notice": "Pauses the contract"
      },
      "rebalanceConfigs(address,uint256,address)": {
        "notice": "Retrieves rebalance configuration for a specified owner, group, and market"
      },
      "rebalanceGroup(address,uint256)": {
        "notice": "Called by keepers to rebalance an unbalanced group"
      },
      "rebalanceGroupMarkets(address,uint256)": {
        "notice": "Retrieves array of markets in an owner's rebalance group"
      },
      "relayAccessUpdateBatch((((address,bool)[],(address,bool)[],(address,address,address,uint256,uint256,uint256)),(uint256,(address,address,address,uint256,uint256,uint256))),bytes,bytes)": {
        "notice": "Relays a message to MarketFactory to update multiple operators and signers"
      },
      "relayGroupCancellation(((uint256,(address,address,address,uint256,uint256,uint256)),(uint256,(address,address,address,uint256,uint256,uint256))),bytes,bytes)": {
        "notice": "Relays a message to Verifier extension to invalidate a group nonce"
      },
      "relayNonceCancellation(((address,address,address,uint256,uint256,uint256),(uint256,(address,address,address,uint256,uint256,uint256))),bytes,bytes)": {
        "notice": "Relays a message to Verifier extension to invalidate a nonce"
      },
      "relayOperatorUpdate((((address,bool),(address,address,address,uint256,uint256,uint256)),(uint256,(address,address,address,uint256,uint256,uint256))),bytes,bytes)": {
        "notice": "Relays a message to MarketFactory to update status of an operator"
      },
      "relaySignerUpdate((((address,bool),(address,address,address,uint256,uint256,uint256)),(uint256,(address,address,address,uint256,uint256,uint256))),bytes,bytes)": {
        "notice": "Relays a message to MarketFactory to update status of a delegated signer"
      },
      "unpause()": {
        "notice": "Unpauses the contract"
      },
      "updatePauser(address)": {
        "notice": "Updates the new pauser"
      },
      "updatePendingOwner(address)": {
        "notice": "Updates the new pending owner"
      },
      "withdrawWithSignature((uint256,bool,(uint256,(address,address,address,uint256,uint256,uint256))),bytes)": {
        "notice": "Transfers tokens from the collateral account back to the owner of the account"
      }
    },
    "notice": "Controller which compensates keepers for handling or relaying messages on Arbitrum L2.",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 533,
        "contract": "@equilibria/perennial-v2-account/contracts/Controller_Arbitrum.sol:Controller_Arbitrum",
        "label": "marketFactory",
        "offset": 0,
        "slot": "0",
        "type": "t_contract(IMarketFactory)4953"
      },
      {
        "astId": 537,
        "contract": "@equilibria/perennial-v2-account/contracts/Controller_Arbitrum.sol:Controller_Arbitrum",
        "label": "verifier",
        "offset": 0,
        "slot": "1",
        "type": "t_contract(IAccountVerifier)2489"
      },
      {
        "astId": 547,
        "contract": "@equilibria/perennial-v2-account/contracts/Controller_Arbitrum.sol:Controller_Arbitrum",
        "label": "_rebalanceConfigs",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_address,t_mapping(t_uint256,t_mapping(t_address,t_struct(RebalanceConfig)3093_storage)))"
      },
      {
        "astId": 554,
        "contract": "@equilibria/perennial-v2-account/contracts/Controller_Arbitrum.sol:Controller_Arbitrum",
        "label": "marketToGroup",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_address,t_mapping(t_address,t_uint256))"
      },
      {
        "astId": 563,
        "contract": "@equilibria/perennial-v2-account/contracts/Controller_Arbitrum.sol:Controller_Arbitrum",
        "label": "groupToMarkets",
        "offset": 0,
        "slot": "4",
        "type": "t_mapping(t_address,t_mapping(t_uint256,t_array(t_contract(IMarket)4726)dyn_storage))"
      },
      {
        "astId": 571,
        "contract": "@equilibria/perennial-v2-account/contracts/Controller_Arbitrum.sol:Controller_Arbitrum",
        "label": "groupToMaxRebalanceFee",
        "offset": 0,
        "slot": "5",
        "type": "t_mapping(t_address,t_mapping(t_uint256,t_userDefinedValueType(UFixed6)22937))"
      },
      {
        "astId": 1746,
        "contract": "@equilibria/perennial-v2-account/contracts/Controller_Arbitrum.sol:Controller_Arbitrum",
        "label": "keepConfig",
        "offset": 0,
        "slot": "6",
        "type": "t_struct(KeepConfig)19746_storage"
      },
      {
        "astId": 1750,
        "contract": "@equilibria/perennial-v2-account/contracts/Controller_Arbitrum.sol:Controller_Arbitrum",
        "label": "nonceManager",
        "offset": 0,
        "slot": "10",
        "type": "t_contract(IVerifierBase)25333"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_contract(IMarket)4726)dyn_storage": {
        "base": "t_contract(IMarket)4726",
        "encoding": "dynamic_array",
        "label": "contract IMarket[]",
        "numberOfBytes": "32"
      },
      "t_contract(IAccountVerifier)2489": {
        "encoding": "inplace",
        "label": "contract IAccountVerifier",
        "numberOfBytes": "20"
      },
      "t_contract(IMarket)4726": {
        "encoding": "inplace",
        "label": "contract IMarket",
        "numberOfBytes": "20"
      },
      "t_contract(IMarketFactory)4953": {
        "encoding": "inplace",
        "label": "contract IMarketFactory",
        "numberOfBytes": "20"
      },
      "t_contract(IVerifierBase)25333": {
        "encoding": "inplace",
        "label": "contract IVerifierBase",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_mapping(t_address,t_uint256))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => uint256))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_uint256)"
      },
      "t_mapping(t_address,t_mapping(t_uint256,t_array(t_contract(IMarket)4726)dyn_storage))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(uint256 => contract IMarket[]))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_uint256,t_array(t_contract(IMarket)4726)dyn_storage)"
      },
      "t_mapping(t_address,t_mapping(t_uint256,t_mapping(t_address,t_struct(RebalanceConfig)3093_storage)))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(uint256 => mapping(address => struct RebalanceConfig)))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_uint256,t_mapping(t_address,t_struct(RebalanceConfig)3093_storage))"
      },
      "t_mapping(t_address,t_mapping(t_uint256,t_userDefinedValueType(UFixed6)22937))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(uint256 => UFixed6))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_uint256,t_userDefinedValueType(UFixed6)22937)"
      },
      "t_mapping(t_address,t_struct(RebalanceConfig)3093_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct RebalanceConfig)",
        "numberOfBytes": "32",
        "value": "t_struct(RebalanceConfig)3093_storage"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_uint256,t_array(t_contract(IMarket)4726)dyn_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => contract IMarket[])",
        "numberOfBytes": "32",
        "value": "t_array(t_contract(IMarket)4726)dyn_storage"
      },
      "t_mapping(t_uint256,t_mapping(t_address,t_struct(RebalanceConfig)3093_storage))": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => mapping(address => struct RebalanceConfig))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_struct(RebalanceConfig)3093_storage)"
      },
      "t_mapping(t_uint256,t_userDefinedValueType(UFixed6)22937)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => UFixed6)",
        "numberOfBytes": "32",
        "value": "t_userDefinedValueType(UFixed6)22937"
      },
      "t_struct(KeepConfig)19746_storage": {
        "encoding": "inplace",
        "label": "struct IKept.KeepConfig",
        "members": [
          {
            "astId": 19738,
            "contract": "@equilibria/perennial-v2-account/contracts/Controller_Arbitrum.sol:Controller_Arbitrum",
            "label": "multiplierBase",
            "offset": 0,
            "slot": "0",
            "type": "t_userDefinedValueType(UFixed18)22119"
          },
          {
            "astId": 19740,
            "contract": "@equilibria/perennial-v2-account/contracts/Controller_Arbitrum.sol:Controller_Arbitrum",
            "label": "bufferBase",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 19743,
            "contract": "@equilibria/perennial-v2-account/contracts/Controller_Arbitrum.sol:Controller_Arbitrum",
            "label": "multiplierCalldata",
            "offset": 0,
            "slot": "2",
            "type": "t_userDefinedValueType(UFixed18)22119"
          },
          {
            "astId": 19745,
            "contract": "@equilibria/perennial-v2-account/contracts/Controller_Arbitrum.sol:Controller_Arbitrum",
            "label": "bufferCalldata",
            "offset": 0,
            "slot": "3",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "128"
      },
      "t_struct(RebalanceConfig)3093_storage": {
        "encoding": "inplace",
        "label": "struct RebalanceConfig",
        "members": [
          {
            "astId": 3088,
            "contract": "@equilibria/perennial-v2-account/contracts/Controller_Arbitrum.sol:Controller_Arbitrum",
            "label": "target",
            "offset": 0,
            "slot": "0",
            "type": "t_userDefinedValueType(UFixed6)22937"
          },
          {
            "astId": 3092,
            "contract": "@equilibria/perennial-v2-account/contracts/Controller_Arbitrum.sol:Controller_Arbitrum",
            "label": "threshold",
            "offset": 0,
            "slot": "1",
            "type": "t_userDefinedValueType(UFixed6)22937"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_userDefinedValueType(UFixed18)22119": {
        "encoding": "inplace",
        "label": "UFixed18",
        "numberOfBytes": "32"
      },
      "t_userDefinedValueType(UFixed6)22937": {
        "encoding": "inplace",
        "label": "UFixed6",
        "numberOfBytes": "32"
      }
    }
  }
}
